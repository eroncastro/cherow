{"map":"{\"version\":3,\"file\":\"zeparser.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/zeparser.ts\"],\"names\":[],\"mappings\":\"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\"}","code":"import { inspect, $$A_61, $$C_63, $$D_64, $$F_66, $$L_6C, $$V_76, $$W_77, $$PAREN_L_28, $$PAREN_R_29, $$STAR_2A, $$PLUS_2B, $$COMMA_2C, $$DASH_2D, $$DOT_2E, $$FWDSLASH_2F, $$COLON_3A, $$SEMI_3B, $$IS_3D, $$QMARK_3F, $$SQUARE_L_5B, $$SQUARE_R_5D, $$TICK_60, $$CURLY_L_7B, $$CURLY_R_7D, ASSERT, THROW as _THROW, } from './utils';\r\nimport ZeTokenizer, { $EOF, $ERROR, $IDENT, $NUMBER, $NUMBER_HEX, $NUMBER_DEC, $NUMBER_BIN, $NUMBER_OCT, $NUMBER_OLD, $PUNCTUATOR, $REGEX, $REGEXU, $STRING, $STRING_DOUBLE, $STRING_SINGLE, $TICK, $TICK_BAD_ESCAPE, $TICK_BODY, $TICK_HEAD, $TICK_PURE, $TICK_TAIL, COLLECT_TOKENS_NONE, COLLECT_TOKENS_SOLID, COLLECT_TOKENS_ALL, FAIL_HARD, GOAL_MODULE, GOAL_SCRIPT, LF_CAN_FUNC_STMT, LF_CAN_NEW_DOT_TARGET, LF_DO_WHILE_ASI, LF_FOR_REGEX, LF_IN_ASYNC, LF_IN_CONSTRUCTOR, LF_IN_FOR_LHS, LF_IN_FUNC_ARGS, LF_IN_GENERATOR, LF_IN_GLOBAL, LF_IN_ITERATION, LF_IN_SCOPE_ROOT, LF_IN_SWITCH, LF_IN_TEMPLATE, LF_NO_ASI, LF_NO_FLAGS, LF_STRICT_MODE, LF_SUPER_CALL, LF_SUPER_PROP, INITIAL_LEXER_FLAGS, RETURN_SOLID_TOKENS, WEB_COMPAT_OFF, WEB_COMPAT_ON, debug_toktype, } from '../src/zetokenizer';\r\nconst VERSION_EXPONENTIATION = 7;\r\nconst VERSION_ASYNC = 8;\r\nconst VERSION_TRAILING_FUNC_COMMAS = 8;\r\nconst VERSION_ASYNC_GEN = 9;\r\nconst VERSION_OBJECTSPREAD = 9;\r\nconst VERSION_TAGGED_TEMPLATE_BAD_ESCAPES = 9;\r\nconst VERSION_WHATEVER = Infinity;\r\nconst WAS_ASYNC = true;\r\nconst NOT_ASYNC = false;\r\nconst IS_ASYNC_PREFIXED = {};\r\nconst NOT_ASYNC_PREFIXED = {};\r\nconst UNDEF_ASYNC = undefined;\r\nconst WAS_GENERATOR = true;\r\nconst IS_GENERATOR = true;\r\nconst NOT_GENERATOR = false;\r\nconst CALLED_FROM_WRAPPER = true;\r\nconst IS_FUNC_DECL = true;\r\nconst NOT_FUNC_DECL = false;\r\nconst IS_FUNC_EXPR = true;\r\nconst NOT_FUNC_EXPR = false;\r\nconst IDENT_OPTIONAL = true;\r\nconst IDENT_REQUIRED = false;\r\nconst PARSE_VALUE_MAYBE = true;\r\nconst PARSE_VALUE_MUST = false;\r\nconst YIELD_WITHOUT_VALUE = 0;\r\nconst WITH_ASSIGNABLE = 1;\r\nconst WITH_NON_ASSIGNABLE = 2;\r\nconst IS_ARROW = true;\r\nconst NOT_ARROW = false;\r\nconst FROM_STATEMENT_START = 1;\r\nconst FROM_FOR_HEADER = 2;\r\nconst FROM_EXPORT_DECL = 3;\r\nconst FROM_CATCH = 4;\r\nconst FROM_ASYNC_ARG = 5;\r\nconst FROM_OTHER_FUNC_ARG = 6;\r\nconst BINDING_TYPE_NONE = 0;\r\nconst BINDING_TYPE_ARG = 1;\r\nconst BINDING_TYPE_VAR = 2;\r\nconst BINDING_TYPE_LET = 3;\r\nconst BINDING_TYPE_CONST = 4;\r\nconst BINDING_TYPE_CLASS = 5;\r\nconst ASSIGNMENT_IS_INIT = true;\r\nconst ASSIGNMENT_IS_DEFAULT = false;\r\nconst IS_EXPRESSION = {};\r\nconst IS_STATEMENT = {};\r\nconst IS_NEW_ARG = 3;\r\nconst NOT_NEW_ARG = 4;\r\nconst PARSE_DIRECTIVES = true;\r\nconst IGNORE_DIRECTIVES = false;\r\nlet assignableFlag = 0;\r\nconst MIGHT_DESTRUCT = assignableFlag;\r\nconst CANT_DESTRUCT = 1 << assignableFlag;\r\nconst DESTRUCT_ASSIGN_ONLY = 1 << ++assignableFlag;\r\nconst MUST_DESTRUCT = 1 << ++assignableFlag;\r\nconst DESTRUCTIBLE_PIGGY_BACK_WAS_CONSTRUCTOR = 1 << ++assignableFlag;\r\nconst DESTRUCTIBLE_PIGGY_BACK_WAS_PROTO = 1 << ++assignableFlag;\r\nconst DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_OR_YIELD_KEYWORD = 1 << ++assignableFlag;\r\nconst DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_VARNAME = 1 << ++assignableFlag;\r\nconst DESTRUCTIBLE_PIGGY_BACK_SAW_YIELD_VARNAME = 1 << ++assignableFlag;\r\nconst NOT_ASSIGNABLE = 1 << ++assignableFlag;\r\nconst IS_ASSIGNABLE = 1 << ++assignableFlag;\r\nconst NO_SPREAD = 0;\r\nconst LAST_SPREAD = 1;\r\nconst MID_SPREAD = 2;\r\nconst PARSE_INIT = false;\r\nconst SKIP_INIT = true;\r\nconst IS_GROUP_TOPLEVEL = true;\r\nconst NOT_GROUP_TOPLEVEL = false;\r\nconst IS_CLASS_METHOD = true;\r\nconst NOT_CLASS_METHOD = false;\r\nconst IS_EXPORT = true;\r\nconst NOT_EXPORT = false;\r\nconst IS_DyNAMIC_PROPERTY = true;\r\nconst NOT_DyNAMIC_PROPERTY = false;\r\nconst IS_QUASI_TAIL = true;\r\nconst NOT_QUASI_TAIL = false;\r\nconst ARG_NEITHER_SIMPLE_NOR_INIT = 0;\r\nconst ARG_WAS_SIMPLE = 1;\r\nconst ARG_HAD_INIT = 2;\r\nconst ARGS_SIMPLE = true;\r\nconst ARGS_COMPLEX = false;\r\nconst IS_CONSTRUCTOR = true;\r\nconst NOT_CONSTRUCTOR = false;\r\nconst IS_METHOD = true;\r\nconst NOT_METHOD = false;\r\nconst ALLOW_ASSIGNMENT = true;\r\nconst NO_ASSIGNMENT = false;\r\nconst NOT_GETSET = 0;\r\nconst IS_GETTER = 1;\r\nconst IS_SETTER = 2;\r\nconst NOT_EVAL_OR_ARGS = undefined;\r\nconst IS_DELETE_ARG = true;\r\nconst NOT_DELETE_ARG = false;\r\nconst IS_SINGLE_IDENT_WRAP_A = 1;\r\nconst IS_SINGLE_IDENT_WRAP_NA = 2;\r\nconst NOT_SINGLE_IDENT_WRAP_A = 4;\r\nconst NOT_SINGLE_IDENT_WRAP_NA = 8;\r\nconst DELETE_PIGGY_AWAIT_OR_YIELD_KEYWORD = 16;\r\nconst DELETE_PIGGY_AWAIT_VARNAME = 32;\r\nconst DELETE_PIGGY_YIELD_VARNAME = 64;\r\nconst INC_DECL = true;\r\nconst EXC_DECL = false;\r\nconst FROM_CONTINUE = true;\r\nconst FROM_BREAK = false;\r\nconst FOR_SCOPE = 1;\r\nconst BLOCK_SCOPE = 2;\r\nconst ARG_SCOPE = 3;\r\nconst CATCH_SCOPE = 4;\r\nconst SWITCH_SCOPE = 5;\r\nconst DO_NOT_BIND = { var: {}, lexvar: {}, lex: { '#': undefined, type: BLOCK_SCOPE }, _: 'skip bindings in this scope' };\r\nconst SKIP_DUPE_CHECKS = true;\r\nconst CHECK_DUPE_BINDS = false;\r\nconst ORIGIN_IS_VAR_DECL = true;\r\nconst ORIGIN_NOT_VAR_DECL = false;\r\nconst NOT_FUNCTION_STATEMENT = false;\r\nconst UNDEF_EXPORTS = undefined;\r\nconst CHECK_TO_READ = true;\r\nconst CHECK_TO_BIND = false;\r\nASSERT(assignableFlag < 32, '32bit bitfield cannot exceed 32bit', assignableFlag);\r\nfunction ZeParser(code, goalMode = GOAL_SCRIPT, collectTokens = COLLECT_TOKENS_NONE, options = {}) {\r\n    let { webCompat: options_webCompat = WEB_COMPAT_ON, strictMode: options_strictMode = false, astRoot: options_astRoot = null, tokenStorage: options_tokenStorage = [], getTokenizer, allowGlobalReturn = false, targetEsVersion = VERSION_WHATEVER, AST_directiveNodes = false, } = options;\r\n    let tok = ZeTokenizer(code, targetEsVersion, goalMode, collectTokens, options_webCompat, FAIL_HARD, options_tokenStorage);\r\n    ASSERT((targetEsVersion >= 6 && targetEsVersion <= 9) || targetEsVersion === VERSION_WHATEVER, 'version should be 6 7 8 9 or infin');\r\n    let allowTrailingFunctionComma = targetEsVersion >= VERSION_TRAILING_FUNC_COMMAS || targetEsVersion === VERSION_WHATEVER;\r\n    let allowAsyncFunctions = targetEsVersion >= VERSION_ASYNC || targetEsVersion === VERSION_WHATEVER;\r\n    let allowAsyncGenerators = targetEsVersion >= VERSION_ASYNC_GEN || targetEsVersion === VERSION_WHATEVER;\r\n    let allowBadEscapesInTaggedTemplates = targetEsVersion >= VERSION_TAGGED_TEMPLATE_BAD_ESCAPES || targetEsVersion === VERSION_WHATEVER;\r\n    if (getTokenizer)\r\n        getTokenizer(tok);\r\n    let prevtok = null;\r\n    let curtok = null;\r\n    let curtype = 0;\r\n    let curc = 0;\r\n    let catchforofhack = false;\r\n    let asyncExceptionStack = undefined;\r\n    let asyncExceptionSimple = false;\r\n    let traceast = false;\r\n    function THROW(desc, ...args) {\r\n        console.log('\\n');\r\n        console.log('Error in parser:', desc, 'remaining throw args;', args);\r\n        console.log('Error token:', curtok, '\\n' + curtok);\r\n        tok.throw('Parser error! ' + desc);\r\n    }\r\n    function sansFlag(flags, flag) {\r\n        ASSERT(typeof flag === 'number', 'sansFlag flag 1 should be number', flag, flags);\r\n        ASSERT(typeof flags === 'number', 'sansFlag flag 2 should be number', flag, flags);\r\n        return (flags | flag) ^ flag;\r\n    }\r\n    function hasAllFlags(flags1, flags2) {\r\n        ASSERT(typeof flags1 === 'number', 'hasAllFlags flag 1 should be number', flags1, flags2);\r\n        ASSERT(typeof flags2 === 'number', 'hasAllFlags flag 2 should be number', flags1, flags2);\r\n        return (flags1 & flags2) === flags2;\r\n    }\r\n    function hasAnyFlag(flags1, flags2) {\r\n        ASSERT(typeof flags1 === 'number', 'hasAnyFlag flag 1 should be number', flags1, flags2);\r\n        ASSERT(typeof flags2 === 'number', 'hasAnyFlag flag 2 should be number', flags1, flags2);\r\n        return (flags1 & flags2) !== 0;\r\n    }\r\n    function hasNoFlag(flags, flag) {\r\n        ASSERT(typeof flag === 'number', 'hasNoFlag flag 1 should be number', flag, flags);\r\n        ASSERT(typeof flags === 'number', 'hasNoFlag flag 2 should be number', flag, flags);\r\n        return (flags & flag) === 0;\r\n    }\r\n    let _tree = {\r\n        type: 'Program',\r\n    };\r\n    let _path = [_tree];\r\n    let _pnames = ['ROOT'];\r\n    if (options_astRoot) {\r\n        options_astRoot.root = _tree;\r\n        options_astRoot.path = _path;\r\n        options_astRoot.pathNames = _pnames;\r\n    }\r\n    function AST_open(prop, type, explictlyOverwrite = false) {\r\n        if (traceast) {\r\n            console.log('AST_open; write type=' + type + ' to prop=' + prop, explictlyOverwrite);\r\n            console.log('- path (before):', _path.map((o) => o.type).join(' - '));\r\n            console.log('- AST:', inspect(_tree, false, null));\r\n        }\r\n        ASSERT(arguments.length === 2 || arguments.length === 3, '2 args');\r\n        ASSERT(_path.length > 0, 'path shouldnt be empty');\r\n        ASSERT(_pnames.length === _path.length, 'pnames should have as many names as paths');\r\n        ASSERT(typeof prop === 'string' && prop !== 'undefined', 'prop should be string');\r\n        ASSERT(typeof type === 'string' && type !== 'undefined', 'type should be string');\r\n        let node = _path[_path.length - 1];\r\n        let newnode = { type };\r\n        if (Array.isArray(node[prop])) {\r\n            node[prop].push(newnode);\r\n        }\r\n        else if (node[prop] === undefined || explictlyOverwrite) {\r\n            node[prop] = newnode;\r\n        }\r\n        else {\r\n            THROW(`AST_open(${prop}, ${type}, ${explictlyOverwrite}); bad tree? node[${prop}] should be \\`undefined\\` but wasnt (child=${node}, prop=${prop}, type=${type}, node[prop]=${node[prop]})`);\r\n        }\r\n        _path.push(newnode);\r\n        _pnames.push(prop);\r\n        ASSERT(_pnames.length === _path.length, 'pnames should have as many names as paths');\r\n    }\r\n    function AST_close(names) {\r\n        if (traceast) {\r\n            console.log('AST_close(' + names + '), closing', _path[_path.length - 1].type);\r\n            console.log('- path:', _path.map((o) => o.type).join(' - '));\r\n            console.log('- AST:', inspect(_tree, false, null));\r\n        }\r\n        ASSERT(arguments.length === 1, 'expecting one arg');\r\n        ASSERT(_path.length > 0, 'path shouldnt be empty');\r\n        ASSERT(_pnames.length === _path.length, 'pnames should have as many names as paths');\r\n        let was = _path.pop();\r\n        _pnames.pop();\r\n        ASSERT(!names || (typeof names === 'string' && names === was.type) || (names instanceof Array && names.indexOf(was.type) >= 0), 'Expecting to close a node with given name(s), expected: ' + names + ' but closed: ' + was.type);\r\n    }\r\n    function AST_set(prop, value, clobber = false) {\r\n        if (traceast) {\r\n            console.log('AST_set', prop, value);\r\n            console.log('- path:', _path.map((o) => o.type).join(' - '));\r\n            console.log('- AST:', inspect(_tree, false, null));\r\n        }\r\n        ASSERT(typeof prop === 'string', 'prop should be string');\r\n        ASSERT(arguments.length === 2 || arguments.length === 3, 'expecting two args');\r\n        ASSERT(_path.length > 0, 'path shouldnt be empty');\r\n        ASSERT(_pnames.length === _path.length, 'pnames should have as many names as paths');\r\n        ASSERT(clobber !== (_path[_path.length - 1][prop] === undefined), 'dont clobber, prop=' + prop + ', val=' + value);\r\n        _path[_path.length - 1][prop] = value;\r\n    }\r\n    function AST_setIdent(astProp, token, overwrite = false) {\r\n        ASSERT(typeof astProp === 'string', 'prop should be an string');\r\n        ASSERT(typeof token === 'object', 'token should be an obj');\r\n        ASSERT(_path.length > 0, 'path shouldnt be empty');\r\n        ASSERT(_pnames.length === _path.length, 'pnames should have as many names as paths');\r\n        ASSERT(token.type === $IDENT, 'token must be ident');\r\n        AST_open(astProp, 'Identifier', overwrite);\r\n        AST_set('name', token.canon);\r\n        AST_close('Identifier');\r\n    }\r\n    function AST_setLiteral(astProp, token) {\r\n        ASSERT(typeof astProp === 'string', 'prop is string');\r\n        ASSERT(typeof token === 'object', 'token is obj');\r\n        ASSERT(_path.length > 0, 'path shouldnt be empty');\r\n        ASSERT(_pnames.length === _path.length, 'pnames should have as many names as paths');\r\n        ASSERT(hasAnyFlag(token.type, $NUMBER | $STRING | $REGEX), 'should be number or string');\r\n        AST_open(astProp, 'Literal');\r\n        AST_set('value', '<TODO>');\r\n        AST_set('raw', token.str);\r\n        AST_close('Literal');\r\n    }\r\n    function AST_add(prop, value) {\r\n        if (traceast) {\r\n            console.log('ADD', prop, value);\r\n            console.log('- path:', _path.map((o) => o.type).join(' - '));\r\n            console.log('- AST:', inspect(_tree, false, null));\r\n        }\r\n        ASSERT(typeof prop === 'string', 'prop should be string');\r\n        ASSERT(arguments.length === 2, 'expecting two args');\r\n        ASSERT(_path.length > 0, 'path shouldnt be empty');\r\n        ASSERT(_pnames.length === _path.length, 'pnames should have as many names as paths');\r\n        ASSERT(Array.isArray(_path[_path.length - 1][prop]), 'expecting to add to an existing array');\r\n        _path[_path.length - 1][prop].push(value);\r\n    }\r\n    function AST_wrapOpened(prop, newNodeType, newProp) {\r\n        if (traceast) {\r\n            console.log('AST_wrapOpened', prop, newNodeType, newProp);\r\n            console.log('- path:', _path.map((o) => o.type).join(' - '));\r\n            console.log('- tree before:', inspect(_tree, false, null));\r\n        }\r\n        ASSERT(_path.length > 0, 'path shouldnt be empty');\r\n        ASSERT(_pnames.length === _path.length, 'pnames should have as many names as paths');\r\n        let node = _path.pop();\r\n        _pnames.pop();\r\n        let parent = _path[_path.length - 1];\r\n        if (traceast)\r\n            console.log(' - node to wrap:', node, ', prop:', prop, ', parent:', parent);\r\n        if (Array.isArray(parent[prop])) {\r\n            ASSERT(node === parent[prop][parent[prop].length - 1], 'top should be last element of parent[prop]');\r\n            parent[prop].pop();\r\n        }\r\n        else {\r\n            ASSERT(node === parent[prop], 'top should be parent[prop]');\r\n        }\r\n        AST_open(prop, newNodeType, CALLED_FROM_WRAPPER);\r\n        AST_set(newProp, node);\r\n        _path.push(node);\r\n        _pnames.push(newProp);\r\n        if (traceast) {\r\n            console.log('- tree after:', inspect(_tree, false, null));\r\n        }\r\n    }\r\n    function AST_wrapClosed(prop, newNodeType, newProp) {\r\n        if (traceast) {\r\n            console.log('AST_wrapClosed', prop, newNodeType, newProp);\r\n            console.log('- path:', _path.map((o) => o.type).join(' - '));\r\n            console.log('- tree before:', inspect(_tree, false, null));\r\n        }\r\n        ASSERT(AST_wrapClosed.length === arguments.length, 'arg count');\r\n        ASSERT(typeof prop === 'string', 'should be string');\r\n        ASSERT(_path.length > 0, 'path shouldnt be empty');\r\n        ASSERT(_pnames.length === _path.length, 'pnames should have as many names as paths', 'pnames=' + _pnames + ', path=' + _path.map((p) => p.type));\r\n        let parent = _path[_path.length - 1];\r\n        let child = null;\r\n        if (traceast)\r\n            console.log(' - prop:', prop, ', parent:', parent);\r\n        if (Array.isArray(parent[prop])) {\r\n            child = parent[prop].pop();\r\n        }\r\n        else {\r\n            child = parent[prop];\r\n        }\r\n        if (traceast)\r\n            console.log(' - child:', child);\r\n        ASSERT(child, 'AST_wrapClosed(' + prop + ', ' + newNodeType + ',' + newProp + '); node prop `' + prop + '` should exist, bad tree?', 'child=', child, 'prop=', prop, 'newProp=', newProp, 'parent[prop]=', parent[prop]);\r\n        AST_open(prop, newNodeType, CALLED_FROM_WRAPPER);\r\n        AST_set(newProp, child);\r\n        if (traceast) {\r\n            console.log('- tree after:', inspect(_tree, false, null));\r\n        }\r\n    }\r\n    function AST_replaceOpened(newNodeType, oldNodeType) {\r\n        if (traceast) {\r\n            console.log('AST_replaceOpened', oldNodeType, '->', newNodeType);\r\n            console.log('- path:', _pnames.join(' - '));\r\n            console.log('- path:', _path.map((o) => o.type).join(' - '));\r\n            console.log('- tree before:', inspect(_tree, false, null));\r\n        }\r\n        ASSERT(arguments.length === 2, 'expecting 2 args');\r\n        ASSERT(_path.length > 0, 'path shouldnt be empty');\r\n        ASSERT(_pnames.length === _path.length, 'pnames should have as many names as paths');\r\n        let oldNode = _path.pop();\r\n        let parentNode = _path[_path.length - 1];\r\n        let prevProp = _pnames.pop();\r\n        ASSERT(oldNode.type === oldNodeType, 'expecting to replace a certain node (expected=' + oldNodeType + ', found=' + oldNode.type + ')');\r\n        ASSERT((Array.isArray(parentNode[prevProp]) ? parentNode[prevProp][parentNode[prevProp].length - 1] : parentNode[prevProp]) === oldNode, 'should be the target node');\r\n        if (Array.isArray(parentNode[prevProp]))\r\n            parentNode[prevProp].pop();\r\n        AST_open(prevProp, newNodeType, CALLED_FROM_WRAPPER);\r\n        if (traceast) {\r\n            console.log('- tree after:', inspect(_tree, false, null));\r\n        }\r\n        return oldNode;\r\n    }\r\n    function AST_replaceClosed(prop, newNodeType, oldNodeType) {\r\n        if (traceast) {\r\n            console.log('AST_replaceClosed;', prop, ':', oldNodeType, '->', newNodeType);\r\n            console.log('- path:', _pnames.join(' - '));\r\n            console.log('- path:', _path.map((o) => o.type).join(' - '));\r\n            console.log('- tree before:', inspect(_tree, false, null));\r\n        }\r\n        ASSERT(arguments.length === 3, 'expecting 3 args');\r\n        ASSERT(typeof prop === 'string', 'prop=string');\r\n        ASSERT(typeof newNodeType === 'string', 'pronewNodeTypep=string');\r\n        ASSERT(typeof oldNodeType === 'string', 'oldNodeType=string');\r\n        ASSERT(_path.length > 0, 'path shouldnt be empty');\r\n        ASSERT(_pnames.length === _path.length, 'pnames should have as many names as paths');\r\n        let parentNode = _path[_path.length - 1];\r\n        let oldNode = parentNode[prop];\r\n        if (oldNode instanceof Array)\r\n            oldNode = oldNode.pop();\r\n        ASSERT(oldNode, 'Expected a node on property of top', prop);\r\n        ASSERT(!(oldNode instanceof Array), 'node should not be an array');\r\n        ASSERT(oldNode.type !== undefined, 'Nodes should have a type');\r\n        ASSERT(oldNode.type === oldNodeType, 'expecting to replace a certain node (expected=' + oldNodeType + ', found=' + oldNode.type + ') ' + JSON.stringify(oldNode));\r\n        AST_open(prop, newNodeType, CALLED_FROM_WRAPPER);\r\n        if (traceast) {\r\n            console.log('- tree after:', inspect(_tree, false, null));\r\n        }\r\n        return oldNode;\r\n    }\r\n    function AST_replaceParent(newNodeType, oldNodeType) {\r\n        if (traceast) {\r\n            console.log('- path:', _pnames.join(' - '));\r\n            console.log('- path:', _path.map((o) => o.type).join(' - '));\r\n            console.log('- tree before:', inspect(_tree, false, null));\r\n        }\r\n        ASSERT(_path.length > 0, 'path shouldnt be empty');\r\n        ASSERT(_pnames.length === _path.length, 'pnames should have as many names as paths');\r\n        let oldNode = _path.pop();\r\n        let parentNode = _path[_path.length - 1];\r\n        let prevProp = _pnames.pop();\r\n        ASSERT(oldNode.type === oldNodeType, 'expecting to replace a certain node');\r\n        ASSERT((Array.isArray(parentNode[prevProp]) ? parentNode[prevProp][parentNode[prevProp].length - 1] : parentNode[prevProp]) === oldNode, 'should be the target node');\r\n        if (Array.isArray(parentNode[prevProp]))\r\n            parentNode[prevProp].pop();\r\n        AST_open(prevProp, newNodeType, CALLED_FROM_WRAPPER);\r\n        if (traceast) {\r\n            console.log('- tree after:', inspect(_tree, false, null));\r\n        }\r\n        return oldNode;\r\n    }\r\n    function AST_wrapClosedIntoArray(prop, value, newProp, skipArrCheck) {\r\n        if (traceast) {\r\n            console.log('AST_wrapClosedIntoArray', prop, value, newProp);\r\n            console.log('- path:', _path.map((o) => o.type).join(' - '));\r\n            console.log('- tree before:', inspect(_tree, false, null));\r\n        }\r\n        ASSERT(_path.length > 0, 'path shouldnt be empty');\r\n        ASSERT(_pnames.length === _path.length, 'pnames should have as many names as paths');\r\n        let parent = _path[_path.length - 1];\r\n        let child = null;\r\n        if (traceast)\r\n            console.log(' - prop:', prop, ', parent:', parent);\r\n        if (!skipArrCheck && Array.isArray(parent[prop])) {\r\n            child = parent[prop].pop();\r\n        }\r\n        else {\r\n            child = parent[prop];\r\n        }\r\n        if (traceast)\r\n            console.log(' - child:', child);\r\n        ASSERT(child, 'should exist, bad tree?', 'child=', child, 'prop=', prop, 'newProp=', newProp, 'parent[prop]=', parent[prop]);\r\n        AST_open(prop, value, CALLED_FROM_WRAPPER);\r\n        AST_set(newProp, [child]);\r\n        if (traceast) {\r\n            console.log('- tree after:', inspect(_tree, false, null));\r\n        }\r\n    }\r\n    function AST_destruct(prop) {\r\n        if (traceast) {\r\n            console.log('AST_destruct', prop);\r\n            console.log('- path:', _path.map((o) => o.type).join(' - '));\r\n            console.log('- tree before destruct:', inspect(_tree, false, null));\r\n        }\r\n        ASSERT(arguments.length === 1, 'arg count');\r\n        ASSERT(_path.length > 0, 'path shouldnt be empty');\r\n        ASSERT(_pnames.length === _path.length, 'pnames should have as many names as paths');\r\n        let node = _path[_path.length - 1][prop];\r\n        ASSERT(node, 'top[' + prop + '] should be a node');\r\n        if (Array.isArray(node))\r\n            node = node[node.length - 1];\r\n        AST__destruct(node);\r\n        if (traceast) {\r\n            console.log('- tree after destruct:', inspect(_tree, false, null));\r\n        }\r\n    }\r\n    function AST__destruct(node) {\r\n        if (traceast) {\r\n            console.log('AST__destruct', node);\r\n        }\r\n        ASSERT(arguments.length === 1, 'arg count');\r\n        switch (node.type) {\r\n            case 'ArrayExpression':\r\n                node.type = 'ArrayPattern';\r\n                let elements = node.elements;\r\n                for (let i = 0, n = elements.length; i < n; ++i) {\r\n                    let element = elements[i];\r\n                    if (element)\r\n                        AST__destruct(element);\r\n                }\r\n                break;\r\n            case 'ObjectExpression':\r\n                node.type = 'ObjectPattern';\r\n                let properties = node.properties;\r\n                for (let i = 0, n = properties.length; i < n; ++i) {\r\n                    if (properties[i].type === 'Property') {\r\n                        ASSERT(properties[i].value, 'each property should have a value');\r\n                    }\r\n                    else {\r\n                        ASSERT(properties[i].type === 'SpreadElement', 'expecting only properties, spreads, and assignments here');\r\n                        ASSERT(properties[i].argument, 'each property should have a value');\r\n                    }\r\n                    AST__destruct(properties[i]);\r\n                }\r\n                break;\r\n            case 'AssignmentExpression':\r\n                node.type = 'AssignmentPattern';\r\n                if (node.operator !== '=')\r\n                    THROW('The destruturing assignment should be a regular assignment');\r\n                delete node.operator;\r\n                AST__destruct(node.left);\r\n                break;\r\n            case 'Property':\r\n                AST__destruct(node.value);\r\n                break;\r\n            case 'SpreadElement':\r\n                node.type = 'RestElement';\r\n                AST__destruct(node.argument);\r\n                break;\r\n        }\r\n    }\r\n    function init(lexerFlags) {\r\n        do {\r\n            skipRex(lexerFlags);\r\n            if (curtype === $ERROR)\r\n                softError();\r\n        } while (curtype === $ERROR);\r\n    }\r\n    function softError() {\r\n        THROW('Tokenizer error: ' + inspect(curtok, false, null));\r\n    }\r\n    function skipRex(lexerFlags) {\r\n        ASSERT(arguments.length === 1, 'should get all params', arguments);\r\n        ASSERT(typeof lexerFlags === 'number', 'lexerFlags number');\r\n        ASSERT(hasNoFlag(lexerFlags, LF_FOR_REGEX), 'regex flag should not be set anywhere');\r\n        updateToken(tok(lexerFlags | LF_FOR_REGEX, RETURN_SOLID_TOKENS));\r\n        ASSERT(typeof curc === 'number' && curc >= 0 && curc <= 0x10ffff, 'valid c', JSON.stringify(curtok));\r\n    }\r\n    function skipDiv(lexerFlags) {\r\n        ASSERT(arguments.length === 1, 'should get all params', arguments);\r\n        ASSERT(typeof lexerFlags === 'number', 'lexerFlags number');\r\n        ASSERT(hasNoFlag(lexerFlags, LF_FOR_REGEX), 'regex flag should not be set anywhere');\r\n        updateToken(tok(lexerFlags, RETURN_SOLID_TOKENS));\r\n        ASSERT(typeof curc === 'number' && curc >= 0 && curc <= 0x10ffff, 'valid c', JSON.stringify(curtok));\r\n    }\r\n    function updateToken(token) {\r\n        prevtok = curtok;\r\n        curtok = token;\r\n        curtype = curtok.type;\r\n        curc = curtok.c;\r\n    }\r\n    function skipAny(lexerFlags) {\r\n        skipRex(lexerFlags);\r\n        ASSERT(curc !== $$FWDSLASH_2F, 'skip any should not be called when the next char can be fwd slash');\r\n    }\r\n    function ASSERT_skipRex(what, lexerFlags) {\r\n        ASSERT(arguments.length === 2, 'should get all params', arguments);\r\n        ASSERT(typeof lexerFlags === 'number', 'lexerFlags number');\r\n        ASSERT(typeof what === 'number' || typeof what === 'string', 'what number/string');\r\n        if (typeof what === 'string') {\r\n        }\r\n        else {\r\n        }\r\n        skipRex(lexerFlags);\r\n    }\r\n    function ASSERT_skipDiv(what, lexerFlags) {\r\n        ASSERT(arguments.length === 2, 'should get all params', arguments);\r\n        ASSERT(typeof lexerFlags === 'number', 'lexerFlags number');\r\n        ASSERT(typeof what === 'number' || typeof what === 'string', 'what number/string');\r\n        if (typeof what === 'string') {\r\n        }\r\n        else {\r\n            ASSERT(hasAllFlags(curtype, what), 'expecting to skip token with certain type', 'expect:', debug_toktype(what, true), 'actual:', debug_toktype(curtype, true));\r\n        }\r\n        skipDiv(lexerFlags);\r\n    }\r\n    function ASSERT_skipAny(what, lexerFlags) {\r\n        ASSERT_skipDiv(what, lexerFlags);\r\n        ASSERT(curc !== $$FWDSLASH_2F, 'skip any should not be called when the next char can be fwd slash');\r\n    }\r\n    function skipRexOrDie(ord, str, lexerFlags) {\r\n        ASSERT(arguments.length === 3, 'arg count');\r\n        ASSERT(typeof lexerFlags === 'number', 'lexerFlags number');\r\n        if (curc !== ord || str !== curtok.str) {\r\n            THROW('Next char should be [' + str + '] but was [' + curtok.str + ']');\r\n        }\r\n        else {\r\n            skipRex(lexerFlags);\r\n        }\r\n    }\r\n    function skipAnyOrDie(ord, str, lexerFlags) {\r\n        skipRexOrDie(ord, str, lexerFlags);\r\n        ASSERT(curc !== $$FWDSLASH_2F, 'skip any should not be called when the next char can be fwd slash');\r\n    }\r\n    function skipRexOrDieSingleChar(ord, lexerFlags) {\r\n        ASSERT(arguments.length === 2, 'arg count');\r\n        ASSERT(typeof lexerFlags === 'number', 'lexerFlags number');\r\n        if (curc !== ord || curtok.str.length !== 1) {\r\n            THROW('Next ord should be ' + ord + ' (' + String.fromCharCode(ord) + ') but was ' + curc + ' (curc: `' + String.fromCharCode(curc) + '`, token: `' + curtok.str + '`)');\r\n        }\r\n        else {\r\n            ASSERT(curtok.str.length === 1, 'should be len=1');\r\n            skipRex(lexerFlags);\r\n        }\r\n    }\r\n    function skipDivOrDieSingleChar(ord, lexerFlags) {\r\n        ASSERT(arguments.length === 2, 'arg count');\r\n        ASSERT(typeof lexerFlags === 'number', 'lexerFlags number');\r\n        if (curc !== ord) {\r\n            THROW('Next ord should be ' + ord + ' (' + String.fromCharCode(ord) + ') but was ' + curc + ' (curc: `' + String.fromCharCode(curc) + '`, token: `' + curtok.str + '`)');\r\n        }\r\n        else if (curtok.str.length !== 1) {\r\n            THROW('Next token should be the single char `' + String.fromCharCode(ord) + '` but was `' + curtok.str + '`');\r\n        }\r\n        else {\r\n            ASSERT(curtok.str.length === 1, 'should be len=1');\r\n            skipDiv(lexerFlags);\r\n        }\r\n    }\r\n    function skipAnyOrDieSingleChar(ord, lexerFlags) {\r\n        skipRexOrDieSingleChar(ord, lexerFlags);\r\n        ASSERT(curc !== $$FWDSLASH_2F, 'skip any should not be called when the next char can be fwd slash');\r\n    }\r\n    function skipRexIf(str, lexerFlags) {\r\n        ASSERT(typeof lexerFlags === 'number', 'lexerFlags number');\r\n        ASSERT(typeof str === 'string', 'string matches, for now');\r\n        if (curtok.str === str) {\r\n            skipRex(lexerFlags);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function skipAnyIf(str, lexerFlags) {\r\n        let x = skipRexIf(str, lexerFlags);\r\n        ASSERT(!x || curc !== $$FWDSLASH_2F, 'skip any should not be called when the next char can be fwd slash');\r\n        return x;\r\n    }\r\n    function skipIdentSafeSlowAndExpensive(lexerFlags) {\r\n        switch (curtok.str) {\r\n            case 'delete':\r\n            case 'new':\r\n            case 'typeof':\r\n            case 'void':\r\n                ASSERT_skipRex($IDENT, lexerFlags);\r\n                break;\r\n            case 'await':\r\n                if (goalMode === GOAL_MODULE || hasAnyFlag(lexerFlags, LF_IN_ASYNC)) {\r\n                    ASSERT_skipRex($IDENT, lexerFlags);\r\n                }\r\n                else {\r\n                    ASSERT_skipDiv($IDENT, lexerFlags);\r\n                }\r\n                break;\r\n            case 'yield':\r\n                if (hasAnyFlag(lexerFlags, LF_IN_GENERATOR | LF_STRICT_MODE)) {\r\n                    ASSERT_skipRex($IDENT, lexerFlags);\r\n                }\r\n                else {\r\n                    ASSERT_skipDiv($IDENT, lexerFlags);\r\n                }\r\n                break;\r\n            default:\r\n                ASSERT_skipDiv($IDENT, lexerFlags);\r\n        }\r\n    }\r\n    function parseTopLevels(lexerFlags) {\r\n        let scoop = SCOPE_create('_parseTopLevels');\r\n        let exportedNames = {};\r\n        let exportedBindings = {};\r\n        let len = _path.length;\r\n        let bak = _path.slice(0);\r\n        AST_set('body', []);\r\n        let labelSet = { _: 'labelSet' };\r\n        _parseBodyPartsWithDirectives(lexerFlags, scoop, labelSet, exportedNames, exportedBindings, ARGS_SIMPLE, NOT_EVAL_OR_ARGS, 'body');\r\n        ASSERT(_path.length === len, 'should close all that was opened. Open before: ' + JSON.stringify(bak.map((o) => o.type).join(' > ')) + ', open after: ' + JSON.stringify(_path.map((o) => o.type).join(' > ')));\r\n        if (goalMode === GOAL_MODULE) {\r\n            for (let key in exportedBindings) {\r\n                if (key[0] === '#' && key !== '#default' && (scoop.var[key] === undefined && scoop.lex[key] === undefined)) {\r\n                    THROW('Exporting a name that was not bound in global: `' + key.slice(1) + '`');\r\n                }\r\n            }\r\n            ASSERT((function () { for (let key in exportedBindings)\r\n                ASSERT(key[0] !== '#' || exportedBindings[key] === 1, 'key should be 1', exportedBindings[key]); return true; })(), 'all bindings should exist exactly one, or have thrown an error');\r\n        }\r\n    }\r\n    function SCOPE_create(des) {\r\n        let d = des;\r\n        let scoop = {\r\n            var: {},\r\n            lexvar: {},\r\n            lex: {\r\n                '#': undefined,\r\n                type: BLOCK_SCOPE,\r\n                funcs: {},\r\n            },\r\n        };\r\n        ASSERT(scoop._ = 'scope', 'just debugging');\r\n        return scoop;\r\n    }\r\n    function SCOPE_addLexTo(scoop, scopeType, desc) {\r\n        let de = desc;\r\n        let scoop2 = {\r\n            var: scoop.var,\r\n            lexvar: {\r\n                '#': scoop.lexvar,\r\n            },\r\n            lex: {\r\n                '#': scoop.lex,\r\n                type: scopeType,\r\n                funcs: [],\r\n            },\r\n        };\r\n        return scoop2;\r\n    }\r\n    function SCOPE_addBindingAndDedupe(lexerFlags, scoop, name, bindingType, originIsVarDecl) {\r\n        ASSERT(SCOPE_addBindingAndDedupe.length === arguments.length, 'arg count');\r\n        SCOPE_addBinding(lexerFlags, scoop, name, bindingType, CHECK_DUPE_BINDS, originIsVarDecl);\r\n        if (options_webCompat === WEB_COMPAT_ON) {\r\n            scoop.lex.funcs['#' + name] = false;\r\n        }\r\n    }\r\n    function SCOPE_addFuncDeclName(lexerFlags, scoop, name, bindingType, originIsVarDecl) {\r\n        ASSERT(SCOPE_addBindingAndDedupe.length === arguments.length, 'arg count');\r\n        SCOPE_addBinding(lexerFlags, scoop, name, bindingType, CHECK_DUPE_BINDS, originIsVarDecl);\r\n        if (options_webCompat === WEB_COMPAT_ON) {\r\n            if (!scoop.lex.funcs['#' + name])\r\n                scoop.lex.funcs['#' + name] = true;\r\n        }\r\n    }\r\n    function SCOPE_addBinding(lexerFlags, scoop, name, bindingType, dupeChecks, originIsVarDecl) {\r\n        ASSERT(SCOPE_addBinding.length === arguments.length, 'arg count');\r\n        if (scoop === DO_NOT_BIND)\r\n            return;\r\n        let hashed = '#' + name;\r\n        if (bindingType === BINDING_TYPE_VAR) {\r\n            let lex = scoop.lex;\r\n            do {\r\n                let type = lex.type;\r\n                if (lex[hashed] !== undefined) {\r\n                    if (type === CATCH_SCOPE) {\r\n                        if (originIsVarDecl && options_webCompat === WEB_COMPAT_ON) {\r\n                            catchforofhack = true;\r\n                        }\r\n                        else {\r\n                            THROW('Can not redefine the catch-var as same binding');\r\n                        }\r\n                    }\r\n                    else if (type === FOR_SCOPE) {\r\n                        THROW('Tried to define a var which was already bound as a let/const inside a for-header, which is explicitly illegal');\r\n                    }\r\n                    else if (type !== ARG_SCOPE) {\r\n                        if (SCOPE_isDupeLexBindingError(scoop, hashed, lexerFlags) === true) {\r\n                            THROW('Tried to define a var which was already bound as a lexical binding');\r\n                        }\r\n                    }\r\n                }\r\n                lex = lex['#'];\r\n            } while (lex);\r\n            let x = scoop.var[hashed];\r\n            if (x === undefined)\r\n                x = 1;\r\n            else\r\n                ++x;\r\n            scoop.var[hashed] = x;\r\n            let lexvar = scoop.lexvar;\r\n            do {\r\n                lexvar[hashed] = true;\r\n                lexvar = lexvar['#'];\r\n            } while (lexvar);\r\n        }\r\n        else {\r\n            ASSERT(bindingType === BINDING_TYPE_ARG || bindingType === BINDING_TYPE_LET || bindingType === BINDING_TYPE_CONST || bindingType === BINDING_TYPE_NONE, 'only use this for arg, var, let, and const', bindingType);\r\n            let lex = scoop.lex;\r\n            if (dupeChecks === CHECK_DUPE_BINDS) {\r\n                SCOPE_lexParentDupeCheck(lexerFlags, scoop, hashed);\r\n                if (lex[hashed] !== undefined) {\r\n                    if (SCOPE_isDupeLexBindingError(scoop, hashed, lexerFlags) === true) {\r\n                        THROW('Cannot create lexical binding when the name was already bound');\r\n                    }\r\n                }\r\n            }\r\n            let x = lex[hashed];\r\n            if (x === undefined)\r\n                x = 1;\r\n            else if (dupeChecks === CHECK_DUPE_BINDS) {\r\n                ASSERT(x >= 1, 'x is undefined or at least 1');\r\n                if (SCOPE_isDupeLexBindingError(scoop, hashed, lexerFlags) === true) {\r\n                    THROW('Encountered lexical binding `' + hashed.slice(1) + '` that was bound multiple times (let/const/class/etc)');\r\n                }\r\n            }\r\n            else\r\n                ++x;\r\n            lex[hashed] = x;\r\n        }\r\n    }\r\n    function SCOPE_verifyLexical(lexerFlags, scoop, skipParent) {\r\n        let lex = scoop.lex;\r\n        for (let key in lex) {\r\n            if (key[0] === '#' && key.length > 1) {\r\n                if (lex[key] > 1) {\r\n                    return true;\r\n                }\r\n                if (!skipParent)\r\n                    SCOPE_lexParentDupeCheck(lexerFlags, scoop, key);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    function SCOPE_lexParentDupeCheck(lexerFlags, scoop, hashed) {\r\n        ASSERT(SCOPE_lexParentDupeCheck.length === arguments.length, 'arg count');\r\n        let lex = scoop.lex;\r\n        let lexParent = lex['#'];\r\n        if (lexParent !== undefined) {\r\n            if (lexParent.type === ARG_SCOPE && lexParent[hashed] !== undefined) {\r\n                THROW('Cannot use `let` or `const` with the same name as bound to a parameter');\r\n            }\r\n            if (lexParent.type === CATCH_SCOPE && lexParent[hashed] !== undefined) {\r\n                THROW('Double declaration of the same binding name in a `catch` var');\r\n            }\r\n        }\r\n        if (scoop.lexvar[hashed] !== undefined) {\r\n            if (SCOPE_isDupeLexBindingError(scoop, hashed, lexerFlags) === true) {\r\n                THROW('Cannot create lexical binding when the name was already `var` bound');\r\n            }\r\n        }\r\n    }\r\n    function SCOPE_verifyArgs(scoop, wereSimpleArgs) {\r\n        let lex = scoop.lex['#'];\r\n        ASSERT(lex, 'should be in the body of a function/scope where the args have just been parsed into another layer');\r\n        _SCOPE_verifyArgs(lex, wereSimpleArgs);\r\n    }\r\n    function _SCOPE_verifyArgs(lex, wereSimpleArgs) {\r\n        for (let key in lex) {\r\n            if (key[0] === '#' && key.length > 1 && lex[key] > 1) {\r\n                if (wereSimpleArgs === ARGS_COMPLEX) {\r\n                    THROW('Same param name was bound twice and the args are not simple, this is not allowed');\r\n                }\r\n                else {\r\n                    THROW('Same param name `' + key.slice(1) + '` was bound twice, this is not allowed in strict mode');\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function SCOPE_isDupeLexBindingError(scoop, hashed, lexerFlags) {\r\n        if (options_webCompat === WEB_COMPAT_OFF)\r\n            return true;\r\n        if (SCOPE_isFuncDeclOnly(scoop, hashed) === false)\r\n            return true;\r\n        if (hasAnyFlag(lexerFlags, LF_STRICT_MODE))\r\n            return true;\r\n        return false;\r\n    }\r\n    function SCOPE_isFuncDeclOnly(scoop, hashed) {\r\n        ASSERT(options_webCompat === WEB_COMPAT_ON, 'this is only for webcompat');\r\n        ASSERT(scoop.lex && scoop.lex.funcs, 'obj should be there');\r\n        ASSERT(hashed[0] === '#' && hashed !== '#', 'name should be hashed');\r\n        return scoop.lex.funcs[hashed] === true;\r\n    }\r\n    function parseDirectivePrologues(lexerFlags, astProp) {\r\n        ASSERT(arguments.length === parseDirectivePrologues.length, 'arg count');\r\n        while (hasAllFlags(curtype, $STRING)) {\r\n            let stringToken = curtok;\r\n            ASSERT_skipDiv($STRING, lexerFlags);\r\n            if (isDirective()) {\r\n                lexerFlags = parseDirectivePrologue(lexerFlags, stringToken, astProp);\r\n            }\r\n            else {\r\n                _parseFromLiteralStatement(lexerFlags, stringToken, astProp);\r\n            }\r\n        }\r\n        return lexerFlags;\r\n    }\r\n    function parseDirectivePrologue(lexerFlags, stringToken, astProp) {\r\n        ASSERT(arguments.length === parseDirectivePrologue.length, 'arg count');\r\n        let dir = stringToken.str.slice(1, -1);\r\n        if (dir === 'use strict')\r\n            lexerFlags = lexerFlags | LF_STRICT_MODE;\r\n        if (AST_directiveNodes) {\r\n            AST_open(astProp, 'Directive');\r\n            AST_set('directive', dir);\r\n            AST_close('Directive');\r\n        }\r\n        else {\r\n            AST_open(astProp, 'ExpressionStatement');\r\n            AST_setLiteral('expression', stringToken);\r\n            AST_set('directive', dir);\r\n            AST_close('ExpressionStatement');\r\n        }\r\n        parseSemiOrAsi(lexerFlags);\r\n        return lexerFlags;\r\n    }\r\n    function isDirective() {\r\n        if (curc === $$SEMI_3B || curc === $$CURLY_R_7D)\r\n            return true;\r\n        if (!curtok.nl) {\r\n            if (curtype === $EOF)\r\n                return true;\r\n            return false;\r\n        }\r\n        if (curtok.str === '++' || curtok.str === '--')\r\n            return true;\r\n        if (curtype !== $PUNCTUATOR) {\r\n            if (curtok.str === 'in' || curtok.str === 'instanceof') {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function _parseBodyPartsWithDirectives(lexerFlags, scoop, labelSet, exportedNames, exportedBindings, wasSimple, functionNameTokenToVerify, astProp) {\r\n        ASSERT(arguments.length === _parseBodyPartsWithDirectives.length, 'arg count');\r\n        ASSERT(typeof lexerFlags === 'number', 'lexerFlags number');\r\n        let wasStrict = hasAllFlags(lexerFlags, LF_STRICT_MODE);\r\n        let addedLexerFlags = parseDirectivePrologues(LF_NO_FLAGS, 'body');\r\n        if (hasAnyFlag(addedLexerFlags, LF_STRICT_MODE)) {\r\n            if (wasSimple === ARGS_COMPLEX) {\r\n                THROW('Can only declare use strict if func params are \"simple\"');\r\n            }\r\n            if (functionNameTokenToVerify && (functionNameTokenToVerify.str === 'eval' || functionNameTokenToVerify.str === 'arguments')) {\r\n                THROW('Can not use `eval` or `arguments` for a strict mode function');\r\n            }\r\n        }\r\n        if (!wasStrict && hasAnyFlag(addedLexerFlags, LF_STRICT_MODE) && hasNoFlag(lexerFlags, LF_IN_GLOBAL)) {\r\n            SCOPE_verifyArgs(scoop, wasSimple);\r\n        }\r\n        lexerFlags |= addedLexerFlags;\r\n        while (curtype !== $EOF && curc !== $$CURLY_R_7D)\r\n            parseBodyPart(lexerFlags, scoop, { '#': labelSet }, exportedNames, exportedBindings, INC_DECL, astProp);\r\n    }\r\n    function _parseBodyPartsSansDirectives(lexerFlags, scoop, labelSet, includeDeclarations, astProp) {\r\n        ASSERT(arguments.length === _parseBodyPartsSansDirectives.length, 'arg count');\r\n        ASSERT(typeof lexerFlags === 'number', 'lexerFlags number');\r\n        while (curtype !== $EOF && curc !== $$CURLY_R_7D)\r\n            parseNestedBodyPart(lexerFlags, scoop, { '#': labelSet }, includeDeclarations, astProp);\r\n    }\r\n    function parseStatementHeader(lexerFlags, headProp) {\r\n        ASSERT(typeof lexerFlags === 'number', 'lexerflags number');\r\n        skipRexOrDieSingleChar($$PAREN_L_28, lexerFlags);\r\n        parseExpressions(lexerFlags | LF_NO_ASI, ALLOW_ASSIGNMENT, headProp);\r\n        skipRexOrDieSingleChar($$PAREN_R_29, lexerFlags);\r\n    }\r\n    function parseSemiOrAsi(lexerFlags) {\r\n        if (curc === $$FWDSLASH_2F) {\r\n            ASSERT(false, 'Tried to apply ASI but next token starts with forward slash. This could be a legit error. Confirm and make sure parser path is properly setting regex/div flag.', '' + curtok);\r\n            THROW('Cannot apply ASI when next token starts with forward slash (this could very well be a bug in the parser...)');\r\n        }\r\n        if (curc === $$SEMI_3B) {\r\n            ASSERT_skipRex(';', lexerFlags);\r\n        }\r\n        else if (hasAllFlags(lexerFlags, LF_DO_WHILE_ASI)) {\r\n            if (curtok.nl)\r\n                tok.asi();\r\n            else\r\n                THROW('Unable to ASI inside a do-while statement without a newline');\r\n        }\r\n        else {\r\n            ASSERT(hasNoFlag(lexerFlags, LF_NO_ASI), 'this case should have been caught sooner');\r\n            if (curc === $$CURLY_R_7D || curtok.nl || curtype === $EOF) {\r\n                tok.asi();\r\n            }\r\n            else {\r\n                console.log('parse error at curc', curc, String.fromCharCode(curc), curtok.str);\r\n                console.log('current token:', curtok);\r\n                THROW('Unable to ASI, token: ' + curtok);\r\n            }\r\n        }\r\n    }\r\n    function parseNestedBodyPart(lexerFlags, scoop, labelSet, includeDeclarations, astProp) {\r\n        ASSERT(arguments.length === parseNestedBodyPart.length, 'arg count');\r\n        return parseBodyPart(sansFlag(lexerFlags, LF_IN_SCOPE_ROOT), scoop, labelSet, UNDEF_EXPORTS, UNDEF_EXPORTS, includeDeclarations, astProp);\r\n    }\r\n    function parseBodyPart(lexerFlags, scoop, labelSet, exportedNames, exportedBindings, includeDeclarations, astProp) {\r\n        ASSERT(arguments.length === parseBodyPart.length, 'arg count');\r\n        ASSERT(typeof lexerFlags === 'number', 'lexerFlags number');\r\n        ASSERT(hasNoFlag(curtype, $ERROR | $EOF), 'should not have error or eof at this point');\r\n        if (asyncExceptionStack !== undefined) {\r\n            parsePlainArrowAfterAsyncNewline(lexerFlags, scoop, astProp);\r\n            return;\r\n        }\r\n        switch (getGenericTokenType(curtype)) {\r\n            case $IDENT:\r\n                parseIdentStatement(lexerFlags, scoop, labelSet, exportedNames, exportedBindings, includeDeclarations, astProp);\r\n                break;\r\n            case $PUNCTUATOR:\r\n                parsePunctuatorStatement(lexerFlags, scoop, labelSet, astProp);\r\n                break;\r\n            case $NUMBER:\r\n                parseFromLiteralStatement(lexerFlags, astProp);\r\n                break;\r\n            case $STRING:\r\n                parseFromLiteralStatement(lexerFlags, astProp);\r\n                break;\r\n            case $TICK:\r\n                parseTickStatement(lexerFlags, astProp);\r\n                break;\r\n            case $REGEX:\r\n                parseFromLiteralStatement(lexerFlags, astProp);\r\n                break;\r\n            default:\r\n                THROW('Unexpected token', curtok);\r\n        }\r\n    }\r\n    function parsePlainArrowAfterAsyncNewline(lexerFlags, scoop, astProp) {\r\n        ASSERT(curtok.str === '=>', 'if the hack is used the next token must be an arrow');\r\n        ASSERT(!!asyncExceptionStack, 'this should have been asserted at callsite');\r\n        curtok.nl = false;\r\n        AST_open(astProp, 'ExpressionStatement');\r\n        astProp = 'expression';\r\n        AST_open(astProp, 'ArrowFunctionExpression');\r\n        AST_set('params', asyncExceptionStack instanceof Array ? asyncExceptionStack : [asyncExceptionStack]);\r\n        asyncExceptionStack = undefined;\r\n        parseArrowFromPunc(lexerFlags, scoop, NOT_ASYNC, asyncExceptionSimple);\r\n        AST_close('ArrowFunctionExpression');\r\n        AST_close('ExpressionStatement');\r\n    }\r\n    function parseFunction(lexerFlags, scoop, isFuncDecl, isRealFuncExpr, isAsync, optionalIdent, isFunctionStatement, astProp) {\r\n        ASSERT(parseFunction.length === arguments.length, 'arg count');\r\n        ASSERT(typeof lexerFlags === 'number', 'lexerflags number');\r\n        ASSERT_skipAny('function', lexerFlags);\r\n        let isGenerator = false;\r\n        if (skipAnyIf('*', lexerFlags)) {\r\n            if (isAsync && !allowAsyncGenerators) {\r\n                THROW('Async generators are not supported by the current targeted language version, they were introduced in ES9/ES2018');\r\n            }\r\n            isGenerator = true;\r\n        }\r\n        return parseFunctionAfterKeyword(lexerFlags, scoop, isFuncDecl, isRealFuncExpr, isGenerator, isAsync, optionalIdent, NOT_CONSTRUCTOR, NOT_METHOD, NOT_GETSET, isFunctionStatement, astProp);\r\n    }\r\n    function parseFunctionExpression(lexerFlags, isAsync, astProp) {\r\n        ASSERT(typeof isAsync === 'boolean', 'enum');\r\n        let isGenerator = NOT_GENERATOR;\r\n        if (skipAnyIf('*', lexerFlags)) {\r\n            if (isAsync && !allowAsyncGenerators) {\r\n                THROW('Async generators are not supported by the current targeted language version, they were introduced in ES9/ES2018');\r\n            }\r\n            isGenerator = IS_GENERATOR;\r\n        }\r\n        parseFunctionAfterKeyword(lexerFlags, DO_NOT_BIND, NOT_FUNC_DECL, IS_FUNC_EXPR, isGenerator, isAsync, IDENT_REQUIRED, NOT_CONSTRUCTOR, NOT_METHOD, NOT_GETSET, NOT_FUNCTION_STATEMENT, astProp);\r\n    }\r\n    function parseAsyncFunctionDecl(lexerFlags, fromStmtOrExpr, includeDeclarations, scoop, isExport, exportedBindings, astProp) {\r\n        ASSERT(parseAsyncFunctionDecl.length === arguments.length, 'arg count');\r\n        ASSERT(curtok.str === 'function', 'already checked, not yet consumed');\r\n        if (fromStmtOrExpr === IS_STATEMENT && includeDeclarations === EXC_DECL) {\r\n            THROW('Cannot parse a async function declaration here, only expecting statements here');\r\n        }\r\n        let name = parseFunction(lexerFlags, scoop, fromStmtOrExpr === IS_EXPRESSION ? NOT_FUNC_DECL : IS_FUNC_DECL, fromStmtOrExpr === IS_EXPRESSION ? IS_FUNC_EXPR : NOT_FUNC_EXPR, WAS_ASYNC, (isExport === IS_EXPORT || fromStmtOrExpr === IS_EXPRESSION) ? IDENT_OPTIONAL : IDENT_REQUIRED, NOT_FUNCTION_STATEMENT, astProp);\r\n        if (isExport) {\r\n            addBindingToExports(exportedBindings, name);\r\n        }\r\n        return NOT_ASSIGNABLE;\r\n    }\r\n    function parseFunctionAfterKeyword(lexerFlags, outerScoop, isFuncDecl, isRealFuncExpr, isGenerator, isAsync, isIdentOptional, isClassConstructor, isMethod, isGetSet, isFunctionStatement, astProp) {\r\n        ASSERT(arguments.length === parseFunctionAfterKeyword.length, 'arg count must match');\r\n        ASSERT(isGenerator === IS_GENERATOR || isGenerator === NOT_GENERATOR, 'gen enum');\r\n        ASSERT(typeof isAsync === 'boolean', 'enum');\r\n        AST_open(astProp, isFuncDecl === IS_FUNC_DECL ? 'FunctionDeclaration' : 'FunctionExpression');\r\n        ASSERT(!isAsync || allowAsyncFunctions, 'async = es8');\r\n        ASSERT(!isAsync || !isGenerator || allowAsyncGenerators, 'async generators = es9');\r\n        AST_set('generator', isGenerator);\r\n        AST_set('async', isAsync);\r\n        let innerScoop = SCOPE_create('parseFunctionAfterKeyword');\r\n        let functionNameTokenToVerify = NOT_EVAL_OR_ARGS;\r\n        let name = '';\r\n        if (curtype === $IDENT) {\r\n            let bindingFlags = (sansFlag(lexerFlags, LF_IN_GENERATOR | LF_IN_ASYNC)\r\n                |\r\n                    getFuncIdentAsyncGenState(isRealFuncExpr, lexerFlags, isGenerator, isAsync));\r\n            let nameBindingType = (isFuncDecl === IS_FUNC_DECL && ((hasNoFlag(lexerFlags, LF_IN_GLOBAL) || goalMode === GOAL_SCRIPT) && hasAllFlags(lexerFlags, LF_IN_SCOPE_ROOT))) ? BINDING_TYPE_VAR : BINDING_TYPE_LET;\r\n            bindingIdentCheck(curtok, nameBindingType, bindingFlags);\r\n            name = curtok.str;\r\n            if (isFunctionStatement) {\r\n                outerScoop = SCOPE_addLexTo(outerScoop, BLOCK_SCOPE, 'special function statement');\r\n            }\r\n            if (isFuncDecl === IS_FUNC_DECL) {\r\n                SCOPE_addFuncDeclName(lexerFlags, outerScoop, name, nameBindingType, ORIGIN_IS_VAR_DECL);\r\n            }\r\n            else if (isFuncDecl === IS_FUNC_EXPR && isRealFuncExpr) {\r\n                SCOPE_addBindingAndDedupe(lexerFlags, innerScoop, name, nameBindingType, ORIGIN_IS_VAR_DECL);\r\n            }\r\n            innerScoop = SCOPE_addLexTo(innerScoop, BLOCK_SCOPE, 'parseFunctionAfterKeyword');\r\n            functionNameTokenToVerify = curtok;\r\n            AST_setIdent('id', curtok);\r\n            ASSERT_skipAny($IDENT, lexerFlags);\r\n        }\r\n        else if (isFuncDecl === IS_FUNC_DECL && !isIdentOptional) {\r\n            THROW('Function decl missing required ident');\r\n        }\r\n        else {\r\n            AST_set('id', null);\r\n        }\r\n        lexerFlags = resetLexerFlagsForFuncAndArrow(lexerFlags, isGenerator, isAsync, NOT_ARROW);\r\n        if (isClassConstructor === IS_CONSTRUCTOR) {\r\n            ASSERT(isAsync === NOT_ASYNC, 'class constructors are not async');\r\n            ASSERT(isGenerator === NOT_GENERATOR, 'class constructors are not generators');\r\n            ASSERT(isMethod === IS_METHOD, 'class constructors are methods');\r\n            lexerFlags |= LF_IN_CONSTRUCTOR;\r\n        }\r\n        else {\r\n            lexerFlags = sansFlag(lexerFlags, LF_IN_CONSTRUCTOR | LF_SUPER_CALL);\r\n        }\r\n        if (isMethod === IS_METHOD)\r\n            lexerFlags |= LF_SUPER_PROP;\r\n        else\r\n            lexerFlags = sansFlag(lexerFlags, LF_SUPER_PROP);\r\n        parseFunctionFromParams(lexerFlags, innerScoop, isAsync ? FROM_ASYNC_ARG : FROM_OTHER_FUNC_ARG, isFuncDecl === IS_FUNC_DECL ? IS_STATEMENT : IS_EXPRESSION, isGenerator, isClassConstructor, isGetSet, functionNameTokenToVerify, isMethod);\r\n        AST_close(isFuncDecl === IS_FUNC_DECL ? 'FunctionDeclaration' : 'FunctionExpression');\r\n        return name;\r\n    }\r\n    function getFuncIdentGeneratorState(isFuncExpr, enclosingScopeFlags, currentScopeIsGenerator) {\r\n        if (hasAllFlags(enclosingScopeFlags, LF_STRICT_MODE))\r\n            return LF_IN_GENERATOR;\r\n        if (isFuncExpr)\r\n            return currentScopeIsGenerator ? LF_IN_GENERATOR : 0;\r\n        return hasAnyFlag(enclosingScopeFlags, LF_IN_GENERATOR) ? LF_IN_GENERATOR : 0;\r\n    }\r\n    function getFuncIdentAsyncState(isFuncExpr, enclosingScopeFlags, currentScopeIsGenerator) {\r\n        if (goalMode === GOAL_MODULE)\r\n            return LF_IN_ASYNC;\r\n        if (isFuncExpr)\r\n            return currentScopeIsGenerator ? LF_IN_ASYNC : 0;\r\n        return hasAnyFlag(enclosingScopeFlags, LF_IN_ASYNC) ? LF_IN_ASYNC : 0;\r\n    }\r\n    function getFuncIdentAsyncGenState(isFuncExpr, enclosingScopeFlags, currentScopeGenerator, currentScopeAsync) {\r\n        return getFuncIdentGeneratorState(isFuncExpr, enclosingScopeFlags, currentScopeGenerator) |\r\n            getFuncIdentAsyncState(isFuncExpr, enclosingScopeFlags, currentScopeAsync);\r\n    }\r\n    function resetLexerFlagsForFuncAndArrow(lexerFlags, isGenerator, isAsync, funcType) {\r\n        ASSERT(arguments.length === resetLexerFlagsForFuncAndArrow.length, 'arg count');\r\n        lexerFlags = sansFlag(lexerFlags, LF_IN_ASYNC |\r\n            LF_IN_GENERATOR |\r\n            LF_IN_FUNC_ARGS);\r\n        if (isAsync) {\r\n            lexerFlags |= LF_IN_ASYNC;\r\n        }\r\n        if (isGenerator) {\r\n            lexerFlags |= LF_IN_GENERATOR;\r\n        }\r\n        if (funcType === NOT_ARROW)\r\n            lexerFlags = lexerFlags | LF_CAN_NEW_DOT_TARGET;\r\n        return lexerFlags;\r\n    }\r\n    function parseFunctionFromParams(lexerFlags, scoop, bindingFrom, expressionState, isGenerator, isClassConstructor, isGetSet, functionNameTokenToVerify, isMethod) {\r\n        let a = isClassConstructor;\r\n        ASSERT(parseFunctionFromParams.length === arguments.length, 'arg count should match');\r\n        let paramScoop = SCOPE_addLexTo(scoop, ARG_SCOPE, 'parseFunctionFromParams(arg)');\r\n        let wasSimple = parseFuncArguments(lexerFlags | LF_NO_ASI, paramScoop, bindingFrom, isGetSet, isGenerator, isMethod);\r\n        _parseBlockStatement(sansFlag(lexerFlags | LF_IN_SCOPE_ROOT, LF_IN_GLOBAL | LF_IN_SWITCH | LF_IN_ITERATION), SCOPE_addLexTo(paramScoop, BLOCK_SCOPE, 'parseFunctionFromParams(body)'), {}, expressionState, PARSE_DIRECTIVES, wasSimple, functionNameTokenToVerify, INC_DECL, 'body');\r\n    }\r\n    function parseFuncArguments(lexerFlags, scoop, bindingFrom, isGetSet, isGenerator, isMethod) {\r\n        let a = isGenerator;\r\n        ASSERT(arguments.length === parseFuncArguments.length, 'arg count');\r\n        ASSERT(isGetSet === IS_GETTER || isGetSet === IS_SETTER || isGetSet === NOT_GETSET, 'enum');\r\n        lexerFlags = lexerFlags | LF_IN_FUNC_ARGS;\r\n        AST_set('params', []);\r\n        let wasSimple = true;\r\n        if (curc !== $$PAREN_L_28)\r\n            THROW('Must have func arguments next but did not find `(`');\r\n        skipRexOrDieSingleChar($$PAREN_L_28, lexerFlags);\r\n        if (curc === $$PAREN_R_29) {\r\n            if (isGetSet === IS_SETTER) {\r\n                THROW('Setters must have exactly one parameter');\r\n            }\r\n            ASSERT_skipRex(')', lexerFlags);\r\n        }\r\n        else if (isGetSet === IS_GETTER) {\r\n            THROW('Getters can not have any parameters');\r\n        }\r\n        else {\r\n            wasSimple = parseBindings(lexerFlags, scoop, BINDING_TYPE_ARG, bindingFrom, ASSIGNMENT_IS_DEFAULT, isGetSet, SKIP_DUPE_CHECKS, UNDEF_EXPORTS, UNDEF_EXPORTS, 'params');\r\n            AST_destruct('params');\r\n            ASSERT(curc !== $$COMMA_2C, 'the trailing func comma case should already be caught by now');\r\n            skipAnyOrDieSingleChar($$PAREN_R_29, lexerFlags);\r\n        }\r\n        if (isMethod === IS_METHOD || !wasSimple || hasAnyFlag(lexerFlags, LF_STRICT_MODE)) {\r\n            _SCOPE_verifyArgs(scoop.lex, wasSimple);\r\n        }\r\n        return wasSimple;\r\n    }\r\n    function parseIdentStatement(lexerFlags, scoop, labelSet, exportedNames, exportedBindings, includeDeclarations, astProp) {\r\n        ASSERT(parseIdentStatement.length === arguments.length, 'arg count');\r\n        let identToken = curtok;\r\n        switch (curtok.str) {\r\n            case 'async':\r\n                ASSERT_skipAny('async', lexerFlags);\r\n                if (curc === $$COLON_3A)\r\n                    return parseLabeledStatementInstead(lexerFlags, scoop, labelSet, identToken, astProp);\r\n                parseAsyncStatement(lexerFlags, scoop, identToken, NOT_EXPORT, includeDeclarations, UNDEF_EXPORTS, astProp);\r\n                return;\r\n            case 'break':\r\n                parseBreakStatement(lexerFlags, scoop, labelSet, astProp);\r\n                return;\r\n            case 'class':\r\n                if (includeDeclarations === EXC_DECL)\r\n                    THROW('Cannot parse a class declaration here, only excpecting statements here');\r\n                parseClassDeclaration(lexerFlags, scoop, IDENT_REQUIRED, astProp);\r\n                return;\r\n            case 'const':\r\n                if (includeDeclarations === EXC_DECL)\r\n                    THROW('Cannot parse a const declaration here, only excpecting statements here');\r\n                parseConstStatement(lexerFlags, scoop, astProp);\r\n                return;\r\n            case 'continue':\r\n                parseContinueStatement(lexerFlags, scoop, labelSet, astProp);\r\n                return;\r\n            case 'debugger':\r\n                parseDebuggerStatement(lexerFlags, astProp);\r\n                return;\r\n            case 'do':\r\n                parseDoStatement(lexerFlags, scoop, labelSet, astProp);\r\n                return;\r\n            case 'export':\r\n                parseExportStatement(lexerFlags, scoop, exportedNames, exportedBindings, astProp);\r\n                return;\r\n            case 'for':\r\n                parseForStatement(lexerFlags, scoop, labelSet, astProp);\r\n                return;\r\n            case 'function':\r\n                let isFunctionStatement = false;\r\n                if (includeDeclarations === EXC_DECL) {\r\n                    isFunctionStatement = true;\r\n                    if (options_webCompat === WEB_COMPAT_OFF || hasNoFlag(lexerFlags, LF_CAN_FUNC_STMT) || hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n                        THROW('Cannot parse a function declaration here, only excpecting statements here');\r\n                    }\r\n                }\r\n                parseFunction(lexerFlags, scoop, IS_FUNC_DECL, NOT_FUNC_EXPR, NOT_ASYNC, IDENT_REQUIRED, isFunctionStatement, astProp);\r\n                return;\r\n            case 'if':\r\n                parseIfStatement(lexerFlags, scoop, labelSet, astProp);\r\n                return;\r\n            case 'import':\r\n                parseImportDeclaration(lexerFlags, scoop, astProp);\r\n                return;\r\n            case 'let':\r\n                if (includeDeclarations === INC_DECL) {\r\n                    parseLetDeclaration(lexerFlags, scoop, labelSet, astProp);\r\n                }\r\n                else {\r\n                    ASSERT(includeDeclarations === EXC_DECL, 'enum');\r\n                    parseLetExpressionStatement(lexerFlags, scoop, labelSet, astProp);\r\n                }\r\n                return;\r\n            case 'return':\r\n                parseReturnStatement(lexerFlags, astProp);\r\n                return;\r\n            case 'switch':\r\n                parseSwitchStatement(lexerFlags, scoop, labelSet, astProp);\r\n                return;\r\n            case 'throw':\r\n                parseThrowStatement(lexerFlags, astProp);\r\n                return;\r\n            case 'try':\r\n                parseTryStatement(lexerFlags, scoop, labelSet, astProp);\r\n                return;\r\n            case 'var':\r\n                parseVarStatement(lexerFlags, scoop, astProp);\r\n                return;\r\n            case 'while':\r\n                parseWhileStatement(lexerFlags, scoop, labelSet, astProp);\r\n                return;\r\n            case 'with':\r\n                parseWithStatement(lexerFlags, scoop, labelSet, astProp);\r\n                return;\r\n            default:\r\n                parseIdentLabelOrExpressionStatement(lexerFlags, scoop, labelSet, astProp);\r\n                return;\r\n        }\r\n        THROW('Unexpected identifier case');\r\n    }\r\n    function parseFromLiteralStatement(lexerFlags, astProp) {\r\n        let stringToken = curtok;\r\n        skipDiv(lexerFlags);\r\n        _parseFromLiteralStatement(lexerFlags, stringToken, astProp);\r\n    }\r\n    function _parseFromLiteralStatement(lexerFlags, stringToken, astProp) {\r\n        AST_open(astProp, 'ExpressionStatement');\r\n        AST_setLiteral('expression', stringToken);\r\n        parseExpressionAfterLiteral(lexerFlags, 'expression');\r\n        if (curc === $$COMMA_2C) {\r\n            _parseExpressions(lexerFlags, initNotAssignable(0), 'expression');\r\n        }\r\n        AST_close('ExpressionStatement');\r\n        parseSemiOrAsi(lexerFlags);\r\n    }\r\n    function parseTickStatement(lexerFlags, astProp) {\r\n        ASSERT(typeof lexerFlags === 'number', 'lexerFlags number');\r\n        if (hasAllFlags(curtype, $TICK_BAD_ESCAPE)) {\r\n            THROW('Template contained an illegal escape', debug_toktype(curtype, false), '' + curtok);\r\n        }\r\n        AST_open(astProp, 'ExpressionStatement');\r\n        parseTickExpression(lexerFlags, 'expression');\r\n        parseExpressionAfterLiteral(lexerFlags, 'expression');\r\n        if (curc === $$COMMA_2C) {\r\n            _parseExpressions(lexerFlags, initNotAssignable(0), 'expression');\r\n        }\r\n        AST_close('ExpressionStatement');\r\n        parseSemiOrAsi(lexerFlags);\r\n    }\r\n    function parseAsyncStatement(lexerFlags, scoop, asyncIdentToken, isExport, includeDeclarations, exportedBindings, astProp) {\r\n        ASSERT(parseAsyncStatement.length === arguments.length, 'arg count');\r\n        _parseAsync(lexerFlags, scoop, IS_STATEMENT, asyncIdentToken, NOT_NEW_ARG, isExport, ALLOW_ASSIGNMENT, includeDeclarations, exportedBindings, astProp);\r\n    }\r\n    function parseAsyncExpression(lexerFlags, scoop, asyncIdentToken, isNewArg, isExport, allowAssignment, astProp) {\r\n        ASSERT(parseAsyncExpression.length === arguments.length, 'arg count');\r\n        return _parseAsync(lexerFlags, scoop, IS_EXPRESSION, asyncIdentToken, isNewArg, isExport, allowAssignment, EXC_DECL, UNDEF_EXPORTS, astProp);\r\n    }\r\n    function _parseAsync(lexerFlags, scoop, fromStmtOrExpr, asyncIdentToken, isNewArg, isExport, allowAssignment, includeDeclarations, exportedBindings, astProp) {\r\n        ASSERT(_parseAsync.length === arguments.length, 'arg count');\r\n        ASSERT(typeof astProp === 'string', 'astprop = string', astProp);\r\n        ASSERT(asyncIdentToken.str === 'async', 'pass on the async keyword');\r\n        ASSERT(curtok !== asyncIdentToken, 'should have consumed the async keyword');\r\n        if (curtok.str === 'in' || curtok.str === 'instanceof' || curtype === $EOF || !allowAsyncFunctions) {\r\n            return parseExpressionAfterAsyncAsVarName(lexerFlags, fromStmtOrExpr, asyncIdentToken, isNewArg, allowAssignment, astProp);\r\n        }\r\n        let newlineAfterAsync = curtok.nl;\r\n        if (curtype === $IDENT) {\r\n            if (newlineAfterAsync) {\r\n                return parseExpressionAfterAsyncAsVarName(lexerFlags, fromStmtOrExpr, asyncIdentToken, isNewArg, allowAssignment, astProp);\r\n            }\r\n            if (curtok.str === 'function') {\r\n                return parseAsyncFunctionDecl(lexerFlags, fromStmtOrExpr, includeDeclarations, scoop, isExport, exportedBindings, astProp);\r\n            }\r\n            if (allowAssignment === NO_ASSIGNMENT) {\r\n                ASSERT(curtype === $IDENT, 'already confirmed that the next token is an ident');\r\n                ASSERT(!curtok.nl, 'already confirmed that the next token is on the sae line as `async`');\r\n                THROW('Was not allowed to parse an AssignmentExpression but had to parse an arrow (which is considered to be one)');\r\n            }\r\n            return parseParenlessArrowAfterAsync(lexerFlags, scoop, fromStmtOrExpr, astProp);\r\n        }\r\n        if (curc === $$PAREN_L_28) {\r\n            if (fromStmtOrExpr === IS_STATEMENT) {\r\n                AST_open(astProp, 'ExpressionStatement');\r\n                astProp = 'expression';\r\n            }\r\n            if (isNewArg === IS_NEW_ARG) {\r\n                return parseExpressionAfterAsyncAsVarName(lexerFlags, fromStmtOrExpr, asyncIdentToken, isNewArg, allowAssignment, astProp);\r\n            }\r\n            let r = parseGroupToplevels(lexerFlags, fromStmtOrExpr, allowAssignment, asyncIdentToken, newlineAfterAsync ? IS_ASYNC_PREFIXED : NOT_ASYNC_PREFIXED, astProp);\r\n            if (fromStmtOrExpr === IS_STATEMENT) {\r\n                AST_close('ExpressionStatement');\r\n            }\r\n            return r;\r\n        }\r\n        return parseExpressionAfterAsyncAsVarName(lexerFlags, fromStmtOrExpr, asyncIdentToken, isNewArg, allowAssignment, astProp);\r\n    }\r\n    function isAssignable(state) {\r\n        return (state & IS_ASSIGNABLE) === IS_ASSIGNABLE;\r\n    }\r\n    function notAssignable(state) {\r\n        return (state & NOT_ASSIGNABLE) === NOT_ASSIGNABLE;\r\n    }\r\n    function initAssignable(previous) {\r\n        ASSERT(arguments.length === 0 || previous === 0, 'if the previous value was set it should still be 0');\r\n        return IS_ASSIGNABLE;\r\n    }\r\n    function initNotAssignable(previous) {\r\n        ASSERT(arguments.length === 0 || previous === 0, 'if the previous value was set it should still be 0');\r\n        return NOT_ASSIGNABLE;\r\n    }\r\n    function setAssignable(state) {\r\n        return (state | IS_ASSIGNABLE | NOT_ASSIGNABLE) ^ NOT_ASSIGNABLE;\r\n    }\r\n    function setNotAssignable(state) {\r\n        return (state | IS_ASSIGNABLE | NOT_ASSIGNABLE) ^ IS_ASSIGNABLE;\r\n    }\r\n    function mergeAssignable(override, state) {\r\n        return override | ((state | NOT_ASSIGNABLE | IS_ASSIGNABLE) ^ (NOT_ASSIGNABLE | IS_ASSIGNABLE));\r\n    }\r\n    function parseAwait(lexerFlags, awaitIdentToken, isNewArg, allowAssignment, astProp) {\r\n        ASSERT(parseAwait.length === arguments.length, 'arg count');\r\n        ASSERT(awaitIdentToken.str === 'await', 'await token');\r\n        ASSERT(awaitIdentToken !== curtok, 'await should have been skipped');\r\n        if (hasAnyFlag(lexerFlags, LF_IN_ASYNC)) {\r\n            return parseAwaitKeyword(lexerFlags, isNewArg, astProp);\r\n        }\r\n        else if (goalMode === GOAL_SCRIPT) {\r\n            return parseAwaitVar(lexerFlags, awaitIdentToken, isNewArg, allowAssignment, astProp);\r\n        }\r\n        else {\r\n            THROW('Cannot use `await` outside of `async` functions');\r\n        }\r\n    }\r\n    function parseAwaitKeyword(lexerFlags, isNewArg, astProp) {\r\n        if (isNewArg === IS_NEW_ARG) {\r\n            THROW('Cannot `await` as the arg of `new`');\r\n        }\r\n        if (hasAllFlags(lexerFlags, LF_IN_FUNC_ARGS)) {\r\n            THROW('Await is illegal as default arg value');\r\n        }\r\n        AST_open(astProp, 'AwaitExpression');\r\n        parseValue(lexerFlags, NO_ASSIGNMENT, NOT_NEW_ARG, 'argument');\r\n        if (curtok.str === '**') {\r\n            THROW('The lhs of ** can not be this kind of unary expression (syntactically not allowed, you have to wrap something)');\r\n        }\r\n        AST_close('AwaitExpression');\r\n        return NOT_ASSIGNABLE | DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_OR_YIELD_KEYWORD;\r\n    }\r\n    function parseAwaitVar(lexerFlags, awaitIdentToken, isNewArg, allowAssignment, astProp) {\r\n        let assignable = parseAfterVarName(lexerFlags, awaitIdentToken, IS_ASSIGNABLE, allowAssignment, astProp);\r\n        assignable = parseValueTail(lexerFlags, assignable, isNewArg, astProp);\r\n        if (allowAssignment === NO_ASSIGNMENT)\r\n            assignable = setNotAssignable(assignable);\r\n        assignable = parseExpressionFromOp(lexerFlags, assignable, astProp);\r\n        return assignable | DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_VARNAME;\r\n    }\r\n    function parseBlockStatement(lexerFlags, scoop, labelSet, blockType, parseDirectives, wasSimple, includeDeclarations, astProp) {\r\n        return _parseBlockStatement(lexerFlags, scoop, labelSet, blockType, parseDirectives, wasSimple, NOT_EVAL_OR_ARGS, includeDeclarations, astProp);\r\n    }\r\n    function _parseBlockStatement(lexerFlags, scoop, labelSet, blockType, parseDirectives, wasSimple, functionNameTokenToVerify, includeDeclarations, astProp) {\r\n        ASSERT(_parseBlockStatement.length === arguments.length, 'arg count');\r\n        ASSERT(typeof lexerFlags === 'number', 'lexerFlags number');\r\n        let lexerFlagsNoTemplate = sansFlag(lexerFlags, LF_IN_TEMPLATE | LF_NO_ASI | LF_DO_WHILE_ASI);\r\n        AST_open(astProp, 'BlockStatement');\r\n        AST_set('body', []);\r\n        ASSERT_skipRex('{', lexerFlagsNoTemplate);\r\n        if (parseDirectives === PARSE_DIRECTIVES) {\r\n            _parseBodyPartsWithDirectives(lexerFlagsNoTemplate, scoop, labelSet, UNDEF_EXPORTS, UNDEF_EXPORTS, wasSimple, functionNameTokenToVerify, 'body');\r\n        }\r\n        else {\r\n            ASSERT(parseDirectives === IGNORE_DIRECTIVES, 'should be boolean');\r\n            _parseBodyPartsSansDirectives(lexerFlagsNoTemplate, scoop, labelSet, includeDeclarations, 'body');\r\n        }\r\n        if (blockType === IS_EXPRESSION) {\r\n            skipDivOrDieSingleChar($$CURLY_R_7D, lexerFlags);\r\n        }\r\n        else {\r\n            ASSERT(blockType === IS_STATEMENT, 'either expression or not');\r\n            skipRexOrDieSingleChar($$CURLY_R_7D, lexerFlags);\r\n        }\r\n        AST_close('BlockStatement');\r\n        if (curc === $$IS_3D)\r\n            THROW('A statement can not start with object destructuring assignment (because block)');\r\n    }\r\n    function parseBreakStatement(lexerFlags, scoop, labelSet, astProp) {\r\n        let s = scoop;\r\n        ASSERT(arguments.length === parseBreakStatement.length, 'arg count');\r\n        AST_open(astProp, 'BreakStatement');\r\n        ASSERT_skipRex('break', lexerFlags);\r\n        if (curtype === $IDENT && !curtok.nl) {\r\n            AST_setIdent('label', curtok);\r\n            if (!findLabel(labelSet, curtok.str, FROM_BREAK))\r\n                THROW('The label for this `break` was not defined in the current label set, which is illegal');\r\n            ASSERT_skipRex($IDENT, lexerFlags);\r\n        }\r\n        else {\r\n            AST_set('label', null);\r\n            if (hasNoFlag(lexerFlags, LF_IN_ITERATION | LF_IN_SWITCH))\r\n                THROW('Can only `break` inside a `switch` or loop');\r\n        }\r\n        parseSemiOrAsi(lexerFlags);\r\n        AST_close('BreakStatement');\r\n    }\r\n    function findLabel(labelSet, label, checkIteration) {\r\n        let id = '#' + label;\r\n        let failIfFound = checkIteration === FROM_CONTINUE;\r\n        do {\r\n            if (labelSet[id]) {\r\n                if (failIfFound) {\r\n                    THROW('Cannot `continue` to this label because it was defined inside the current inner-most loop');\r\n                }\r\n                return true;\r\n            }\r\n            if (failIfFound && labelSet['##'])\r\n                failIfFound = false;\r\n            labelSet = labelSet['#'];\r\n        } while (labelSet);\r\n        return false;\r\n    }\r\n    function parseClassDeclaration(lexerFlags, scoop, optionalIdent, astProp) {\r\n        ASSERT(arguments.length === parseClassDeclaration.length, 'expecting all args');\r\n        lexerFlags = sansFlag(lexerFlags | LF_STRICT_MODE, LF_IN_CONSTRUCTOR);\r\n        ASSERT_skipAny('class', lexerFlags);\r\n        AST_open(astProp, 'ClassDeclaration');\r\n        let name = parseClassId(lexerFlags, optionalIdent, scoop);\r\n        _parseClass(lexerFlags, scoop, IS_STATEMENT);\r\n        AST_close('ClassDeclaration');\r\n        return name;\r\n    }\r\n    function parseClassExpression(lexerFlags, astProp) {\r\n        ASSERT(arguments.length === parseClassExpression.length, 'expecting all args');\r\n        lexerFlags = sansFlag(lexerFlags | LF_STRICT_MODE, LF_IN_CONSTRUCTOR);\r\n        AST_open(astProp, 'ClassExpression');\r\n        parseClassId(lexerFlags, IDENT_OPTIONAL, DO_NOT_BIND);\r\n        let assignable = _parseClass(lexerFlags, DO_NOT_BIND, IS_EXPRESSION);\r\n        AST_close('ClassExpression');\r\n        return setNotAssignable(assignable);\r\n    }\r\n    function parseClassId(lexerFlags, optionalIdent, scoop) {\r\n        ASSERT(parseClassId.length === arguments.length, 'arg count');\r\n        ASSERT(hasAllFlags(lexerFlags, LF_STRICT_MODE) && hasNoFlag(lexerFlags, LF_IN_CONSTRUCTOR), 'should be set by caller');\r\n        let bindingName = '';\r\n        if (curtype === $IDENT && curtok.str !== 'extends') {\r\n            bindingIdentCheck(curtok, BINDING_TYPE_CLASS, lexerFlags);\r\n            bindingName = curtok.str;\r\n            SCOPE_addBindingAndDedupe(lexerFlags, scoop, bindingName, BINDING_TYPE_LET, ORIGIN_NOT_VAR_DECL);\r\n            AST_setIdent('id', curtok);\r\n            ASSERT_skipAny($IDENT, lexerFlags);\r\n        }\r\n        else if (!optionalIdent) {\r\n            THROW('Class decl missing required ident, `extends` is not a valid variable name');\r\n        }\r\n        else {\r\n            AST_set('id', null);\r\n        }\r\n        return bindingName;\r\n    }\r\n    function _parseClass(lexerFlags, scoop, isExpression) {\r\n        ASSERT(arguments.length === _parseClass.length, 'expecting all args');\r\n        ASSERT(hasAllFlags(lexerFlags, LF_STRICT_MODE) && hasNoFlag(lexerFlags, LF_IN_CONSTRUCTOR), 'should be set by caller');\r\n        let assignable = 0;\r\n        if (curtype === $IDENT && curtok.str === 'extends') {\r\n            ASSERT_skipRex('extends', lexerFlags);\r\n            assignable = parseValue(lexerFlags | LF_NO_ASI, NO_ASSIGNMENT, NOT_NEW_ARG, 'superClass');\r\n            lexerFlags |= LF_SUPER_CALL;\r\n        }\r\n        else {\r\n            AST_set('superClass', null);\r\n            lexerFlags = sansFlag(lexerFlags, LF_SUPER_CALL);\r\n        }\r\n        lexerFlags |= LF_SUPER_PROP;\r\n        assignable |= parseClassbody(lexerFlags, scoop, BINDING_TYPE_NONE, isExpression, 'body');\r\n        return assignable;\r\n    }\r\n    function parseConstStatement(lexerFlags, scoop, astProp) {\r\n        ASSERT_skipAny('const', lexerFlags);\r\n        parseAnyVarDecls(lexerFlags, scoop, BINDING_TYPE_CONST, FROM_STATEMENT_START, SKIP_DUPE_CHECKS, UNDEF_EXPORTS, UNDEF_EXPORTS, astProp);\r\n        if (SCOPE_verifyLexical(lexerFlags, scoop, false))\r\n            THROW('Const binding attempted to get at least one name bound more than once');\r\n        parseSemiOrAsi(lexerFlags);\r\n    }\r\n    function parseContinueStatement(lexerFlags, scoop, labelSet, astProp) {\r\n        ASSERT(arguments.length === parseContinueStatement.length, 'arg count');\r\n        let sc = scoop;\r\n        AST_open(astProp, 'ContinueStatement');\r\n        if (hasNoFlag(lexerFlags, LF_IN_ITERATION))\r\n            THROW('Can only `continue` inside a loop');\r\n        ASSERT_skipRex('continue', lexerFlags);\r\n        if (curtype === $IDENT && !(curtok.nl || curtype === $EOF || curtok.value === ';')) {\r\n            AST_setIdent('label', curtok);\r\n            if (!findLabel(labelSet, curtok.str, FROM_CONTINUE))\r\n                THROW('The label for this `continue` was not defined in the current label set, which is illegal');\r\n            ASSERT_skipRex($IDENT, lexerFlags);\r\n        }\r\n        else {\r\n            AST_set('label', null);\r\n        }\r\n        parseSemiOrAsi(lexerFlags);\r\n        AST_close('ContinueStatement');\r\n    }\r\n    function parseDebuggerStatement(lexerFlags, astProp) {\r\n        AST_open(astProp, 'DebuggerStatement');\r\n        AST_close('DebuggerStatement');\r\n        ASSERT_skipRex('debugger', lexerFlags);\r\n        parseSemiOrAsi(lexerFlags);\r\n    }\r\n    function parseDoStatement(lexerFlags, scoop, labelSet, astProp) {\r\n        ASSERT(arguments.length === parseDoStatement.length, 'arg count');\r\n        AST_open(astProp, 'DoWhileStatement');\r\n        ASSERT_skipRex('do', lexerFlags);\r\n        parseNestedBodyPart((curc !== $$CURLY_L_7B ? lexerFlags | LF_DO_WHILE_ASI : lexerFlags) | LF_IN_ITERATION, scoop, { '##': 'dowhile', '#': labelSet }, EXC_DECL, 'body');\r\n        skipAnyOrDie($$W_77, 'while', lexerFlags);\r\n        parseStatementHeader(lexerFlags, 'test');\r\n        parseSemiOrAsi(lexerFlags);\r\n        AST_close('DoWhileStatement');\r\n    }\r\n    function parseExportStatement(lexerFlags, scoop, exportedNames, exportedBindings, astProp) {\r\n        ASSERT(parseExportStatement.length === arguments.length, 'arg count');\r\n        if (goalMode !== GOAL_MODULE)\r\n            THROW('The `export` keyword can only be used with the module goal');\r\n        if (hasNoFlag(lexerFlags, LF_IN_GLOBAL))\r\n            THROW('The `export` keyword is only supported at the top level');\r\n        if (hasNoFlag(lexerFlags, LF_IN_SCOPE_ROOT))\r\n            THROW('The `export` keyword can not be nested in another statement');\r\n        ASSERT_skipAny('export', lexerFlags);\r\n        let needsSemi = true;\r\n        if (curc === $$D_64 && curtok.str === 'default') {\r\n            AST_open(astProp, 'ExportDefaultDeclaration');\r\n            ASSERT_skipRex('default', lexerFlags);\r\n            if (curtok.str === 'class') {\r\n                let exportedName = parseClassDeclaration(lexerFlags, scoop, IDENT_OPTIONAL, 'declaration');\r\n                SCOPE_addBindingAndDedupe(lexerFlags, scoop, '*default*', BLOCK_SCOPE, ORIGIN_NOT_VAR_DECL);\r\n                addNameToExports(exportedNames, 'default');\r\n                addBindingToExports(exportedBindings, '*default*');\r\n                addBindingToExports(exportedBindings, exportedName);\r\n                needsSemi = false;\r\n            }\r\n            else if (curc === $$F_66 && curtok.str === 'function') {\r\n                let exportedName = parseFunction(lexerFlags, scoop, IS_FUNC_DECL, NOT_FUNC_EXPR, NOT_ASYNC, IDENT_OPTIONAL, NOT_FUNCTION_STATEMENT, 'declaration');\r\n                SCOPE_addBindingAndDedupe(lexerFlags, scoop, '*default*', BLOCK_SCOPE, ORIGIN_NOT_VAR_DECL);\r\n                addNameToExports(exportedNames, 'default');\r\n                addBindingToExports(exportedBindings, '*default*');\r\n                addBindingToExports(exportedBindings, exportedName);\r\n                needsSemi = false;\r\n            }\r\n            else if (curc === $$A_61 && curtok.str === 'async') {\r\n                let identToken = curtok;\r\n                ASSERT_skipRex('async', lexerFlags);\r\n                if (curtok.str === 'function') {\r\n                    parseAsyncStatement(lexerFlags, scoop, identToken, IS_EXPORT, INC_DECL, exportedBindings, 'declaration');\r\n                    SCOPE_addBindingAndDedupe(lexerFlags, scoop, '*default*', BLOCK_SCOPE, ORIGIN_NOT_VAR_DECL);\r\n                    addNameToExports(exportedNames, 'default');\r\n                    addBindingToExports(exportedBindings, '*default*');\r\n                    needsSemi = false;\r\n                }\r\n                else {\r\n                    parseAsyncExpression(lexerFlags, scoop, identToken, NOT_NEW_ARG, IS_EXPORT, ALLOW_ASSIGNMENT, 'declaration');\r\n                    SCOPE_addBindingAndDedupe(lexerFlags, scoop, '*default*', BLOCK_SCOPE, ORIGIN_NOT_VAR_DECL);\r\n                    addNameToExports(exportedNames, 'default');\r\n                    addBindingToExports(exportedBindings, '*default*');\r\n                }\r\n            }\r\n            else {\r\n                parseExpression(lexerFlags, ALLOW_ASSIGNMENT, 'declaration');\r\n                SCOPE_addBindingAndDedupe(lexerFlags, scoop, '*default*', BLOCK_SCOPE, ORIGIN_NOT_VAR_DECL);\r\n                addNameToExports(exportedNames, 'default');\r\n                addBindingToExports(exportedBindings, '*default*');\r\n            }\r\n            AST_close('ExportDefaultDeclaration');\r\n        }\r\n        else if (curc === $$STAR_2A) {\r\n            AST_open(astProp, 'ExportAllDeclaration');\r\n            ASSERT_skipAny('*', lexerFlags);\r\n            skipAnyOrDie($$F_66, 'from', lexerFlags);\r\n            AST_setLiteral('source', curtok);\r\n            skipRex(lexerFlags);\r\n            AST_close('ExportAllDeclaration');\r\n        }\r\n        else {\r\n            AST_open(astProp, 'ExportNamedDeclaration');\r\n            AST_set('specifiers', []);\r\n            if (curc === $$CURLY_L_7B) {\r\n                AST_set('declaration', null);\r\n                let tmpExportedNames = [];\r\n                let tmpExportedBindings = [];\r\n                parseExportObject(lexerFlags, tmpExportedNames, tmpExportedBindings);\r\n                if (skipAnyIf('from', lexerFlags)) {\r\n                    if (hasNoFlag(curtype, $STRING))\r\n                        THROW('Export source must be a string');\r\n                    AST_setLiteral('source', curtok);\r\n                    skipRex(lexerFlags);\r\n                }\r\n                else {\r\n                    AST_set('source', null);\r\n                    for (let i = 0, l = tmpExportedNames.length; i < l; ++i)\r\n                        addNameToExports(exportedNames, tmpExportedNames[i]);\r\n                    for (let i = 0, l = tmpExportedBindings.length; i < l; ++i)\r\n                        addBindingToExports(exportedBindings, tmpExportedBindings[i]);\r\n                }\r\n            }\r\n            else if (curc === $$V_76 && curtok.str === 'var') {\r\n                ASSERT_skipAny('var', lexerFlags);\r\n                parseAnyVarDecls(lexerFlags, scoop, BINDING_TYPE_VAR, FROM_EXPORT_DECL, SKIP_DUPE_CHECKS, exportedNames, exportedBindings, 'declaration');\r\n                AST_set('source', null);\r\n            }\r\n            else if (curc === $$L_6C && curtok.str === 'let') {\r\n                ASSERT_skipAny('let', lexerFlags);\r\n                parseAnyVarDecls(lexerFlags, scoop, BINDING_TYPE_LET, FROM_EXPORT_DECL, SKIP_DUPE_CHECKS, exportedNames, exportedBindings, 'declaration');\r\n                if (SCOPE_verifyLexical(lexerFlags, scoop, false))\r\n                    THROW('Let export binding attempted to get at least one name bound twice or more');\r\n                AST_set('source', null);\r\n            }\r\n            else if (curc === $$C_63) {\r\n                if (curtok.str === 'const') {\r\n                    ASSERT_skipAny('const', lexerFlags);\r\n                    parseAnyVarDecls(lexerFlags, scoop, BINDING_TYPE_CONST, FROM_EXPORT_DECL, SKIP_DUPE_CHECKS, exportedNames, exportedBindings, 'declaration');\r\n                    if (SCOPE_verifyLexical(lexerFlags, scoop, false))\r\n                        THROW('Const export binding attempted to get at least one name bound twice or more');\r\n                }\r\n                else if (curtok.str === 'class') {\r\n                    let exportedName = parseClassDeclaration(lexerFlags, scoop, IDENT_REQUIRED, 'declaration');\r\n                    addNameToExports(exportedNames, exportedName);\r\n                    addBindingToExports(exportedBindings, exportedName);\r\n                    needsSemi = false;\r\n                }\r\n                else {\r\n                    THROW('Unknown export type [' + curtok.str + '] (note: you can only export individual vars through `export {foo};)');\r\n                }\r\n                AST_set('source', null);\r\n            }\r\n            else if (curc === $$F_66 && curtok.str === 'function') {\r\n                let exportedName = parseFunction(lexerFlags, scoop, IS_FUNC_DECL, NOT_FUNC_EXPR, NOT_ASYNC, IDENT_REQUIRED, NOT_FUNCTION_STATEMENT, 'declaration');\r\n                addNameToExports(exportedNames, exportedName);\r\n                addBindingToExports(exportedBindings, exportedName);\r\n                AST_set('source', null);\r\n                needsSemi = false;\r\n            }\r\n            else if (curc === $$A_61 && curtok.str === 'async') {\r\n                ASSERT_skipAny('async', lexerFlags);\r\n                if (curtok.str !== 'function') {\r\n                    THROW('Can only export async functions (not arrows), did not find a function');\r\n                }\r\n                if (curtok.nl) {\r\n                    THROW('Async can not be followed by a newline as it results in `export async;`, which is not valid (and probably not what you wanted)');\r\n                }\r\n                let exportedName = parseFunction(lexerFlags, scoop, IS_FUNC_DECL, NOT_FUNC_EXPR, WAS_ASYNC, IDENT_REQUIRED, NOT_FUNCTION_STATEMENT, 'declaration');\r\n                addNameToExports(exportedNames, exportedName);\r\n                addBindingToExports(exportedBindings, exportedName);\r\n                AST_set('source', null);\r\n                needsSemi = false;\r\n            }\r\n            else {\r\n                THROW('Unknown export type [' + curtok.str + '] (note: you can only export individual vars through `export {' + curtok.str + '};`)');\r\n            }\r\n            AST_close('ExportNamedDeclaration');\r\n        }\r\n        if (needsSemi) {\r\n            parseSemiOrAsi(lexerFlags);\r\n        }\r\n    }\r\n    function addNameToExports(exportList, exportedName) {\r\n        ASSERT(exportList !== DO_NOT_BIND, 'use UNDEF_EXPORTS not DO_NOT_BIND');\r\n        if (exportList !== undefined && exportedName !== '') {\r\n            let hashed = '#' + exportedName;\r\n            if (exportList[hashed])\r\n                THROW('Tried to export the name `' + exportedName + '` twice');\r\n            exportList[hashed] = 1;\r\n        }\r\n    }\r\n    function addBindingToExports(exportList, exportedName) {\r\n        ASSERT(exportList !== DO_NOT_BIND, 'use UNDEF_EXPORTS not DO_NOT_BIND');\r\n        if (exportList !== undefined && exportedName !== '') {\r\n            let hashed = '#' + exportedName;\r\n            exportList[hashed] = 1;\r\n        }\r\n    }\r\n    function parseExportObject(lexerFlags, tmpExportedNames, tmpExportedBindings) {\r\n        ASSERT(parseExportObject.length === arguments.length, 'arg count');\r\n        let lexerFlagsNoTemplate = sansFlag(lexerFlags, LF_IN_TEMPLATE);\r\n        ASSERT_skipAny('{', lexerFlagsNoTemplate);\r\n        while (curtype === $IDENT) {\r\n            AST_open('specifiers', 'ExportSpecifier');\r\n            let nameToken = curtok;\r\n            AST_setIdent('local', nameToken);\r\n            skipAny(lexerFlagsNoTemplate);\r\n            if (curtype === $IDENT && curtok.str === 'as') {\r\n                ASSERT_skipAny('as', lexerFlagsNoTemplate);\r\n                if (curtype !== $IDENT)\r\n                    THROW('Can only use ident to indicate alias');\r\n                AST_setIdent('exported', curtok);\r\n                tmpExportedNames.push(curtok.str);\r\n                tmpExportedBindings.push(nameToken.str);\r\n                skipAny(lexerFlagsNoTemplate);\r\n            }\r\n            else {\r\n                AST_setIdent('exported', nameToken);\r\n                tmpExportedNames.push(nameToken.str);\r\n                tmpExportedBindings.push(nameToken.str);\r\n            }\r\n            if (curc === $$COMMA_2C)\r\n                skipAny(lexerFlagsNoTemplate);\r\n            else if (curc !== $$CURLY_R_7D)\r\n                THROW('Unexpected token while parsing export object');\r\n            AST_close('ExportSpecifier');\r\n        }\r\n        if (curtok.str !== '}') {\r\n            console.log('Error: Invalid export token: ' + curtok);\r\n            if (curtok.str === '...')\r\n                THROW('Export object cannot have spread');\r\n            if (curtok.str === ':')\r\n                THROW('Export object uses `as` to alias (`{a as y}`), not colon (`{a: y}`)');\r\n            THROW('Export object can only have \"shorthand\" `{x}` or \"as\" `{x as y}');\r\n        }\r\n        skipAnyOrDieSingleChar($$CURLY_R_7D, lexerFlags);\r\n    }\r\n    function parseForStatement(lexerFlags, scoop, labelSet, astProp) {\r\n        ASSERT(arguments.length === parseForStatement.length, 'arg count');\r\n        scoop = SCOPE_addLexTo(scoop, FOR_SCOPE, 'parseForStatement(header)');\r\n        ASSERT_skipAny('for', lexerFlags);\r\n        let awaitable = curtype === $IDENT && curtok.str === 'await';\r\n        if (awaitable) {\r\n            if (!allowAsyncGenerators)\r\n                THROW('The `for await` syntax is not supported by the currently targeted language version');\r\n            ASSERT_skipAny('await', lexerFlags);\r\n        }\r\n        skipRexOrDieSingleChar($$PAREN_L_28, lexerFlags);\r\n        parseForHeader(lexerFlags | LF_NO_ASI, scoop, awaitable, astProp);\r\n        skipRexOrDieSingleChar($$PAREN_R_29, lexerFlags);\r\n        parseNestedBodyPart(lexerFlags | LF_IN_ITERATION, scoop, { '##': 'for', '#': labelSet }, EXC_DECL, 'body');\r\n        AST_close(['ForStatement', 'ForInStatement', 'ForOfStatement']);\r\n    }\r\n    function parseForHeader(lexerFlags, scoop, awaitable, astProp) {\r\n        ASSERT(arguments.length === parseForHeader.length, 'arg count');\r\n        let assignable = 0;\r\n        let wasNotDecl = false;\r\n        let emptyInit = false;\r\n        let startedWithArrObj = false;\r\n        catchforofhack = false;\r\n        if (curtype === $IDENT) {\r\n            switch (curtok.str) {\r\n                case 'var':\r\n                    ASSERT_skipAny('var', lexerFlags);\r\n                    parseAnyVarDecls(lexerFlags | LF_IN_FOR_LHS, scoop, BINDING_TYPE_VAR, FROM_FOR_HEADER, SKIP_DUPE_CHECKS, UNDEF_EXPORTS, UNDEF_EXPORTS, astProp);\r\n                    assignable = initAssignable(assignable);\r\n                    break;\r\n                case 'let':\r\n                    let identToken = curtok;\r\n                    ASSERT_skipDiv('let', lexerFlags);\r\n                    if (curtype === $IDENT || curc === $$SQUARE_L_5B || curc === $$CURLY_L_7B) {\r\n                        if (curtok.str === 'in') {\r\n                            if (hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n                                THROW('Let binding missing binding names as `let` cannot be a var name in strict mode');\r\n                            }\r\n                            AST_setIdent(astProp, curtok);\r\n                        }\r\n                        else {\r\n                            parseAnyVarDecls(lexerFlags | LF_IN_FOR_LHS, scoop, BINDING_TYPE_LET, FROM_FOR_HEADER, CHECK_DUPE_BINDS, UNDEF_EXPORTS, UNDEF_EXPORTS, astProp);\r\n                            if (SCOPE_verifyLexical(lexerFlags, scoop, false))\r\n                                THROW('Let for-binding attempted to get at least one name bound more than once');\r\n                        }\r\n                        assignable = initAssignable(assignable);\r\n                    }\r\n                    else if (hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n                        THROW('Let binding missing binding names');\r\n                    }\r\n                    else {\r\n                        assignable = parseExpressionAfterPlainVarName(lexerFlags, identToken, ALLOW_ASSIGNMENT, astProp);\r\n                        if (curc === $$COMMA_2C) {\r\n                            _parseExpressions(lexerFlags, initNotAssignable(false), astProp);\r\n                        }\r\n                    }\r\n                    break;\r\n                case 'const':\r\n                    ASSERT_skipAny('const', lexerFlags);\r\n                    parseAnyVarDecls(lexerFlags | LF_IN_FOR_LHS, scoop, BINDING_TYPE_CONST, FROM_FOR_HEADER, SKIP_DUPE_CHECKS, UNDEF_EXPORTS, UNDEF_EXPORTS, astProp);\r\n                    if (SCOPE_verifyLexical(lexerFlags, scoop, false))\r\n                        THROW('Const for-binding attempted to get at least one name bound more than once');\r\n                    assignable = initAssignable(assignable);\r\n                    break;\r\n                default:\r\n                    ASSERT(curtype === $IDENT, 'should be ident');\r\n                    assignable = parseValueHeadBodyIdent(lexerFlags | LF_IN_FOR_LHS, NOT_NEW_ARG, BINDING_TYPE_NONE, NO_ASSIGNMENT, astProp);\r\n                    assignable = parseValueTail(lexerFlags | LF_IN_FOR_LHS, assignable, NOT_NEW_ARG, astProp);\r\n                    wasNotDecl = true;\r\n            }\r\n        }\r\n        else if (curc === $$SEMI_3B) {\r\n            if (awaitable) {\r\n                THROW('for await only accepts the `for-of` type');\r\n            }\r\n            emptyInit = true;\r\n        }\r\n        else {\r\n            startedWithArrObj = curc === $$SQUARE_L_5B || curc === $$CURLY_L_7B;\r\n            assignable = parseValue(lexerFlags | LF_IN_FOR_LHS, ALLOW_ASSIGNMENT, NOT_NEW_ARG, astProp);\r\n            wasNotDecl = true;\r\n        }\r\n        ASSERT(assignable !== 0, 'every branch should update assignable');\r\n        if (curtype === $IDENT) {\r\n            if (curtok.str === 'of') {\r\n                if (catchforofhack)\r\n                    THROW('Encountered `var` declaration for a name used in catch binding which in web compat mode is still not allowed in a `for-of`');\r\n                if (startedWithArrObj)\r\n                    AST_destruct(astProp);\r\n                AST_wrapClosed(astProp, 'ForOfStatement', 'left');\r\n                if (notAssignable(assignable))\r\n                    THROW('Left part of for-of must be assignable');\r\n                ASSERT_skipRex('of', lexerFlags);\r\n                parseExpression(lexerFlags, ALLOW_ASSIGNMENT, 'right');\r\n                AST_set('await', !!awaitable);\r\n                return;\r\n            }\r\n            if (awaitable)\r\n                THROW('`for await` only accepts the `for-of` type');\r\n            if (curtok.str === 'in') {\r\n                if (startedWithArrObj)\r\n                    AST_destruct(astProp);\r\n                AST_wrapClosed(astProp, 'ForInStatement', 'left');\r\n                if (notAssignable(assignable)) {\r\n                    if (options_webCompat === WEB_COMPAT_ON && hasNoFlag(lexerFlags, LF_STRICT_MODE)) {\r\n                    }\r\n                    else {\r\n                        THROW('Left part of for-in must be assignable');\r\n                    }\r\n                }\r\n                ASSERT_skipRex('in', lexerFlags);\r\n                parseExpressions(lexerFlags, ALLOW_ASSIGNMENT, 'right');\r\n                return;\r\n            }\r\n            ASSERT(curtok.str === 'instanceof', 'the only other valid identifier here is the instanceof op');\r\n        }\r\n        else if (awaitable) {\r\n            THROW('for await only accepts the `for-of` type');\r\n        }\r\n        if (emptyInit) {\r\n            AST_open(astProp, 'ForStatement');\r\n            AST_set('init', null);\r\n        }\r\n        else {\r\n            AST_wrapClosed(astProp, 'ForStatement', 'init');\r\n            if (wasNotDecl)\r\n                assignable = parseExpressionFromOp(lexerFlags | LF_IN_FOR_LHS, assignable, 'init');\r\n        }\r\n        let hadComma = curc === $$COMMA_2C;\r\n        if (hadComma)\r\n            _parseExpressions(lexerFlags, initNotAssignable(0), 'init');\r\n        if (curc !== $$SEMI_3B) {\r\n            if (hadComma && (curtok.str === 'of' || ')'))\r\n                THROW('Comma not allowed in left side of `for-in`/`for-of` header');\r\n            skipRexOrDieSingleChar($$SEMI_3B, lexerFlags);\r\n        }\r\n        ASSERT_skipRex(';', lexerFlags);\r\n        if (curc === $$SEMI_3B) {\r\n            AST_set('test', null);\r\n        }\r\n        else {\r\n            parseExpressions(lexerFlags, ALLOW_ASSIGNMENT, 'test');\r\n        }\r\n        skipRexOrDieSingleChar($$SEMI_3B, lexerFlags);\r\n        if (curc === $$PAREN_R_29) {\r\n            AST_set('update', null);\r\n        }\r\n        else {\r\n            parseExpressions(lexerFlags, ALLOW_ASSIGNMENT, 'update');\r\n        }\r\n    }\r\n    function parseIfStatement(lexerFlags, scoop, labelSet, astProp) {\r\n        ASSERT(arguments.length === parseIfStatement.length, 'arg count');\r\n        AST_open(astProp, 'IfStatement');\r\n        ASSERT_skipAny('if', lexerFlags);\r\n        parseStatementHeader(lexerFlags, 'test');\r\n        parseNestedBodyPart(lexerFlags | LF_CAN_FUNC_STMT, scoop, { '#': labelSet }, EXC_DECL, 'consequent');\r\n        if (curtype === $IDENT && curtok.str === 'else') {\r\n            ASSERT_skipRex('else', lexerFlags);\r\n            parseNestedBodyPart(lexerFlags | LF_CAN_FUNC_STMT, scoop, { '#': labelSet }, EXC_DECL, 'alternate');\r\n        }\r\n        else {\r\n            AST_set('alternate', null);\r\n        }\r\n        AST_close('IfStatement');\r\n    }\r\n    function parseImportDeclaration(lexerFlags, scoop, astProp) {\r\n        ASSERT(parseImportDeclaration.length === arguments.length, 'arg count');\r\n        if (goalMode !== GOAL_MODULE)\r\n            THROW('The `import` keyword can only be used with the module goal');\r\n        if (hasNoFlag(lexerFlags, LF_IN_GLOBAL))\r\n            THROW('The `import` keyword is only supported at the top level');\r\n        if (hasNoFlag(lexerFlags, LF_IN_SCOPE_ROOT))\r\n            THROW('The `import` keyword can not be nested in another statement');\r\n        ASSERT_skipAny('import', lexerFlags);\r\n        AST_open(astProp, 'ImportDeclaration');\r\n        AST_set('specifiers', []);\r\n        if (curtype === $IDENT) {\r\n            parseImportDefault(lexerFlags, scoop);\r\n            if (curc === $$COMMA_2C) {\r\n                ASSERT_skipAny(',', lexerFlags);\r\n                if (curc === $$STAR_2A) {\r\n                    parseImportNamespace(lexerFlags, scoop);\r\n                }\r\n                else if (curc === $$CURLY_L_7B) {\r\n                    parseImportObject(lexerFlags, scoop);\r\n                }\r\n                else {\r\n                    THROW('Can only import star or object after default');\r\n                }\r\n            }\r\n            else if (curtok.str !== 'from') {\r\n                THROW('Missing export source');\r\n            }\r\n            else {\r\n                ASSERT_skipAny('from', lexerFlags);\r\n            }\r\n        }\r\n        else if (curc === $$STAR_2A) {\r\n            parseImportNamespace(lexerFlags, scoop);\r\n        }\r\n        else if (curc === $$CURLY_L_7B) {\r\n            parseImportObject(lexerFlags, scoop);\r\n        }\r\n        if (hasNoFlag(curtype, $STRING))\r\n            THROW('Export source must be string');\r\n        AST_setLiteral('source', curtok);\r\n        skipRex(lexerFlags);\r\n        AST_close('ImportDeclaration');\r\n        parseSemiOrAsi(lexerFlags);\r\n    }\r\n    function parseImportDefault(lexerFlags, scoop) {\r\n        ASSERT(parseImportDefault.length === arguments.length, 'arg count');\r\n        AST_open('specifiers', 'ImportDefaultSpecifier');\r\n        AST_setIdent('local', curtok);\r\n        bindingIdentCheck(curtok, BINDING_TYPE_CONST, lexerFlags);\r\n        SCOPE_addBindingAndDedupe(lexerFlags, scoop, curtok.str, BINDING_TYPE_CONST, ORIGIN_NOT_VAR_DECL);\r\n        ASSERT_skipAny($IDENT, lexerFlags);\r\n        AST_close('ImportDefaultSpecifier');\r\n    }\r\n    function parseImportObject(lexerFlags, scoop) {\r\n        ASSERT(parseImportObject.length === arguments.length, 'arg count');\r\n        let lexerFlagsNoTemplate = sansFlag(lexerFlags, LF_IN_TEMPLATE);\r\n        ASSERT_skipAny('{', lexerFlagsNoTemplate);\r\n        while (curtype === $IDENT) {\r\n            AST_open('specifiers', 'ImportSpecifier');\r\n            let nameToken = curtok;\r\n            AST_setIdent('imported', nameToken);\r\n            skipAny(lexerFlagsNoTemplate);\r\n            if (curtok.str === 'as') {\r\n                ASSERT_skipAny('as', lexerFlagsNoTemplate);\r\n                if (curtype !== $IDENT)\r\n                    THROW('Alias must be an ident');\r\n                AST_setIdent('local', curtok);\r\n                bindingIdentCheck(curtok, BINDING_TYPE_CONST, lexerFlags);\r\n                SCOPE_addBindingAndDedupe(lexerFlagsNoTemplate, scoop, curtok.str, BINDING_TYPE_CONST, ORIGIN_NOT_VAR_DECL);\r\n                skipAny(lexerFlagsNoTemplate);\r\n            }\r\n            else {\r\n                bindingIdentCheck(nameToken, BINDING_TYPE_CONST, lexerFlags);\r\n                SCOPE_addBindingAndDedupe(lexerFlagsNoTemplate, scoop, nameToken.str, BINDING_TYPE_CONST, ORIGIN_NOT_VAR_DECL);\r\n                AST_setIdent('local', nameToken);\r\n            }\r\n            if (curc === $$COMMA_2C)\r\n                ASSERT_skipAny(',', lexerFlagsNoTemplate);\r\n            else if (curc !== $$CURLY_R_7D)\r\n                THROW('Unexpected character while parsing export object');\r\n            AST_close('ImportSpecifier');\r\n        }\r\n        skipAnyOrDieSingleChar($$CURLY_R_7D, lexerFlagsNoTemplate);\r\n        if (curtok.str !== 'from')\r\n            THROW('Missing export source');\r\n        ASSERT_skipAny('from', lexerFlags);\r\n    }\r\n    function parseImportNamespace(lexerFlags, scoop) {\r\n        ASSERT(parseImportNamespace.length === arguments.length, 'arg count');\r\n        ASSERT_skipAny('*', lexerFlags);\r\n        skipAnyOrDie($$A_61, 'as', lexerFlags);\r\n        AST_open('specifiers', 'ImportNamespaceSpecifier');\r\n        AST_setIdent('local', curtok);\r\n        bindingIdentCheck(curtok, BINDING_TYPE_CONST, lexerFlags);\r\n        SCOPE_addBindingAndDedupe(lexerFlags, scoop, curtok.str, BINDING_TYPE_CONST, ORIGIN_NOT_VAR_DECL);\r\n        ASSERT_skipAny($IDENT, lexerFlags);\r\n        AST_close('ImportNamespaceSpecifier');\r\n        if (curtok.str !== 'from')\r\n            THROW('Missing export source');\r\n        ASSERT_skipAny('from', lexerFlags);\r\n    }\r\n    function parseLetDeclaration(lexerFlags, scoop, labelSet, astProp) {\r\n        ASSERT(arguments.length === parseLetDeclaration.length, 'arg count');\r\n        let identToken = curtok;\r\n        ASSERT(identToken.str === 'let', 'should pass on the let token');\r\n        ASSERT_skipDiv('let', lexerFlags);\r\n        if (curtype === $IDENT || curc === $$SQUARE_L_5B || curc === $$CURLY_L_7B) {\r\n            parseAnyVarDecls(lexerFlags, scoop, BINDING_TYPE_LET, FROM_STATEMENT_START, SKIP_DUPE_CHECKS, UNDEF_EXPORTS, UNDEF_EXPORTS, astProp);\r\n            if (SCOPE_verifyLexical(lexerFlags, scoop, false))\r\n                THROW('Let binding attempted to get at least one name bound more than once');\r\n            parseSemiOrAsi(lexerFlags);\r\n        }\r\n        else if (hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n            THROW('Let declaration missing binding names and `let` cannot be a regular var name in strict mode');\r\n        }\r\n        else {\r\n            _parseLetAsPlainVarNameExpressionStatement(lexerFlags, scoop, labelSet, identToken, astProp);\r\n        }\r\n    }\r\n    function parseLetExpressionStatement(lexerFlags, scoop, labelSet, astProp) {\r\n        ASSERT(arguments.length === parseLetExpressionStatement.length, 'arg count');\r\n        let identToken = curtok;\r\n        ASSERT(identToken.str === 'let', 'should pass on the let token');\r\n        ASSERT_skipDiv('let', lexerFlags);\r\n        if (hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n            THROW('`let` declaration not allowed here and `let` cannot be a regular var name in strict mode');\r\n        }\r\n        else if (curc === $$SQUARE_L_5B && curtok.nl) {\r\n            THROW('Must parse expression statement here but that is not allowed to start with `let [` which we just parsed');\r\n        }\r\n        else {\r\n            _parseLetAsPlainVarNameExpressionStatement(lexerFlags, scoop, labelSet, identToken, astProp);\r\n        }\r\n    }\r\n    function _parseLetAsPlainVarNameExpressionStatement(lexerFlags, scoop, labelSet, identToken, astProp) {\r\n        ASSERT(_parseLetAsPlainVarNameExpressionStatement.length === arguments.length, 'arg count');\r\n        ASSERT(identToken.str === 'let', 'should pass on the let token');\r\n        ASSERT(identToken !== curtok, 'the `let` token should have been skipped');\r\n        ASSERT(hasNoFlag(lexerFlags, LF_STRICT_MODE), 'sloppy mode should be asserted at call site');\r\n        if (curtype === $EOF) {\r\n            AST_open(astProp, 'ExpressionStatement');\r\n            AST_setIdent('expression', identToken);\r\n            AST_close('ExpressionStatement');\r\n        }\r\n        else {\r\n            if (curc === $$COLON_3A)\r\n                return parseLabeledStatementInstead(lexerFlags, scoop, labelSet, identToken, astProp);\r\n            AST_open(astProp, 'ExpressionStatement');\r\n            parseExpressionAfterPlainVarName(lexerFlags, identToken, ALLOW_ASSIGNMENT, 'expression');\r\n            if (curc === $$COMMA_2C) {\r\n                _parseExpressions(lexerFlags, initNotAssignable(0), 'expression');\r\n            }\r\n            AST_close('ExpressionStatement');\r\n        }\r\n        parseSemiOrAsi(lexerFlags);\r\n    }\r\n    function parseReturnStatement(lexerFlags, astProp) {\r\n        if (!allowGlobalReturn && hasAllFlags(lexerFlags, LF_IN_GLOBAL))\r\n            THROW('Not configured to parse `return` statement in global, bailing');\r\n        AST_open(astProp, 'ReturnStatement');\r\n        ASSERT_skipRex('return', lexerFlags);\r\n        if (!curtok.nl && curtype !== $EOF && curc !== $$SEMI_3B && curc !== $$CURLY_R_7D) {\r\n            parseExpressions(lexerFlags, ALLOW_ASSIGNMENT, 'argument');\r\n        }\r\n        else {\r\n            AST_set('argument', null);\r\n        }\r\n        parseSemiOrAsi(lexerFlags);\r\n        AST_close('ReturnStatement');\r\n    }\r\n    function parseSwitchStatement(lexerFlags, scoop, labelSet, astProp) {\r\n        ASSERT(arguments.length === parseSwitchStatement.length, 'arg count');\r\n        AST_open(astProp, 'SwitchStatement');\r\n        ASSERT_skipAny('switch', lexerFlags);\r\n        parseStatementHeader(lexerFlags, 'discriminant');\r\n        let lexerFlagsNoTemplate = sansFlag(lexerFlags, LF_IN_TEMPLATE);\r\n        skipAnyOrDieSingleChar($$CURLY_L_7B, lexerFlagsNoTemplate);\r\n        AST_set('cases', []);\r\n        parseSwitchCases(lexerFlagsNoTemplate | LF_IN_SWITCH, SCOPE_addLexTo(scoop, SWITCH_SCOPE, 'parseSwitchStatement'), labelSet, 'cases');\r\n        skipRexOrDieSingleChar($$CURLY_R_7D, lexerFlags);\r\n        AST_close('SwitchStatement');\r\n    }\r\n    function parseSwitchCases(lexerFlags, scoop, labelSet, astProp) {\r\n        ASSERT(arguments.length === parseSwitchCases.length, 'arg count');\r\n        let hadDefault = false;\r\n        while (true) {\r\n            if (curtok.str === 'case') {\r\n                AST_open(astProp, 'SwitchCase');\r\n                ASSERT_skipRex('case', lexerFlags);\r\n                parseExpressions(lexerFlags, ALLOW_ASSIGNMENT, 'test');\r\n                AST_set('consequent', []);\r\n                if (curc !== $$COLON_3A)\r\n                    THROW('Missing colon after case expr');\r\n                ASSERT_skipRex(':', lexerFlags);\r\n                while (curtype !== $EOF && curc !== $$CURLY_R_7D && (curtype !== $IDENT || (curtok.str !== 'case' && curtok.str !== 'default'))) {\r\n                    parseNestedBodyPart(lexerFlags, scoop, { '#': labelSet }, INC_DECL, 'consequent');\r\n                }\r\n                AST_close('SwitchCase');\r\n            }\r\n            else if (curtok.str === 'default') {\r\n                if (hadDefault)\r\n                    THROW('Found second `default` in same switch');\r\n                hadDefault = true;\r\n                AST_open(astProp, 'SwitchCase');\r\n                ASSERT_skipAny('default', lexerFlags);\r\n                if (curc !== $$COLON_3A)\r\n                    THROW('Missing colon after default');\r\n                ASSERT_skipRex(':', lexerFlags);\r\n                AST_set('test', null);\r\n                AST_set('consequent', []);\r\n                while (curtype !== $EOF && curc !== $$CURLY_R_7D && (curtype !== $IDENT || (curtok.str !== 'case' && curtok.str !== 'default'))) {\r\n                    parseNestedBodyPart(lexerFlags, scoop, { '#': labelSet }, INC_DECL, 'consequent');\r\n                }\r\n                AST_close('SwitchCase');\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    function parseThrowStatement(lexerFlags, astProp) {\r\n        AST_open(astProp, 'ThrowStatement');\r\n        ASSERT_skipRex('throw', lexerFlags);\r\n        if (curtok.nl)\r\n            THROW('Premature newline');\r\n        parseExpressions(lexerFlags, ALLOW_ASSIGNMENT, 'argument');\r\n        parseSemiOrAsi(lexerFlags);\r\n        AST_close('ThrowStatement');\r\n    }\r\n    function parseTryStatement(lexerFlags, scoop, labelSet, astProp) {\r\n        ASSERT(arguments.length === parseTryStatement.length, 'arg count');\r\n        AST_open(astProp, 'TryStatement');\r\n        let hasEither = false;\r\n        ASSERT_skipAny('try', lexerFlags);\r\n        parseBlockStatement(lexerFlags, SCOPE_addLexTo(scoop, BLOCK_SCOPE, 'parseTryStatement(try)'), { '#': labelSet }, IS_STATEMENT, IGNORE_DIRECTIVES, IGNORE_DIRECTIVES, INC_DECL, 'block');\r\n        if (curc === $$C_63 && curtok.str === 'catch') {\r\n            hasEither = true;\r\n            AST_open('handler', 'CatchClause');\r\n            ASSERT_skipAny('catch', lexerFlags);\r\n            skipAnyOrDieSingleChar($$PAREN_L_28, lexerFlags);\r\n            let catchHeadScoop = SCOPE_addLexTo(scoop, CATCH_SCOPE, 'parseTryStatement(catch-var)');\r\n            if (curc === $$PAREN_R_29)\r\n                THROW('Missing catch clause parameter');\r\n            parseBinding(lexerFlags | LF_NO_ASI, catchHeadScoop, BINDING_TYPE_ARG, FROM_CATCH, ASSIGNMENT_IS_DEFAULT, SKIP_DUPE_CHECKS, UNDEF_EXPORTS, UNDEF_EXPORTS, 'param');\r\n            if (SCOPE_verifyLexical(lexerFlags, catchHeadScoop, true))\r\n                THROW('Catch binding had at least one duplicate name bound');\r\n            let catchBodyScoop = SCOPE_addLexTo(catchHeadScoop, BLOCK_SCOPE, 'parseTryStatement(catch-body)');\r\n            if (curc === $$COMMA_2C)\r\n                THROW('Catch clause requires exactly one parameter, not more (and no trailing comma)');\r\n            if (curc === $$IS_3D && curtok.str === '=')\r\n                THROW('Catch clause parameter does not support default values');\r\n            skipAnyOrDieSingleChar($$PAREN_R_29, lexerFlags);\r\n            parseBlockStatement(lexerFlags, catchBodyScoop, { '#': labelSet }, IS_STATEMENT, IGNORE_DIRECTIVES, IGNORE_DIRECTIVES, INC_DECL, 'body');\r\n            AST_close('CatchClause');\r\n        }\r\n        else {\r\n            AST_set('handler', null);\r\n        }\r\n        if (curc === $$F_66 && curtok.str === 'finally') {\r\n            hasEither = true;\r\n            ASSERT_skipAny('finally', lexerFlags);\r\n            parseBlockStatement(lexerFlags, SCOPE_addLexTo(scoop, BLOCK_SCOPE, 'parseTryStatement(finally)'), { '#': labelSet }, IS_STATEMENT, IGNORE_DIRECTIVES, IGNORE_DIRECTIVES, INC_DECL, 'finalizer');\r\n        }\r\n        else {\r\n            AST_set('finalizer', null);\r\n        }\r\n        AST_close('TryStatement');\r\n        if (!hasEither)\r\n            THROW('Try must have catch or finally');\r\n    }\r\n    function parseVarStatement(lexerFlags, scoop, astProp) {\r\n        ASSERT_skipAny('var', lexerFlags);\r\n        parseAnyVarDecls(lexerFlags, scoop, BINDING_TYPE_VAR, FROM_STATEMENT_START, SKIP_DUPE_CHECKS, UNDEF_EXPORTS, UNDEF_EXPORTS, astProp);\r\n        parseSemiOrAsi(lexerFlags);\r\n    }\r\n    function parseWhileStatement(lexerFlags, scoop, labelSet, astProp) {\r\n        ASSERT(arguments.length === parseWhileStatement.length, 'arg count');\r\n        AST_open(astProp, 'WhileStatement');\r\n        ASSERT_skipAny('while', lexerFlags);\r\n        parseStatementHeader(lexerFlags, 'test');\r\n        parseNestedBodyPart(lexerFlags | LF_IN_ITERATION, scoop, { '##': 'while', '#': labelSet }, EXC_DECL, 'body');\r\n        AST_close('WhileStatement');\r\n    }\r\n    function parseIdentLabelOrExpressionStatement(lexerFlags, scoop, labelSet, astProp) {\r\n        ASSERT(parseIdentLabelOrExpressionStatement.length === arguments.length, 'arg count');\r\n        ASSERT(curtype === $IDENT, 'should not have consumed the ident yet', debug_toktype(curtype, false));\r\n        ASSERT(typeof astProp === 'string', 'should be string');\r\n        let identToken = curtok;\r\n        let assignable = 0;\r\n        let identName = curtok.str;\r\n        switch (identName) {\r\n            case 'await':\r\n                ASSERT_skipRex('await', lexerFlags);\r\n                if (curc === $$COLON_3A)\r\n                    return parseLabeledStatementInstead(lexerFlags, scoop, labelSet, identToken, astProp);\r\n                AST_open(astProp, 'ExpressionStatement');\r\n                parseAwait(lexerFlags, identToken, NOT_NEW_ARG, ALLOW_ASSIGNMENT, 'expression');\r\n                parseExpressionFromOp(lexerFlags, NOT_ASSIGNABLE, 'expression');\r\n                AST_close('ExpressionStatement');\r\n                parseSemiOrAsi(lexerFlags);\r\n                return;\r\n            case 'delete':\r\n                ASSERT_skipRex('delete', lexerFlags);\r\n                if (curc === $$COLON_3A)\r\n                    return parseLabeledStatementInstead(lexerFlags, scoop, labelSet, identToken, astProp);\r\n                AST_open(astProp, 'ExpressionStatement');\r\n                assignable = parseDeleteExpression(lexerFlags, assignable, 'expression');\r\n                astProp = 'expression';\r\n                break;\r\n            case 'false':\r\n                ASSERT_skipDiv('false', lexerFlags);\r\n                if (curc === $$COLON_3A)\r\n                    return parseLabeledStatementInstead(lexerFlags, scoop, labelSet, identToken, astProp);\r\n                AST_open(astProp, 'ExpressionStatement');\r\n                astProp = 'expression';\r\n                assignable = parseFalseKeyword(astProp);\r\n                break;\r\n            case 'function':\r\n                ASSERT(false, 'function ident is already checked before this func');\r\n                throw new Error('fail');\r\n            case 'new':\r\n                ASSERT_skipRex('new', lexerFlags);\r\n                if (curc === $$COLON_3A)\r\n                    return parseLabeledStatementInstead(lexerFlags, scoop, labelSet, identToken, astProp);\r\n                AST_open(astProp, 'ExpressionStatement');\r\n                astProp = 'expression';\r\n                parseNewKeyword(lexerFlags, astProp);\r\n                assignable = initNotAssignable(assignable);\r\n                break;\r\n            case 'null':\r\n                ASSERT_skipDiv('null', lexerFlags);\r\n                if (curc === $$COLON_3A)\r\n                    return parseLabeledStatementInstead(lexerFlags, scoop, labelSet, identToken, astProp);\r\n                AST_open(astProp, 'ExpressionStatement');\r\n                astProp = 'expression';\r\n                assignable = parseNullKeyword(astProp);\r\n                break;\r\n            case 'super':\r\n                ASSERT_skipDiv('super', lexerFlags);\r\n                if (curc === $$COLON_3A)\r\n                    return parseLabeledStatementInstead(lexerFlags, scoop, labelSet, identToken, astProp);\r\n                AST_open(astProp, 'ExpressionStatement');\r\n                astProp = 'expression';\r\n                assignable = parseSuperKeyword(lexerFlags, astProp);\r\n                break;\r\n            case 'this':\r\n                ASSERT_skipDiv('this', lexerFlags);\r\n                if (curc === $$COLON_3A)\r\n                    return parseLabeledStatementInstead(lexerFlags, scoop, labelSet, identToken, astProp);\r\n                AST_open(astProp, 'ExpressionStatement');\r\n                astProp = 'expression';\r\n                assignable = parseThisKeyword(astProp);\r\n                break;\r\n            case 'true':\r\n                ASSERT_skipDiv('true', lexerFlags);\r\n                if (curc === $$COLON_3A)\r\n                    return parseLabeledStatementInstead(lexerFlags, scoop, labelSet, identToken, astProp);\r\n                AST_open(astProp, 'ExpressionStatement');\r\n                astProp = 'expression';\r\n                assignable = parseTrueKeyword(astProp);\r\n                break;\r\n            case 'typeof':\r\n            case 'void':\r\n                ASSERT_skipRex($IDENT, lexerFlags);\r\n                if (curc === $$COLON_3A)\r\n                    return parseLabeledStatementInstead(lexerFlags, scoop, labelSet, identToken, astProp);\r\n                AST_open(astProp, 'ExpressionStatement');\r\n                astProp = 'expression';\r\n                assignable = parseUnary(lexerFlags, identName, astProp);\r\n                break;\r\n            case 'yield':\r\n                ASSERT_skipRex('yield', lexerFlags);\r\n                if (curc === $$COLON_3A) {\r\n                    return parseLabeledStatementInstead(lexerFlags, scoop, labelSet, identToken, astProp);\r\n                }\r\n                AST_open(astProp, 'ExpressionStatement');\r\n                astProp = 'expression';\r\n                assignable = parseYield(lexerFlags, identToken, ALLOW_ASSIGNMENT, astProp);\r\n                break;\r\n            default:\r\n                ASSERT_skipDiv($IDENT, lexerFlags);\r\n                if (curc === $$COLON_3A)\r\n                    return parseLabeledStatementInstead(lexerFlags, scoop, labelSet, identToken, astProp);\r\n                AST_open(astProp, 'ExpressionStatement');\r\n                astProp = 'expression';\r\n                if (!checkIdentReadable(lexerFlags, BINDING_TYPE_NONE, identToken))\r\n                    THROW('Illegal keyword encountered; is not a value [' + identToken.str + ']');\r\n                assignable = bindingAssignableIdentCheck(identToken, BINDING_TYPE_NONE, lexerFlags);\r\n                if (notAssignable(assignable)) {\r\n                    if (identName === 'arguments' || identName === 'eval') {\r\n                        assignable = verifyEvalArgumentsVar(lexerFlags);\r\n                    }\r\n                }\r\n                assignable = parseAfterVarName(lexerFlags, identToken, assignable, ALLOW_ASSIGNMENT, astProp);\r\n        }\r\n        ASSERT(assignable !== 0, 'every branch should update assignable');\r\n        ASSERT(_path[_path.length - 1].type === 'ExpressionStatement', 'at this point the AST has ExpressionStatement open');\r\n        ASSERT(astProp === 'expression', 'each case in the switch should only break if it is an ExpressionStatement and it should leave astProp to expression');\r\n        ASSERT(isAssignable(assignable) || notAssignable(assignable), 'asssignable should be updated properly [' + assignable + ']');\r\n        assignable = parseValueTail(lexerFlags, assignable, NOT_NEW_ARG, astProp);\r\n        assignable = parseExpressionFromOp(lexerFlags, assignable, astProp);\r\n        if (curc === $$COMMA_2C) {\r\n            _parseExpressions(lexerFlags, initNotAssignable(0), 'expression');\r\n        }\r\n        AST_close('ExpressionStatement');\r\n        parseSemiOrAsi(lexerFlags);\r\n    }\r\n    function parseDeleteExpression(lexerFlags, inputAssignable, astProp) {\r\n        AST_open(astProp, 'UnaryExpression');\r\n        AST_set('operator', 'delete');\r\n        AST_set('prefix', true);\r\n        let assignable = 0;\r\n        if (curtype === $IDENT) {\r\n            assignable = parseDeleteIdent(lexerFlags);\r\n        }\r\n        else if (curc === $$PAREN_L_28) {\r\n            assignable = parseDeleteParenSpecialCase(lexerFlags, 'argument');\r\n        }\r\n        else {\r\n            assignable = parseValue(lexerFlags, NO_ASSIGNMENT, NOT_NEW_ARG, 'argument');\r\n        }\r\n        AST_close('UnaryExpression');\r\n        if (curtok.str === '**') {\r\n            THROW('The lhs of ** can not be this kind of unary expression (syntactically not allowed, you have to wrap something)');\r\n        }\r\n        ASSERT(assignable !== 0, 'every branch should update this');\r\n        return setNotAssignable(assignable | inputAssignable);\r\n    }\r\n    function parseDeleteParenSpecialCase(lexerFlags, astProp) {\r\n        ASSERT(curc === $$PAREN_L_28, 'this is why we are here');\r\n        let parens = 0;\r\n        lexerFlags |= LF_NO_ASI;\r\n        do {\r\n            ++parens;\r\n            ASSERT_skipRex('(', lexerFlags);\r\n        } while (curc === $$PAREN_L_28);\r\n        let assignableOrJustIdent = _parseGroupToplevels(lexerFlags, IS_EXPRESSION, parens === 1 ? NO_ASSIGNMENT : ALLOW_ASSIGNMENT, IS_DELETE_ARG, UNDEF_ASYNC, NOT_ASYNC_PREFIXED, astProp);\r\n        ASSERT((assignableOrJustIdent & 0b1111) === NOT_SINGLE_IDENT_WRAP_A || (assignableOrJustIdent & 0b1111) === NOT_SINGLE_IDENT_WRAP_NA || (assignableOrJustIdent & 0b1111) === IS_SINGLE_IDENT_WRAP_A || (assignableOrJustIdent & 0b1111) === IS_SINGLE_IDENT_WRAP_NA, 'exception enum');\r\n        let assignable = hasAnyFlag(assignableOrJustIdent, IS_SINGLE_IDENT_WRAP_A | NOT_SINGLE_IDENT_WRAP_A) ? initAssignable(0) : initNotAssignable(0);\r\n        if (hasAnyFlag(assignableOrJustIdent, DELETE_PIGGY_AWAIT_OR_YIELD_KEYWORD))\r\n            assignable |= DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_OR_YIELD_KEYWORD;\r\n        if (hasAnyFlag(assignableOrJustIdent, DELETE_PIGGY_AWAIT_VARNAME))\r\n            assignable |= DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_VARNAME;\r\n        if (hasAnyFlag(assignableOrJustIdent, DELETE_PIGGY_YIELD_VARNAME))\r\n            assignable |= DESTRUCTIBLE_PIGGY_BACK_SAW_YIELD_VARNAME;\r\n        let canBeErrorCase = hasAnyFlag(assignableOrJustIdent, IS_SINGLE_IDENT_WRAP_A | IS_SINGLE_IDENT_WRAP_NA);\r\n        while (--parens > 0) {\r\n            if (curc !== $$PAREN_R_29) {\r\n                let nowAssignable = parseValueTail(lexerFlags, assignable, NOT_NEW_ARG, astProp);\r\n                assignable = mergeAssignable(nowAssignable, assignable);\r\n                assignable = parseExpressionFromOp(lexerFlags, assignable, astProp);\r\n                if (curc === $$COMMA_2C)\r\n                    assignable = _parseExpressions(lexerFlags, assignable, astProp);\r\n                canBeErrorCase = false;\r\n            }\r\n            skipDivOrDieSingleChar($$PAREN_R_29, lexerFlags);\r\n            if (curtok.str === '=>') {\r\n                THROW('Arrow is illegal here');\r\n            }\r\n        }\r\n        ASSERT(hasAllFlags(lexerFlags, LF_NO_ASI), 'should not be allowed to parse asi inside a group');\r\n        lexerFlags = sansFlag(lexerFlags, LF_NO_ASI);\r\n        ASSERT(curtok.str !== '=>', 'we checked this in the loop');\r\n        let prevtok = curtok;\r\n        parseValueTail(lexerFlags, assignable, NOT_NEW_ARG, astProp);\r\n        if (curtok === prevtok && canBeErrorCase && hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n            THROW('Bad delete case, can not delete an ident wrapped in parens');\r\n        }\r\n        return assignable;\r\n    }\r\n    function parseDeleteIdent(lexerFlags) {\r\n        let identToken = curtok;\r\n        ASSERT_skipDiv($IDENT, lexerFlags);\r\n        let afterIdentToken = curtok;\r\n        let assignable = parseValueAfterIdent(lexerFlags, identToken, BINDING_TYPE_NONE, NO_ASSIGNMENT, 'argument');\r\n        if (identToken.type === $IDENT) {\r\n            if (curtok === afterIdentToken && hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n                THROW('Cannot delete an identifier without tail, in strict mode');\r\n            }\r\n            else if (afterIdentToken.nl && afterIdentToken.str === '(' && identToken.str === 'async' && curtok.str === '=>' && hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n                THROW('Cannot delete an identifier without tail, in strict mode');\r\n            }\r\n        }\r\n        return assignable;\r\n    }\r\n    function parseLabeledStatementInstead(lexerFlags, scoop, labelSet, identToken, astProp) {\r\n        ASSERT(arguments.length === parseLabeledStatementInstead.length, 'arg count');\r\n        bindingIdentCheck(identToken, BINDING_TYPE_NONE, lexerFlags);\r\n        AST_open(astProp, 'LabeledStatement');\r\n        AST_setIdent('label', identToken);\r\n        let set = labelSet;\r\n        do {\r\n            if (set['#' + identToken.str])\r\n                THROW('Saw the same label twice which is not allowed');\r\n            set = set['#'];\r\n        } while (set);\r\n        labelSet['#' + identToken.str] = true;\r\n        ASSERT_skipRex(':', lexerFlags);\r\n        parseNestedBodyPart(lexerFlags | LF_CAN_FUNC_STMT, scoop, labelSet, EXC_DECL, 'body');\r\n        AST_close('LabeledStatement');\r\n    }\r\n    function parsePunctuatorStatement(lexerFlags, scoop, labelSet, astProp) {\r\n        ASSERT(arguments.length === parsePunctuatorStatement.length, 'arg count');\r\n        switch (curc) {\r\n            case $$CURLY_L_7B:\r\n                parseBlockStatement(lexerFlags, SCOPE_addLexTo(scoop, BLOCK_SCOPE, 'parsePunctuatorStatement'), labelSet, IS_STATEMENT, IGNORE_DIRECTIVES, IGNORE_DIRECTIVES, INC_DECL, astProp);\r\n                break;\r\n            case $$SEMI_3B:\r\n                parseEmptyStatement(lexerFlags, astProp);\r\n                break;\r\n            default:\r\n                AST_open(astProp, 'ExpressionStatement');\r\n                parseExpressions(lexerFlags, ALLOW_ASSIGNMENT, 'expression');\r\n                AST_close('ExpressionStatement');\r\n                parseSemiOrAsi(lexerFlags);\r\n        }\r\n    }\r\n    function parseEmptyStatement(lexerFlags, astProp) {\r\n        AST_open(astProp, 'EmptyStatement');\r\n        ASSERT_skipRex(';', lexerFlags);\r\n        AST_close('EmptyStatement');\r\n    }\r\n    function parseWithStatement(lexerFlags, scoop, labelSet, astProp) {\r\n        ASSERT(arguments.length === parseWithStatement.length, 'arg count');\r\n        if (hasAllFlags(lexerFlags, LF_STRICT_MODE))\r\n            THROW('The `with` statement is not allowed in strict mode');\r\n        AST_open(astProp, 'WithStatement');\r\n        ASSERT_skipAny('with', lexerFlags);\r\n        parseStatementHeader(lexerFlags, 'object');\r\n        parseNestedBodyPart(lexerFlags, scoop, labelSet, EXC_DECL, 'body');\r\n        AST_close('WithStatement');\r\n    }\r\n    function parseAnyVarDecls(lexerFlags, scoop, bindingType, bindingOrigin, doDupeBindingCheck, exportedNames, exportedBindings, astProp) {\r\n        ASSERT(parseAnyVarDecls.length === arguments.length, 'arg count');\r\n        if (curtype !== $IDENT && curc !== $$SQUARE_L_5B && curc !== $$CURLY_L_7B)\r\n            THROW('Expected identifier, or array/object destructuring, next token is: ' + curtok);\r\n        ASSERT(bindingType === BINDING_TYPE_VAR || bindingType === BINDING_TYPE_LET || bindingType === BINDING_TYPE_CONST, 'only three kinds here');\r\n        let keyword = bindingType === BINDING_TYPE_VAR ? 'var' : bindingType === BINDING_TYPE_LET ? 'let' : 'const';\r\n        AST_open(astProp, 'VariableDeclaration');\r\n        AST_set('kind', keyword);\r\n        AST_set('declarations', []);\r\n        parseBindings(lexerFlags, scoop, bindingType, bindingOrigin, ASSIGNMENT_IS_INIT, NOT_GETSET, doDupeBindingCheck, exportedNames, exportedBindings, 'declarations');\r\n        AST_close(['VariableDeclaration', 'ExpressionStatement']);\r\n    }\r\n    function parseBindings(lexerFlags, scoop, bindingType, bindingOrigin, defaultOptions, isGetSet, skipDoubleBindCheck, exportedNames, exportedBindings, astProp) {\r\n        ASSERT(parseBindings.length === arguments.length, 'expecting all args');\r\n        ASSERT(typeof bindingType === 'number', 'bindingType should be enum');\r\n        ASSERT(typeof bindingOrigin === 'number', 'bindingOrigin should be enum');\r\n        ASSERT(isGetSet !== IS_GETTER, 'getters should not call this');\r\n        let many = 0;\r\n        let inited = false;\r\n        let startWasObjectOrArray = curc === $$SQUARE_L_5B || curc === $$CURLY_L_7B;\r\n        let wasSimple = ARGS_SIMPLE;\r\n        do {\r\n            ++many;\r\n            let wasRest = curc === $$DOT_2E && curtok.str === '...';\r\n            let bindingMeta = parseBinding(lexerFlags, scoop, bindingType, bindingOrigin, defaultOptions, skipDoubleBindCheck, exportedNames, exportedBindings, astProp);\r\n            if (bindingMeta === ARG_HAD_INIT)\r\n                inited = true;\r\n            if (bindingMeta !== ARG_WAS_SIMPLE) {\r\n                ASSERT(typeof bindingMeta === 'number', 'should be number');\r\n                ASSERT(bindingMeta >= 0 && bindingMeta <= 2, 'bindingMeta should be enum');\r\n                wasSimple = ARGS_COMPLEX;\r\n            }\r\n            if (wasRest) {\r\n                ASSERT(curc === $$PAREN_R_29, 'the \"rest is last and no init\" check should happen elsewhere and before this point');\r\n                break;\r\n            }\r\n            if (curc !== $$COMMA_2C)\r\n                break;\r\n            ASSERT_skipAny(',', lexerFlags);\r\n            if (curc === $$PAREN_R_29) {\r\n                if (bindingType === BINDING_TYPE_ARG) {\r\n                    if (allowTrailingFunctionComma) {\r\n                        return wasSimple;\r\n                    }\r\n                    THROW('Targeted language version does not support trailing function arg comma');\r\n                }\r\n            }\r\n        } while (true);\r\n        if (many !== 1 && isGetSet === IS_SETTER) {\r\n            THROW('Setters require exactly one parameter');\r\n        }\r\n        if (bindingOrigin === FROM_FOR_HEADER && (curtok.str === 'in' || curtok.str === 'of')) {\r\n            if (startWasObjectOrArray || curtok.str === 'of' || bindingType !== BINDING_TYPE_VAR || options_webCompat === WEB_COMPAT_OFF || hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n                if (many > 1) {\r\n                    THROW('For-in and for-of can only have one binding, found ' + many);\r\n                }\r\n                else if (inited) {\r\n                    THROW('For-in and for-of binding can not have an init');\r\n                }\r\n            }\r\n        }\r\n        return wasSimple;\r\n    }\r\n    function parseBinding(lexerFlags, scoop, bindingType, bindingOrigin, defaultsOption, dupeChecks, exportedNames, exportedBindings, astProp) {\r\n        ASSERT(arguments.length === parseBinding.length, 'expecting args');\r\n        let mustHaveInit = false;\r\n        let wasSimple = ARG_NEITHER_SIMPLE_NOR_INIT;\r\n        if (curtype === $IDENT) {\r\n            bindingIdentCheck(curtok, bindingType, lexerFlags);\r\n            SCOPE_addBinding(lexerFlags, scoop, curtok.str, bindingType, dupeChecks, (bindingOrigin === FROM_STATEMENT_START || bindingOrigin === FROM_FOR_HEADER || bindingOrigin === FROM_EXPORT_DECL) && bindingType === BINDING_TYPE_VAR ? ORIGIN_IS_VAR_DECL : ORIGIN_NOT_VAR_DECL);\r\n            addNameToExports(exportedNames, curtok.str);\r\n            addBindingToExports(exportedBindings, curtok.str);\r\n            let identToken = curtok;\r\n            AST_setIdent(astProp, curtok);\r\n            ASSERT_skipRex($IDENT, lexerFlags);\r\n            if (identToken.str !== 'eval' && identToken.str !== 'arguments') {\r\n                wasSimple = ARG_WAS_SIMPLE;\r\n            }\r\n        }\r\n        else if (curc === $$CURLY_L_7B) {\r\n            ASSERT(bindingType !== BINDING_TYPE_NONE, 'must bind as something');\r\n            let destructible = parseObjectLiteralPatternAndAssign(lexerFlags, scoop, bindingType, SKIP_INIT, NOT_CLASS_METHOD, exportedNames, exportedBindings, astProp);\r\n            verifyDestructibleForBinding(destructible, bindingType);\r\n            AST_destruct(astProp);\r\n            if ((bindingOrigin !== FROM_CATCH) &&\r\n                (bindingOrigin !== FROM_FOR_HEADER || (curtok.str !== 'in' && curtok.str !== 'of')) &&\r\n                (bindingType === BINDING_TYPE_CONST || bindingType === BINDING_TYPE_LET || bindingType === BINDING_TYPE_VAR)) {\r\n                mustHaveInit = true;\r\n            }\r\n        }\r\n        else if (curc === $$SQUARE_L_5B) {\r\n            let destructible = parseArrayLiteralPattern(lexerFlags, scoop, bindingType, SKIP_INIT, exportedNames, exportedBindings, astProp);\r\n            verifyDestructibleForBinding(destructible, bindingType);\r\n            AST_destruct(astProp);\r\n            if ((bindingOrigin !== FROM_CATCH) &&\r\n                (bindingOrigin !== FROM_FOR_HEADER || (curtok.str !== 'in' && curtok.str !== 'of')) &&\r\n                (bindingType === BINDING_TYPE_CONST || bindingType === BINDING_TYPE_LET || bindingType === BINDING_TYPE_VAR)) {\r\n                mustHaveInit = true;\r\n            }\r\n        }\r\n        else if (curc === $$DOT_2E && curtok.str === '...') {\r\n            ASSERT(bindingType === BINDING_TYPE_ARG, 'other binding types should catch this sooner?');\r\n            let subDestruct = parseArrowableSpreadOrRest(lexerFlags, scoop, $$PAREN_R_29, bindingType, IS_GROUP_TOPLEVEL, UNDEF_ASYNC, exportedNames, exportedBindings, astProp);\r\n            verifyDestructibleForBinding(subDestruct, bindingType);\r\n        }\r\n        else if (curc !== $$PAREN_R_29) {\r\n            THROW('Expected to parse a(nother) binding but none was found');\r\n        }\r\n        if (curc === $$IS_3D && curtok.str === '=') {\r\n            ASSERT_skipRex('=', lexerFlags);\r\n            wasSimple = ARG_HAD_INIT;\r\n            if (defaultsOption === ASSIGNMENT_IS_DEFAULT) {\r\n                if (bindingOrigin === FROM_CATCH)\r\n                    THROW('The catch clause cannot have a default');\r\n                AST_wrapClosed(astProp, 'AssignmentPattern', 'left');\r\n                parseExpression(lexerFlags, ALLOW_ASSIGNMENT, 'right');\r\n                AST_close('AssignmentPattern');\r\n            }\r\n            else {\r\n                ASSERT(bindingOrigin !== FROM_CATCH, 'catch is default');\r\n                ASSERT(defaultsOption === ASSIGNMENT_IS_INIT, 'two options');\r\n                AST_wrapClosed('declarations', 'VariableDeclarator', 'id');\r\n                parseExpression(lexerFlags, ALLOW_ASSIGNMENT, 'init');\r\n                AST_close('VariableDeclarator');\r\n            }\r\n        }\r\n        else if (mustHaveInit) {\r\n            THROW('Declaration destructuring must have init');\r\n        }\r\n        else if (bindingType === BINDING_TYPE_CONST && (bindingOrigin !== FROM_FOR_HEADER || (curc === $$SEMI_3B || curc === $$COMMA_2C))) {\r\n            THROW('Constants must be initialized');\r\n        }\r\n        else if (defaultsOption === ASSIGNMENT_IS_INIT) {\r\n            AST_wrapClosed('declarations', 'VariableDeclarator', 'id');\r\n            AST_set('init', null);\r\n            AST_close('VariableDeclarator');\r\n        }\r\n        ASSERT(typeof wasSimple === 'number', 'wassimple should be enum');\r\n        return wasSimple;\r\n    }\r\n    function bindingIdentCheck(identToken, bindingType, lexerFlags) {\r\n        ASSERT(bindingIdentCheck.length === arguments.length, 'arg count');\r\n        ASSERT(identToken.type === $IDENT, 'ident check on ident tokens ok');\r\n        let str = _bindingIdentCheck(identToken, bindingType, lexerFlags);\r\n        if (str !== '')\r\n            THROW(`Cannot use this name (${identToken.str}) as a variable name because: ${str}`);\r\n    }\r\n    function _bindingIdentCheck(identToken, bindingType, lexerFlags) {\r\n        ASSERT(_bindingIdentCheck.length === arguments.length, 'expecting all args');\r\n        ASSERT(typeof bindingType === 'number', 'the binding should be an enum', bindingType);\r\n        switch (identToken.canon) {\r\n            case 'break':\r\n            case 'case':\r\n            case 'catch':\r\n            case 'class':\r\n            case 'const':\r\n            case 'continue':\r\n            case 'debugger':\r\n            case 'default':\r\n            case 'delete':\r\n            case 'do':\r\n            case 'else':\r\n            case 'export':\r\n            case 'extends':\r\n            case 'finally':\r\n            case 'for':\r\n            case 'function':\r\n            case 'if':\r\n            case 'import':\r\n            case 'in':\r\n            case 'instanceof':\r\n            case 'new':\r\n            case 'return':\r\n            case 'super':\r\n            case 'switch':\r\n            case 'this':\r\n            case 'throw':\r\n            case 'try':\r\n            case 'typeof':\r\n            case 'var':\r\n            case 'void':\r\n            case 'while':\r\n            case 'with':\r\n            case 'null':\r\n            case 'true':\r\n            case 'false':\r\n            case 'enum':\r\n                if (identToken.str !== identToken.canon)\r\n                    return 'Keywords may not have escapes in their name';\r\n                return 'Cannot never use this reserved word as a variable name';\r\n            case 'let':\r\n                if (bindingType === BINDING_TYPE_CLASS)\r\n                    return 'Can not use `let` as a class name';\r\n                if (bindingType === BINDING_TYPE_LET || bindingType === BINDING_TYPE_CONST) {\r\n                    return 'Can not use `let` when binding through `let` or `const`';\r\n                }\r\n                if (hasAllFlags(lexerFlags, LF_STRICT_MODE))\r\n                    return 'Can not use `let` as variable name in strict mode';\r\n                break;\r\n            case 'static':\r\n                if (hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n                    if (identToken.str !== identToken.canon)\r\n                        return 'Keywords may not have escapes in their name';\r\n                    return '`static` is a reserved word in strict mode';\r\n                }\r\n                break;\r\n            case 'eval':\r\n            case 'arguments':\r\n                if (hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n                    return 'Cannot create a binding named `' + identToken.canon + '` in strict mode';\r\n                }\r\n                break;\r\n            case 'implements':\r\n            case 'package':\r\n            case 'protected':\r\n            case 'interface':\r\n            case 'private':\r\n            case 'public':\r\n                if (hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n                    if (identToken.str !== identToken.canon) {\r\n                        return 'Keywords may not have escapes in their name';\r\n                    }\r\n                    if (identToken.canon === 'eval' || identToken.canon === 'arguments') {\r\n                        return 'Cannot create a binding named `' + identToken.canon + '` in strict mode';\r\n                    }\r\n                    return 'Cannot use this reserved word as a variable name in strict mode';\r\n                }\r\n                break;\r\n            case 'await':\r\n                if (allowAsyncFunctions) {\r\n                    if (goalMode === GOAL_MODULE) {\r\n                        return 'Await is illegal outside of async body with module goal';\r\n                    }\r\n                    else {\r\n                        if (hasAnyFlag(lexerFlags, LF_IN_ASYNC))\r\n                            return 'Await not allowed here';\r\n                    }\r\n                }\r\n                break;\r\n            case 'yield':\r\n                if (hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n                    return 'Cannot use this reserved word as a variable name in strict mode';\r\n                }\r\n                else if (hasAnyFlag(lexerFlags, LF_IN_GENERATOR)) {\r\n                    return 'Cannot use this reserved word as a variable name inside a generator';\r\n                }\r\n                break;\r\n        }\r\n        return '';\r\n    }\r\n    function bindingAssignableIdentCheck(identToken, bindingType, lexerFlags) {\r\n        ASSERT(arguments.length === bindingAssignableIdentCheck.length, 'expecting arg count');\r\n        ASSERT(typeof identToken === 'object', 'token, not name');\r\n        switch (identToken.canon) {\r\n            case 'break':\r\n            case 'case':\r\n            case 'catch':\r\n            case 'const':\r\n            case 'continue':\r\n            case 'debugger':\r\n            case 'default':\r\n            case 'delete':\r\n            case 'do':\r\n            case 'else':\r\n            case 'export':\r\n            case 'extends':\r\n            case 'finally':\r\n            case 'for':\r\n            case 'function':\r\n            case 'if':\r\n            case 'import':\r\n            case 'in':\r\n            case 'instanceof':\r\n            case 'return':\r\n            case 'switch':\r\n            case 'throw':\r\n            case 'try':\r\n            case 'var':\r\n            case 'while':\r\n            case 'with':\r\n            case 'enum':\r\n                THROW('Unexpected keyword: `' + identToken.canon + '`');\r\n                if (identToken.str !== identToken.canon)\r\n                    THROW('Keywords may not have escapes in their name');\r\n                return NOT_ASSIGNABLE;\r\n            case 'class':\r\n            case 'new':\r\n            case 'super':\r\n            case 'this':\r\n            case 'typeof':\r\n            case 'void':\r\n            case 'null':\r\n            case 'true':\r\n            case 'false':\r\n                if (identToken.str !== identToken.canon)\r\n                    THROW('Keywords may not have escapes in their name');\r\n                return NOT_ASSIGNABLE;\r\n            case 'let':\r\n                if (hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n                    THROW('Unexpected keyword in strict mode: `' + identToken.canon + '`');\r\n                    return NOT_ASSIGNABLE;\r\n                }\r\n                if (bindingType === BINDING_TYPE_LET || bindingType === BINDING_TYPE_CONST)\r\n                    return NOT_ASSIGNABLE;\r\n                break;\r\n            case 'static':\r\n                if (hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n                    if (identToken.str !== identToken.canon)\r\n                        THROW('Keywords may not have escapes in their name');\r\n                    return NOT_ASSIGNABLE;\r\n                }\r\n                break;\r\n            case 'eval':\r\n            case 'arguments':\r\n                if (hasAllFlags(lexerFlags, LF_STRICT_MODE))\r\n                    return NOT_ASSIGNABLE;\r\n                break;\r\n            case 'implements':\r\n            case 'package':\r\n            case 'protected':\r\n            case 'interface':\r\n            case 'private':\r\n            case 'public':\r\n                if (hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n                    if (identToken.str !== identToken.canon)\r\n                        THROW('Keywords may not have escapes in their name');\r\n                    THROW('Unexpected keyword: `' + identToken.canon + '`');\r\n                    return NOT_ASSIGNABLE;\r\n                }\r\n                break;\r\n            case 'await':\r\n                if (allowAsyncFunctions) {\r\n                    if (goalMode === GOAL_MODULE || hasAnyFlag(lexerFlags, LF_IN_ASYNC)) {\r\n                        if (identToken.str !== identToken.canon)\r\n                            THROW('Keywords may not have escapes in their name');\r\n                        return NOT_ASSIGNABLE | DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_OR_YIELD_KEYWORD;\r\n                    }\r\n                }\r\n                return IS_ASSIGNABLE | DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_VARNAME;\r\n            case 'yield':\r\n                if (hasAllFlags(lexerFlags, LF_IN_GENERATOR | LF_STRICT_MODE)) {\r\n                    if (identToken.str !== identToken.canon)\r\n                        THROW('Keywords may not have escapes in their name');\r\n                    return NOT_ASSIGNABLE | DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_OR_YIELD_KEYWORD;\r\n                }\r\n                return IS_ASSIGNABLE | DESTRUCTIBLE_PIGGY_BACK_SAW_YIELD_VARNAME;\r\n        }\r\n        return IS_ASSIGNABLE;\r\n    }\r\n    function checkIdentReadable(lexerFlags, bindingType, identToken) {\r\n        return isUsableKeyword(lexerFlags, bindingType, CHECK_TO_READ, identToken);\r\n    }\r\n    function isUsableKeyword(lexerFlags, bindingType, checkBindOrRead, identToken) {\r\n        ASSERT(isUsableKeyword.length === arguments.length, 'expecting arg count');\r\n        switch (identToken.canon) {\r\n            case 'super':\r\n            case 'this':\r\n            case 'null':\r\n            case 'true':\r\n            case 'false':\r\n                if (identToken.str !== identToken.canon)\r\n                    THROW('Keywords may not have escapes in their name');\r\n                return checkBindOrRead === CHECK_TO_READ;\r\n            case 'eval':\r\n            case 'arguments':\r\n                if (checkBindOrRead === CHECK_TO_BIND) {\r\n                    if (hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n                        return checkBindOrRead === CHECK_TO_READ;\r\n                    }\r\n                }\r\n                return true;\r\n            case 'break':\r\n            case 'case':\r\n            case 'catch':\r\n            case 'const':\r\n            case 'continue':\r\n            case 'debugger':\r\n            case 'default':\r\n            case 'delete':\r\n            case 'do':\r\n            case 'else':\r\n            case 'export':\r\n            case 'extends':\r\n            case 'finally':\r\n            case 'for':\r\n            case 'function':\r\n            case 'if':\r\n            case 'import':\r\n            case 'in':\r\n            case 'instanceof':\r\n            case 'return':\r\n            case 'switch':\r\n            case 'throw':\r\n            case 'try':\r\n            case 'var':\r\n            case 'while':\r\n            case 'with':\r\n            case 'enum':\r\n            case 'class':\r\n            case 'new':\r\n            case 'typeof':\r\n            case 'void':\r\n                break;\r\n            case 'let':\r\n                if (hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n                    break;\r\n                }\r\n                if (bindingType === BINDING_TYPE_LET || bindingType === BINDING_TYPE_CONST) {\r\n                    break;\r\n                }\r\n                return true;\r\n            case 'static':\r\n                if (hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n                    break;\r\n                }\r\n                return true;\r\n            case 'implements':\r\n            case 'package':\r\n            case 'protected':\r\n            case 'interface':\r\n            case 'private':\r\n            case 'public':\r\n                if (hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n                    break;\r\n                }\r\n                return true;\r\n            case 'await':\r\n                if (allowAsyncFunctions) {\r\n                    if (goalMode === GOAL_MODULE || hasAnyFlag(lexerFlags, LF_IN_ASYNC)) {\r\n                        break;\r\n                    }\r\n                }\r\n                return true;\r\n            case 'yield':\r\n                if (hasAnyFlag(lexerFlags, LF_STRICT_MODE | LF_IN_GENERATOR | LF_IN_ASYNC)) {\r\n                    break;\r\n                }\r\n                return true;\r\n            default:\r\n                return true;\r\n        }\r\n        if (identToken.str !== identToken.canon)\r\n            THROW('Keywords may not have escapes in their name');\r\n        return false;\r\n    }\r\n    function parseExpression(lexerFlags, allowAssignment, astProp) {\r\n        ASSERT(arguments.length === parseExpression.length, 'expecting all args');\r\n        let assignable = parseValue(lexerFlags, allowAssignment, NOT_NEW_ARG, astProp);\r\n        return parseExpressionFromOp(lexerFlags, assignable, astProp);\r\n    }\r\n    function parseExpressionAfterLiteral(lexerFlags, astProp) {\r\n        let assignable = parseValueTail(lexerFlags, NOT_ASSIGNABLE, NOT_NEW_ARG, astProp);\r\n        return parseExpressionFromOp(lexerFlags, assignable, astProp);\r\n    }\r\n    function parseExpressionAfterIdent(lexerFlags, identToken, bindingType, allowAssignment, astProp) {\r\n        ASSERT(parseExpressionAfterIdent.length === arguments.length, 'arg count');\r\n        let assignable = parseValueAfterIdent(lexerFlags, identToken, bindingType, allowAssignment, astProp);\r\n        return parseExpressionFromOp(lexerFlags, assignable, astProp);\r\n    }\r\n    function parseExpressionAfterPlainVarName(lexerFlags, identToken, allowAssignment, astProp) {\r\n        ASSERT(parseExpressionAfterPlainVarName.length === arguments.length, 'arg count');\r\n        ASSERT(identToken.str === 'let', 'currently only used for let, update is_assignable flag if this changes');\r\n        let assignable = parseAfterVarName(lexerFlags, identToken, IS_ASSIGNABLE, allowAssignment, astProp);\r\n        assignable = parseValueTail(lexerFlags, assignable, NOT_NEW_ARG, astProp);\r\n        if (allowAssignment === NO_ASSIGNMENT)\r\n            assignable = setNotAssignable(assignable);\r\n        return parseExpressionFromOp(lexerFlags, assignable, astProp);\r\n    }\r\n    function parseExpressionAfterAsyncAsVarName(lexerFlags, stmtOrExpr, asyncToken, isNewArg, allowAssignment, astProp) {\r\n        ASSERT(arguments.length === parseExpressionAfterAsyncAsVarName.length, 'arg count');\r\n        if (stmtOrExpr === IS_STATEMENT) {\r\n            AST_open(astProp, 'ExpressionStatement');\r\n            astProp = 'expression';\r\n        }\r\n        let assignable = parseAfterVarName(lexerFlags, asyncToken, IS_ASSIGNABLE, allowAssignment, astProp);\r\n        assignable = parseValueTail(lexerFlags, assignable, isNewArg, astProp);\r\n        ASSERT((isNewArg !== IS_NEW_ARG) || (stmtOrExpr !== IS_STATEMENT), 'this can not be a new arg if it is a statement');\r\n        if (stmtOrExpr === IS_STATEMENT) {\r\n            assignable = parseExpressionFromOp(lexerFlags, assignable, astProp);\r\n            AST_close('ExpressionStatement');\r\n            parseSemiOrAsi(lexerFlags);\r\n        }\r\n        return assignable;\r\n    }\r\n    function parseParenlessArrowAfterAsync(lexerFlags, scoop, fromStmtOrExpr, astProp) {\r\n        if (curtok.str === 'await') {\r\n            THROW('Cannot use `await` as an arg name with async arrows');\r\n        }\r\n        if (fromStmtOrExpr === IS_STATEMENT) {\r\n            AST_open(astProp, 'ExpressionStatement');\r\n            astProp = 'expression';\r\n        }\r\n        AST_open(astProp, 'ArrowFunctionExpression');\r\n        AST_set('params', []);\r\n        let paramScoop = SCOPE_addLexTo(scoop, ARG_SCOPE, '_parseAsync(parenless-arrow)');\r\n        parseBinding(lexerFlags, paramScoop, BINDING_TYPE_ARG, FROM_ASYNC_ARG, ASSIGNMENT_IS_DEFAULT, SKIP_DUPE_CHECKS, UNDEF_EXPORTS, UNDEF_EXPORTS, 'params');\r\n        if (curtok.str !== '=>')\r\n            THROW('Missing rest of async arrow');\r\n        if (curtok.nl)\r\n            THROW('Can not have newline between arrow arg and actual arrow');\r\n        parseArrowFromPunc(lexerFlags, scoop, WAS_ASYNC, ARGS_SIMPLE);\r\n        AST_close('ArrowFunctionExpression');\r\n        if (fromStmtOrExpr === IS_STATEMENT) {\r\n            AST_close('ExpressionStatement');\r\n            parseSemiOrAsi(lexerFlags);\r\n        }\r\n        return NOT_ASSIGNABLE;\r\n    }\r\n    function parseExpressionFromOp(lexerFlags, assignable, astProp) {\r\n        ASSERT(parseExpressionFromOp.length === arguments.length, 'arg count');\r\n        ASSERT(typeof assignable === 'number', 'assignable num');\r\n        if (isAssignable(assignable) && isAssignBinOp()) {\r\n            assignable = parseExpressionFromAssignmentOp(lexerFlags, assignable, astProp);\r\n        }\r\n        else {\r\n            let first = true;\r\n            while (isNonAssignBinOp(lexerFlags) || curc === $$QMARK_3F) {\r\n                if (curc === $$QMARK_3F) {\r\n                    let nowAssignable = parseExpressionFromTernaryOp(lexerFlags, astProp);\r\n                    assignable = setNotAssignable(nowAssignable | assignable);\r\n                }\r\n                else {\r\n                    let nowAssignable = parseExpressionFromBinaryOp(lexerFlags, astProp);\r\n                    assignable = setNotAssignable(nowAssignable | assignable);\r\n                }\r\n                if (curc === $$IS_3D && curtok.str === '=') {\r\n                    THROW('Cannot assign a value to non-assignable value');\r\n                }\r\n                first = false;\r\n            }\r\n        }\r\n        return assignable;\r\n    }\r\n    function parseExpressionFromAssignmentOp(lexerFlags, lhsAssignable, astProp) {\r\n        if (curc === $$IS_3D && curtok.str === '=') {\r\n            let node = _path[_path.length - 1][astProp];\r\n            if (Array.isArray(node))\r\n                node = node[node.length - 1];\r\n            if (node.type === 'ArrayExpression' || node.type === 'ObjectExpression') {\r\n                AST_destruct(astProp);\r\n            }\r\n        }\r\n        AST_wrapClosed(astProp, 'AssignmentExpression', 'left');\r\n        AST_set('operator', curtok.str);\r\n        skipRex(lexerFlags);\r\n        let rhsAssignable = parseExpression(lexerFlags, ALLOW_ASSIGNMENT, 'right');\r\n        rhsAssignable = resetDestructibility(rhsAssignable);\r\n        AST_close('AssignmentExpression');\r\n        return mergeAssignable(rhsAssignable, lhsAssignable);\r\n    }\r\n    function parseExpressionFromBinaryOp(lexerFlags, astProp) {\r\n        let curop = curtok.str;\r\n        let AST_nodeName = (curop === '&&' || curop === '||') ? 'LogicalExpression' : 'BinaryExpression';\r\n        AST_wrapClosed(astProp, AST_nodeName, 'left');\r\n        AST_set('operator', curop);\r\n        skipRex(lexerFlags);\r\n        let assignable = parseValue(lexerFlags, NO_ASSIGNMENT, NOT_NEW_ARG, 'right');\r\n        while ((isNonAssignBinOp(lexerFlags) && getStrength(curtok.str) > getStrength(curop)) || curtok.str === '**') {\r\n            let nowAssignable = parseExpressionFromBinaryOp(lexerFlags, 'right');\r\n            assignable = mergeAssignable(nowAssignable, assignable);\r\n        }\r\n        AST_close(AST_nodeName);\r\n        return assignable;\r\n    }\r\n    function parseExpressionFromTernaryOp(lexerFlags, astProp) {\r\n        AST_wrapClosed(astProp, 'ConditionalExpression', 'test');\r\n        ASSERT_skipRex('?', lexerFlags);\r\n        let midAssignable = parseExpression(sansFlag(lexerFlags, LF_IN_FOR_LHS) | LF_NO_ASI, ALLOW_ASSIGNMENT, 'consequent');\r\n        if (curc !== $$COLON_3A) {\r\n            if (curc === $$COMMA_2C)\r\n                THROW('Can not use comma inside ternary expressions');\r\n            THROW('Unexpected character inside ternary');\r\n        }\r\n        ASSERT_skipRex(':', lexerFlags);\r\n        let rhsAssignable = parseExpression(lexerFlags, ALLOW_ASSIGNMENT, 'alternate');\r\n        AST_close('ConditionalExpression');\r\n        return setNotAssignable(midAssignable | rhsAssignable);\r\n    }\r\n    function parseExpressions(lexerFlags, allowAssignment, astProp) {\r\n        ASSERT(arguments.length === parseExpressions.length, 'arg count');\r\n        let assignable = parseExpression(lexerFlags, allowAssignment, astProp);\r\n        if (curc === $$COMMA_2C)\r\n            assignable = _parseExpressions(lexerFlags, assignable, astProp);\r\n        return assignable;\r\n    }\r\n    function _parseExpressions(lexerFlags, assignable, astProp) {\r\n        ASSERT(arguments.length === _parseExpressions.length, 'arg count');\r\n        ASSERT(curc === $$COMMA_2C, 'confirm at callsite');\r\n        AST_wrapClosedIntoArray(astProp, 'SequenceExpression', 'expressions', false);\r\n        assignable = __parseExpressions(lexerFlags, assignable, 'expressions');\r\n        AST_close('SequenceExpression');\r\n        return assignable;\r\n    }\r\n    function __parseExpressions(lexerFlags, assignable, astProp) {\r\n        ASSERT(__parseExpressions.length === arguments.length, 'arg count');\r\n        do {\r\n            ASSERT_skipRex(',', lexerFlags);\r\n            let nowAssignable = parseExpression(lexerFlags, ALLOW_ASSIGNMENT, astProp);\r\n            assignable |= nowAssignable;\r\n        } while (curc === $$COMMA_2C);\r\n        return setNotAssignable(assignable);\r\n    }\r\n    function isAssignBinOp() {\r\n        let str = curtok.str;\r\n        if (curc === $$IS_3D) {\r\n            return str === '=';\r\n        }\r\n        if (str.charCodeAt(str.length - 1) !== $$IS_3D)\r\n            return false;\r\n        switch (str) {\r\n            case '*=':\r\n            case '/=':\r\n            case '%=':\r\n            case '+=':\r\n            case '-=':\r\n            case '<<=':\r\n            case '>>=':\r\n            case '>>>=':\r\n            case '&=':\r\n            case '^=':\r\n            case '|=':\r\n            case '**=':\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isCompoundAssignment(str) {\r\n        let len = str.length;\r\n        if (len === 1)\r\n            return false;\r\n        if (str.charCodeAt(len - 1) !== $$IS_3D)\r\n            return false;\r\n        switch (str) {\r\n            case '*=':\r\n            case '/=':\r\n            case '%=':\r\n            case '+=':\r\n            case '-=':\r\n            case '<<=':\r\n            case '>>=':\r\n            case '>>>=':\r\n            case '&=':\r\n            case '^=':\r\n            case '|=':\r\n                return true;\r\n            case '**=':\r\n                if (targetEsVersion < VERSION_EXPONENTIATION && targetEsVersion !== VERSION_WHATEVER) {\r\n                    THROW('`**` is not supported in ES' + targetEsVersion);\r\n                }\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function isNonAssignBinOp(lexerFlags) {\r\n        ASSERT(isNonAssignBinOp.length === arguments.length, 'arg count');\r\n        switch (curtok.str) {\r\n            case '&&':\r\n            case '||':\r\n            case '+':\r\n            case '-':\r\n            case '*':\r\n            case '/':\r\n            case '&':\r\n            case '|':\r\n            case '^':\r\n            case '==':\r\n            case '!=':\r\n            case '===':\r\n            case '!==':\r\n            case '<':\r\n            case '<=':\r\n            case '>':\r\n            case '>=':\r\n            case '<<':\r\n            case '>>':\r\n            case '>>>':\r\n            case '%':\r\n            case 'instanceof':\r\n                return true;\r\n            case 'in':\r\n                return hasNoFlag(lexerFlags, LF_IN_FOR_LHS);\r\n            case '**':\r\n                if (targetEsVersion < VERSION_EXPONENTIATION && targetEsVersion !== VERSION_WHATEVER) {\r\n                    THROW('`**` is not supported in ES' + targetEsVersion);\r\n                }\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function getStrength(str) {\r\n        switch (str) {\r\n            case '**': return 15;\r\n            case '*': return 14;\r\n            case '/': return 14;\r\n            case '%': return 14;\r\n            case '+': return 13;\r\n            case '-': return 13;\r\n            case '<<': return 12;\r\n            case '>>': return 12;\r\n            case '>>>': return 12;\r\n            case '<': return 11;\r\n            case '<=': return 11;\r\n            case '>': return 11;\r\n            case '>=': return 11;\r\n            case 'in': return 11;\r\n            case 'of': return 11;\r\n            case 'instanceof': return 11;\r\n            case '==': return 10;\r\n            case '!=': return 10;\r\n            case '===': return 10;\r\n            case '!==': return 10;\r\n            case '&': return 9;\r\n            case '^': return 8;\r\n            case '|': return 7;\r\n            case '&&': return 6;\r\n            case '||': return 5;\r\n            case '?': return 4;\r\n            default: THROW('Unknown operator [' + str + ']');\r\n        }\r\n    }\r\n    function parseValue(lexerFlags, allowAssignment, isNewArg, astProp) {\r\n        ASSERT(arguments.length === parseValue.length, 'arg count');\r\n        let assignable = parseValueHeadBody(lexerFlags, PARSE_VALUE_MUST, isNewArg, allowAssignment, astProp);\r\n        return parseValueTail(lexerFlags, assignable, isNewArg, astProp);\r\n    }\r\n    function parseValueAfterIdent(lexerFlags, identToken, bindingType, allowAssignment, astProp) {\r\n        ASSERT(parseValueAfterIdent.length === arguments.length, 'arg count');\r\n        let assignable = parseValueHeadBodyAfterIdent(lexerFlags, identToken, bindingType, allowAssignment, astProp);\r\n        return parseValueTail(lexerFlags, assignable, NOT_NEW_ARG, astProp);\r\n    }\r\n    function parseYieldValueMaybe(lexerFlags, allowAssignment, astProp) {\r\n        let startok = curtok;\r\n        let assignable = parseValueHeadBody(lexerFlags, PARSE_VALUE_MAYBE, NOT_NEW_ARG, allowAssignment, astProp);\r\n        if (curtok === startok)\r\n            return YIELD_WITHOUT_VALUE;\r\n        assignable = parseValueTail(lexerFlags, assignable, NOT_NEW_ARG, astProp);\r\n        if (isAssignable(assignable))\r\n            return WITH_ASSIGNABLE;\r\n        return WITH_NON_ASSIGNABLE;\r\n    }\r\n    function parseValueHeadBody(lexerFlags, maybe, isNewArg, allowAssignment, astProp) {\r\n        ASSERT(arguments.length === parseValueHeadBody.length, 'argcount');\r\n        if (curtype === $IDENT) {\r\n            return parseValueHeadBodyIdent(lexerFlags, isNewArg, BINDING_TYPE_NONE, allowAssignment, astProp);\r\n        }\r\n        else if (hasAnyFlag(curtype, $NUMBER | $STRING | $REGEX)) {\r\n            AST_setLiteral(astProp, curtok);\r\n            skipDiv(lexerFlags);\r\n            return NOT_ASSIGNABLE;\r\n        }\r\n        else if (isTemplateStart(curtype)) {\r\n            parseTickExpression(lexerFlags, astProp);\r\n            return NOT_ASSIGNABLE;\r\n        }\r\n        else if (curtype === $PUNCTUATOR) {\r\n            if (curc === $$CURLY_L_7B) {\r\n                let wasDestruct = parseObjectLiteralPatternAndAssign(lexerFlags, DO_NOT_BIND, BINDING_TYPE_NONE, PARSE_INIT, NOT_CLASS_METHOD, UNDEF_EXPORTS, UNDEF_EXPORTS, astProp);\r\n                if (hasAllFlags(wasDestruct, MUST_DESTRUCT)) {\r\n                    if (curtok.str !== 'in' && curtok.str !== 'of') {\r\n                        THROW('Found a struct that must be destructured but was not');\r\n                    }\r\n                }\r\n                if (hasAllFlags(wasDestruct, DESTRUCTIBLE_PIGGY_BACK_WAS_PROTO)) {\r\n                    if (options_webCompat === WEB_COMPAT_ON) {\r\n                        THROW('Found an object with double `__proto__` which is not allowed');\r\n                    }\r\n                }\r\n                if (hasNoFlag(wasDestruct, CANT_DESTRUCT) && hasAllFlags(lexerFlags, LF_IN_FOR_LHS)) {\r\n                    return setAssignable(wasDestruct);\r\n                }\r\n                return setNotAssignable(wasDestruct);\r\n            }\r\n            else if (curc === $$SQUARE_L_5B) {\r\n                let wasDestruct = parseArrayLiteralPattern(lexerFlags, DO_NOT_BIND, BINDING_TYPE_NONE, PARSE_INIT, UNDEF_EXPORTS, UNDEF_EXPORTS, astProp);\r\n                if (hasAllFlags(wasDestruct, MUST_DESTRUCT)) {\r\n                    if (curtok.str !== 'in' && curtok.str !== 'of') {\r\n                        THROW('Found a struct that must be destructured but was not');\r\n                    }\r\n                }\r\n                if (hasAllFlags(wasDestruct, DESTRUCTIBLE_PIGGY_BACK_WAS_PROTO)) {\r\n                    if (options_webCompat === WEB_COMPAT_ON) {\r\n                        THROW('Found an object with double `__proto__` which is not allowed');\r\n                    }\r\n                }\r\n                if (hasNoFlag(wasDestruct, CANT_DESTRUCT) && hasAllFlags(lexerFlags, LF_IN_FOR_LHS)) {\r\n                    return setAssignable(wasDestruct);\r\n                }\r\n                return setNotAssignable(wasDestruct);\r\n            }\r\n            else if (curc === $$PAREN_L_28) {\r\n                return parseGroupToplevels(lexerFlags, IS_STATEMENT, allowAssignment, UNDEF_ASYNC, NOT_ASYNC_PREFIXED, astProp);\r\n            }\r\n            else if (curtok.str === '++' || curtok.str === '--') {\r\n                if (isNewArg === IS_NEW_ARG)\r\n                    THROW('Cannot `new` on an inc/dec expr');\r\n                AST_open(astProp, 'UpdateExpression');\r\n                AST_set('operator', curtok.str);\r\n                ASSERT_skipAny($PUNCTUATOR, lexerFlags);\r\n                AST_set('prefix', true);\r\n                let assignable = parseValue(lexerFlags, NO_ASSIGNMENT, NOT_NEW_ARG, 'argument');\r\n                if (notAssignable(assignable))\r\n                    THROW('Cannot inc/dec a non-assignable value as prefix');\r\n                AST_close('UpdateExpression');\r\n                return setNotAssignable(assignable);\r\n            }\r\n            else if (curtok.str === '+' || curtok.str === '-' || curtok.str === '!' || curtok.str === '~') {\r\n                if (isNewArg === IS_NEW_ARG)\r\n                    THROW('Cannot `new` on +/- prefixed value');\r\n                let name = curtok.str;\r\n                ASSERT_skipRex($PUNCTUATOR, lexerFlags);\r\n                parseUnary(lexerFlags, name, astProp);\r\n                return NOT_ASSIGNABLE;\r\n            }\r\n            else if (curc === $$DOT_2E) {\r\n                ASSERT(!hasAllFlags(curtype, $NUMBER_DEC), 'should be checked elsewhere');\r\n                if (curtok.str === '...') {\r\n                    THROW('Unexpected spread/rest dots');\r\n                }\r\n                else {\r\n                    THROW('Unexpected dot');\r\n                }\r\n            }\r\n        }\r\n        if (!maybe)\r\n            THROW('Expected to parse a value');\r\n        return 'FAIL (remove me)';\r\n    }\r\n    function parseValueHeadBodyIdent(lexerFlags, isNewArg, bindingType, allowAssignment, astProp) {\r\n        ASSERT(curtype === $IDENT, 'token should not yet have been consumed because the next token depends on its value and so you cant consume this ahead of time...');\r\n        ASSERT(arguments.length === parseValueHeadBodyIdent.length, 'arg count');\r\n        ASSERT(isNewArg === NOT_NEW_ARG || allowAssignment === NO_ASSIGNMENT, 'new arg does not allow assignments');\r\n        let identToken = curtok;\r\n        let assignable = 0;\r\n        let identName = identToken.str;\r\n        switch (identName) {\r\n            case 'arguments':\r\n                ASSERT_skipDiv('arguments', lexerFlags);\r\n                assignable = verifyEvalArgumentsVar(lexerFlags);\r\n                break;\r\n            case 'async':\r\n                ASSERT_skipAny('async', lexerFlags);\r\n                return parseAsyncExpression(lexerFlags, DO_NOT_BIND, identToken, isNewArg, NOT_EXPORT, allowAssignment, astProp);\r\n            case 'await':\r\n                ASSERT_skipRex($IDENT, lexerFlags);\r\n                return parseAwait(lexerFlags, identToken, isNewArg, allowAssignment, astProp);\r\n            case 'class':\r\n                ASSERT_skipAny('class', lexerFlags);\r\n                return parseClassExpression(lexerFlags, astProp);\r\n            case 'delete':\r\n                if (isNewArg === IS_NEW_ARG)\r\n                    THROW('Cannot delete inside `new`');\r\n                ASSERT_skipRex('delete', lexerFlags);\r\n                return parseDeleteExpression(lexerFlags, assignable, astProp);\r\n            case 'eval':\r\n                ASSERT_skipDiv('eval', lexerFlags);\r\n                assignable = verifyEvalArgumentsVar(lexerFlags);\r\n                break;\r\n            case 'false':\r\n                ASSERT_skipDiv('false', lexerFlags);\r\n                return parseFalseKeyword(astProp);\r\n            case 'function':\r\n                ASSERT_skipAny('function', lexerFlags);\r\n                parseFunctionExpression(lexerFlags, NOT_ASYNC, astProp);\r\n                return NOT_ASSIGNABLE;\r\n            case 'let':\r\n                if (bindingType === BINDING_TYPE_CLASS)\r\n                    THROW('Can not use `let` as a class name');\r\n                if (bindingType === BINDING_TYPE_LET || bindingType === BINDING_TYPE_CONST) {\r\n                    THROW('Can not use `let` when binding through `let` or `const`');\r\n                }\r\n                if (hasAllFlags(lexerFlags, LF_STRICT_MODE))\r\n                    THROW('Can not use `let` as variable name in strict mode');\r\n                ASSERT_skipDiv($IDENT, lexerFlags);\r\n                assignable = initAssignable(assignable);\r\n                break;\r\n            case 'new':\r\n                ASSERT_skipRex('new', lexerFlags);\r\n                let newAssignable = parseNewKeyword(lexerFlags, astProp);\r\n                return setNotAssignable(newAssignable);\r\n            case 'null':\r\n                ASSERT_skipDiv('null', lexerFlags);\r\n                return parseNullKeyword(astProp);\r\n            case 'super':\r\n                ASSERT_skipAny('super', lexerFlags);\r\n                return parseSuperKeyword(lexerFlags, astProp);\r\n            case 'true':\r\n                ASSERT_skipDiv('true', lexerFlags);\r\n                return parseTrueKeyword(astProp);\r\n            case 'this':\r\n                ASSERT_skipDiv('this', lexerFlags);\r\n                return parseThisKeyword(astProp);\r\n            case 'typeof':\r\n            case 'void':\r\n                if (isNewArg === IS_NEW_ARG)\r\n                    THROW('Cannot ' + identName + ' inside `new`');\r\n                ASSERT_skipRex($IDENT, lexerFlags);\r\n                return parseUnary(lexerFlags, identName, astProp);\r\n            case 'yield':\r\n                if (allowAssignment === NO_ASSIGNMENT) {\r\n                    bindingIdentCheck(identToken, BINDING_TYPE_NONE, lexerFlags);\r\n                    AST_setIdent(astProp, identToken);\r\n                    ASSERT_skipDiv($IDENT, lexerFlags);\r\n                    return IS_ASSIGNABLE;\r\n                }\r\n                else {\r\n                    ASSERT_skipRex($IDENT, lexerFlags);\r\n                    ASSERT(isNewArg === NOT_NEW_ARG || allowAssignment === NO_ASSIGNMENT, 'new arg does not allow assignments so no need to check `new yield x` here');\r\n                    return parseYield(lexerFlags, identToken, allowAssignment, astProp);\r\n                }\r\n            default:\r\n                if (!checkIdentReadable(lexerFlags, bindingType, identToken))\r\n                    THROW('Illegal keyword encountered; is not a value [' + identToken.str + ']');\r\n                ASSERT_skipDiv($IDENT, lexerFlags);\r\n                bindingIdentCheck(identToken, bindingType, lexerFlags);\r\n                assignable = initAssignable(assignable);\r\n        }\r\n        ASSERT(assignable !== 0, 'every branch that breaks should update this');\r\n        parseAfterVarName(lexerFlags, identToken, assignable, allowAssignment, astProp);\r\n        return assignable;\r\n    }\r\n    function parseValueHeadBodyAfterIdent(lexerFlags, identToken, bindingType, allowAssignment, astProp) {\r\n        ASSERT(parseValueHeadBodyAfterIdent.length === arguments.length, 'expecting args');\r\n        ASSERT(identToken.type === $IDENT, 'should have consumed token. make sure you checked whether the token after can be div or regex...');\r\n        ASSERT(identToken !== curtok, 'should have consumed this');\r\n        let assignable = 0;\r\n        let identName = identToken.str;\r\n        switch (identName) {\r\n            case 'arguments':\r\n                assignable = verifyEvalArgumentsVar(lexerFlags);\r\n                break;\r\n            case 'async':\r\n                return parseAsyncExpression(lexerFlags, DO_NOT_BIND, identToken, NOT_NEW_ARG, NOT_EXPORT, allowAssignment, astProp);\r\n            case 'await':\r\n                return parseAwait(lexerFlags, identToken, NOT_NEW_ARG, allowAssignment, astProp);\r\n            case 'class':\r\n                return parseClassExpression(lexerFlags, astProp);\r\n            case 'delete':\r\n                ASSERT(curtok !== identToken, 'should have skipped');\r\n                return parseDeleteExpression(lexerFlags, assignable, astProp);\r\n            case 'eval':\r\n                assignable = verifyEvalArgumentsVar(lexerFlags);\r\n                break;\r\n            case 'false':\r\n                return parseFalseKeyword(astProp);\r\n            case 'function':\r\n                parseFunctionExpression(lexerFlags, NOT_ASYNC, astProp);\r\n                return NOT_ASSIGNABLE;\r\n            case 'let':\r\n                if (hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n                    THROW('Cannot have `let[...]` as a var name in strict mode');\r\n                }\r\n                if (bindingType === BINDING_TYPE_LET)\r\n                    THROW('Cannot use `let` as a let binding');\r\n                assignable = initAssignable(assignable);\r\n                break;\r\n            case 'new':\r\n                let newAssignable = parseNewKeyword(lexerFlags, astProp);\r\n                return setNotAssignable(newAssignable);\r\n            case 'null':\r\n                return parseNullKeyword(astProp);\r\n            case 'super':\r\n                return parseSuperKeyword(lexerFlags, astProp);\r\n            case 'true':\r\n                return parseTrueKeyword(astProp);\r\n            case 'this':\r\n                return parseThisKeyword(astProp);\r\n            case 'typeof':\r\n            case 'void':\r\n                return parseUnary(lexerFlags, identName, astProp);\r\n            case 'yield':\r\n                return parseYield(lexerFlags, identToken, allowAssignment, astProp);\r\n            default:\r\n                if (!checkIdentReadable(lexerFlags, bindingType, identToken))\r\n                    THROW('Illegal keyword encountered; is not a value [' + identToken.str + ']');\r\n                assignable = initAssignable(assignable);\r\n        }\r\n        ASSERT(assignable !== 0, 'everything that breaks should update this');\r\n        parseAfterVarName(lexerFlags, identToken, assignable, allowAssignment, astProp);\r\n        return assignable;\r\n    }\r\n    function verifyEvalArgumentsVar(lexerFlags) {\r\n        if (hasNoFlag(lexerFlags, LF_STRICT_MODE))\r\n            return IS_ASSIGNABLE;\r\n        if (isAssignBinOp()) {\r\n            THROW('Cannot assign to `eval`');\r\n        }\r\n        switch (curtok.str) {\r\n            case '++':\r\n            case '--':\r\n                THROW('Cannot assign to `eval`');\r\n        }\r\n        return NOT_ASSIGNABLE;\r\n    }\r\n    function parseTrueKeyword(astProp) {\r\n        AST_open(astProp, 'Literal');\r\n        AST_set('value', true);\r\n        AST_set('raw', 'true');\r\n        AST_close('Literal');\r\n        return NOT_ASSIGNABLE;\r\n    }\r\n    function parseFalseKeyword(astProp) {\r\n        AST_open(astProp, 'Literal');\r\n        AST_set('value', false);\r\n        AST_set('raw', 'false');\r\n        AST_close('Literal');\r\n        return NOT_ASSIGNABLE;\r\n    }\r\n    function parseNullKeyword(astProp) {\r\n        AST_open(astProp, 'Literal');\r\n        AST_set('value', null);\r\n        AST_set('raw', 'null');\r\n        AST_close('Literal');\r\n        return NOT_ASSIGNABLE;\r\n    }\r\n    function parseSuperKeyword(lexerFlags, astProp) {\r\n        AST_open(astProp, 'Super');\r\n        AST_close('Super');\r\n        if (curc === $$PAREN_L_28) {\r\n            if (hasNoFlag(lexerFlags, LF_SUPER_CALL))\r\n                THROW('Can only use `super()` in constructors of classes that extend another class');\r\n            return NOT_ASSIGNABLE;\r\n        }\r\n        if (curc === $$SQUARE_L_5B || curtok.str === '.') {\r\n            if (hasNoFlag(lexerFlags, LF_SUPER_PROP)) {\r\n                if (curc === $$SQUARE_L_5B) {\r\n                    THROW('Can only use `super[foo]` in class or object methods or in arrows nested in those methods/arrows');\r\n                }\r\n                else {\r\n                    THROW('Can only use `super.foo` in class or object methods or in arrows nested in those methods/arrows');\r\n                }\r\n            }\r\n            return NOT_ASSIGNABLE;\r\n        }\r\n        THROW('The `super` keyword can only be used as call or member expression');\r\n    }\r\n    function parseNewKeyword(lexerFlags, astProp) {\r\n        if (curtok.str === '.')\r\n            return parseNewDotTarget(lexerFlags, astProp);\r\n        return parseNewExpression(lexerFlags, astProp);\r\n    }\r\n    function parseNewDotTarget(lexerFlags, astProp) {\r\n        if (hasNoFlag(lexerFlags, LF_CAN_NEW_DOT_TARGET)) {\r\n            THROW('Must be inside/nested a regular function to use `new.target`');\r\n        }\r\n        ASSERT_skipAny('.', lexerFlags);\r\n        if (curtok.str !== 'target')\r\n            THROW('Can only read `new.target`, no other \"properties\" from `new`');\r\n        AST_open(astProp, 'MetaProperty');\r\n        AST_open('meta', 'Identifier');\r\n        AST_set('name', 'new');\r\n        AST_close('Identifier');\r\n        AST_open('property', 'Identifier');\r\n        AST_set('name', 'target');\r\n        AST_close('Identifier');\r\n        ASSERT_skipDiv('target', lexerFlags);\r\n        AST_close('MetaProperty');\r\n        return NOT_ASSIGNABLE;\r\n    }\r\n    function parseNewExpression(lexerFlags, astProp) {\r\n        AST_open(astProp, 'NewExpression');\r\n        AST_set('arguments', []);\r\n        parseValue(lexerFlags, NO_ASSIGNMENT, IS_NEW_ARG, 'callee');\r\n        AST_close('NewExpression');\r\n        return NOT_ASSIGNABLE;\r\n    }\r\n    function parseThisKeyword(astProp) {\r\n        AST_open(astProp, 'ThisExpression');\r\n        AST_close('ThisExpression');\r\n        return NOT_ASSIGNABLE;\r\n    }\r\n    function parseUnary(lexerFlags, identName, astProp) {\r\n        ASSERT(identName !== 'delete', 'delete has a special parser');\r\n        ASSERT(identName !== 'new', 'new has a special parser');\r\n        ASSERT(identName !== 'yield', 'yield has a special parser');\r\n        ASSERT(identName !== 'await', 'await has a special parser');\r\n        AST_open(astProp, 'UnaryExpression');\r\n        AST_set('operator', identName);\r\n        AST_set('prefix', true);\r\n        parseValue(lexerFlags, NO_ASSIGNMENT, NOT_NEW_ARG, 'argument');\r\n        AST_close('UnaryExpression');\r\n        if (curtok.str === '**') {\r\n            THROW('The lhs of ** can not be this kind of unary expression (syntactically not allowed, you have to wrap something)');\r\n        }\r\n        return NOT_ASSIGNABLE;\r\n    }\r\n    function parseYield(lexerFlags, identToken, allowAssignment, astProp) {\r\n        ASSERT(arguments.length === parseYield.length, 'arg count');\r\n        ASSERT(identToken !== curtok, 'should have consumed the ident already');\r\n        ASSERT(identToken.str === 'yield', 'should receive the yield keyword token that was already consumed');\r\n        if (hasAnyFlag(lexerFlags, LF_IN_GENERATOR)) {\r\n            return parseYieldKeyword(lexerFlags, allowAssignment, astProp);\r\n        }\r\n        return parseYieldVarname(lexerFlags, identToken, allowAssignment, astProp);\r\n    }\r\n    function parseYieldKeyword(lexerFlags, allowAssignment, astProp) {\r\n        ASSERT(parseYieldKeyword.length === arguments.length, 'arg count');\r\n        if (hasAllFlags(lexerFlags, LF_IN_FUNC_ARGS)) {\r\n            THROW('The `yield` keyword in arg default must be a var name but that is not allowed inside a generator');\r\n        }\r\n        if (allowAssignment === NO_ASSIGNMENT) {\r\n            THROW('Did not expect to parse an AssignmentExpression but found `yield`');\r\n        }\r\n        AST_open(astProp, 'YieldExpression');\r\n        AST_set('delegate', false);\r\n        parseYieldArgument(lexerFlags, 'argument');\r\n        AST_close('YieldExpression');\r\n        if (curc === $$QMARK_3F) {\r\n            ASSERT(curtok.str === '?', 'just in case more tokens can start with `?`');\r\n            THROW('Can not have a `yield` expression on the left side of a ternary');\r\n        }\r\n        return NOT_ASSIGNABLE | DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_OR_YIELD_KEYWORD;\r\n    }\r\n    function parseYieldVarname(lexerFlags, identToken, allowAssignment, astProp) {\r\n        ASSERT(parseYieldVarname.length === arguments.length, 'arg count');\r\n        if (hasAllFlags(lexerFlags, LF_STRICT_MODE)) {\r\n            THROW('Cannot use `yield` outside of generator functions when in strict mode');\r\n        }\r\n        parseAfterVarName(lexerFlags, identToken, IS_ASSIGNABLE, allowAssignment, astProp);\r\n        return IS_ASSIGNABLE | DESTRUCTIBLE_PIGGY_BACK_SAW_YIELD_VARNAME;\r\n    }\r\n    function parseYieldArgument(lexerFlags, astProp) {\r\n        let hadValue = curtok.nl ? false : parseYieldValueMaybe(lexerFlags, ALLOW_ASSIGNMENT, astProp);\r\n        if (hadValue === YIELD_WITHOUT_VALUE) {\r\n            AST_set(astProp, null);\r\n        }\r\n        else {\r\n            parseExpressionFromOp(lexerFlags, hadValue === WITH_ASSIGNABLE ? IS_ASSIGNABLE : NOT_ASSIGNABLE, astProp);\r\n        }\r\n    }\r\n    function parseAfterVarName(lexerFlags, identToken, assignable, allowAssignment, astProp) {\r\n        ASSERT(parseAfterVarName.length === arguments.length, 'arg count');\r\n        if (curc === $$IS_3D && curtok.str === '=>') {\r\n            if (curtok.nl)\r\n                THROW('The arrow is a restricted production an there can not be a newline before `=>` token');\r\n            if (allowAssignment === NO_ASSIGNMENT) {\r\n                THROW('Was parsing a value that could not be AssignmentExpression but found an arrow');\r\n            }\r\n            if (hasAnyFlag(lexerFlags, LF_IN_GENERATOR | LF_IN_ASYNC) && identToken.str === 'yield')\r\n                THROW('Yield in generator is keyword');\r\n            ASSERT(isAssignable(assignable), 'not sure whether an arrow can be valid if the arg is marked as non-assignable');\r\n            return parseArrowParenlessFromPunc(lexerFlags, identToken, astProp);\r\n        }\r\n        else {\r\n            AST_setIdent(astProp, identToken);\r\n            return assignable;\r\n        }\r\n    }\r\n    function parseArrowParenlessFromPunc(lexerFlags, identToken, astProp) {\r\n        ASSERT(parseArrowParenlessFromPunc.length === arguments.length, 'arg count');\r\n        ASSERT(curtok.str === '=>', 'punc is arrow');\r\n        let scoop = SCOPE_create('parseArrowParenlessFromPunc');\r\n        scoop.lex.type = ARG_SCOPE;\r\n        SCOPE_addBindingAndDedupe(lexerFlags, scoop, identToken.str, BINDING_TYPE_ARG, ORIGIN_NOT_VAR_DECL);\r\n        if (identToken.str === 'await' && hasAnyFlag(lexerFlags, LF_IN_ASYNC)) {\r\n            THROW('Cannot use `await` as an arrow parameter name inside another async function');\r\n        }\r\n        AST_open(astProp, 'ArrowFunctionExpression');\r\n        AST_set('params', []);\r\n        AST_setIdent('params', identToken);\r\n        parseArrowFromPunc(lexerFlags, scoop, NOT_ASYNC, ARGS_SIMPLE);\r\n        AST_close('ArrowFunctionExpression');\r\n        return NOT_ASSIGNABLE;\r\n    }\r\n    function parseTickExpression(lexerFlags, astProp) {\r\n        ASSERT(typeof lexerFlags === 'number', 'lexerFlags number');\r\n        ASSERT(hasNoFlag(lexerFlags, LF_IN_TEMPLATE) || isTemplateStart(curtype), 'if in template this function can only be called by the head of a nested template', debug_toktype(curtype, false));\r\n        AST_open(astProp, 'TemplateLiteral');\r\n        AST_set('expressions', []);\r\n        AST_set('quasis', []);\r\n        let awaitYieldFlagsFromAssignable = 0;\r\n        if (hasAllFlags(curtype, $TICK_PURE)) {\r\n            parseQuasiPart(lexerFlags, IS_QUASI_TAIL);\r\n        }\r\n        else if (hasAllFlags(curtype, $TICK_HEAD)) {\r\n            parseQuasiPart(lexerFlags | LF_IN_TEMPLATE, NOT_QUASI_TAIL);\r\n            do {\r\n                awaitYieldFlagsFromAssignable |= parseExpressions(lexerFlags | LF_IN_TEMPLATE, ALLOW_ASSIGNMENT, 'expressions');\r\n                AST_open('quasis', 'TemplateElement');\r\n                AST_set('tail', hasAllFlags(curtype, $TICK_TAIL));\r\n                AST_set('value', { raw: curtok.str, cooked: '<TODO>' });\r\n                AST_close('TemplateElement');\r\n                if (hasAllFlags(curtype, $TICK_BAD_ESCAPE)) {\r\n                    THROW('Template contained an illegal escape, these are only allowed in _tagged_ templates');\r\n                }\r\n                if (!hasAllFlags(curtype, $TICK_BODY) && !hasAllFlags(curtype, $TICK_TAIL)) {\r\n                    THROW('The first token after the template expression should be a continuation of the template');\r\n                }\r\n                if (hasAllFlags(curtype, $TICK_BODY)) {\r\n                    ASSERT_skipRex(curtok.str, lexerFlags | LF_IN_TEMPLATE);\r\n                }\r\n                else if (hasAllFlags(curtype, $TICK_TAIL)) {\r\n                    ASSERT_skipDiv(curtok.str, lexerFlags);\r\n                    break;\r\n                }\r\n                else {\r\n                    THROW('Unclosed template');\r\n                }\r\n            } while (true);\r\n        }\r\n        else {\r\n            if (hasAllFlags(curtype, $TICK_BAD_ESCAPE))\r\n                THROW('Template containd bad escape');\r\n            THROW('Template should start as head or pure');\r\n        }\r\n        AST_close('TemplateLiteral');\r\n        return awaitYieldFlagsFromAssignable;\r\n    }\r\n    function parseQuasiPart(lexerFlags, tail) {\r\n        ASSERT(arguments.length === parseQuasiPart.length, 'arg count');\r\n        AST_open('quasis', 'TemplateElement');\r\n        AST_set('tail', tail);\r\n        AST_set('value', { raw: curtok.str, cooked: '<TODO>' });\r\n        if (hasAllFlags(curtype, $TICK_BAD_ESCAPE)) {\r\n            THROW('Template contained an illegal escape', debug_toktype(curtype, false), '' + curtok, curtype, $TICK_BAD_ESCAPE);\r\n        }\r\n        if (hasAllFlags(curtype, $TICK_PURE)) {\r\n            ASSERT_skipDiv(curtok.str, lexerFlags);\r\n        }\r\n        else {\r\n            ASSERT(hasAllFlags(curtype, $TICK_HEAD), 'not used for other ticks');\r\n            ASSERT_skipRex(curtok.str, lexerFlags);\r\n        }\r\n        AST_close('TemplateElement');\r\n    }\r\n    function parseValueTail(lexerFlags, assignable, isNewArg, astProp) {\r\n        ASSERT(parseValueTail.length === arguments.length, 'arg coung');\r\n        ASSERT(isNewArg === IS_NEW_ARG || isNewArg === NOT_NEW_ARG, 'enum');\r\n        ASSERT(typeof assignable === 'number', 'assignablenum', assignable);\r\n        ASSERT(typeof astProp === 'string', 'should be string');\r\n        if (curc === $$DOT_2E && curtok.str === '.') {\r\n            ASSERT_skipAny('.', lexerFlags);\r\n            if (curtype !== $IDENT)\r\n                THROW('Dot property must be an identifier');\r\n            AST_wrapClosed(astProp, 'MemberExpression', 'object');\r\n            AST_setIdent('property', curtok);\r\n            ASSERT_skipDiv($IDENT, lexerFlags);\r\n            AST_set('computed', false);\r\n            AST_close('MemberExpression');\r\n            assignable = parseValueTail(lexerFlags, setAssignable(assignable), isNewArg, astProp);\r\n        }\r\n        else if (curc === $$SQUARE_L_5B) {\r\n            AST_wrapClosed(astProp, 'MemberExpression', 'object');\r\n            ASSERT_skipRex('[', lexerFlags);\r\n            let nowAssignable = parseExpression(lexerFlags, ALLOW_ASSIGNMENT, 'property');\r\n            assignable = mergeAssignable(nowAssignable, assignable);\r\n            skipDivOrDieSingleChar($$SQUARE_R_5D, lexerFlags);\r\n            AST_set('computed', true);\r\n            AST_close('MemberExpression');\r\n            assignable = parseValueTail(lexerFlags | LF_NO_ASI, setAssignable(assignable), isNewArg, astProp);\r\n        }\r\n        else if (curc === $$PAREN_L_28) {\r\n            if (isNewArg === IS_NEW_ARG) {\r\n                let nowAssignable = parseCallArgs(lexerFlags | LF_NO_ASI, 'arguments');\r\n                assignable = mergeAssignable(nowAssignable, assignable);\r\n                if (curtok.str === '=>') {\r\n                    THROW('The `new` keyword can not be applied to an arrow');\r\n                }\r\n                assignable = setNotAssignable(assignable);\r\n            }\r\n            else {\r\n                ASSERT(typeof astProp === 'string', 'should be string');\r\n                AST_wrapClosed(astProp, 'CallExpression', 'callee');\r\n                AST_set('arguments', []);\r\n                let nowAssignable = parseCallArgs(lexerFlags, 'arguments');\r\n                assignable = mergeAssignable(nowAssignable, assignable);\r\n                AST_close('CallExpression');\r\n                assignable = parseValueTail(lexerFlags | LF_NO_ASI, setNotAssignable(assignable), isNewArg, astProp);\r\n            }\r\n        }\r\n        else if (curc === $$TICK_60 && isTemplateStart(curtype)) {\r\n            AST_wrapClosed(astProp, 'TaggedTemplateExpression', 'tag');\r\n            AST_open('quasi', 'TemplateLiteral');\r\n            AST_set('expressions', []);\r\n            AST_set('quasis', []);\r\n            AST_open('quasis', 'TemplateElement');\r\n            AST_set('value', { raw: curtok.str.slice(1, hasAllFlags(curtype, $TICK_PURE) ? -1 : -2), cooked: '<TODO>' });\r\n            AST_set('tail', hasAllFlags(curtype, $TICK_PURE));\r\n            AST_close('TemplateElement');\r\n            if (!allowBadEscapesInTaggedTemplates && hasAllFlags(curtype, $TICK_BAD_ESCAPE)) {\r\n                THROW('Template contained an illegal escape', debug_toktype(curtype, false), '' + curtok);\r\n            }\r\n            if (hasAllFlags(curtype, $TICK_HEAD)) {\r\n                let lfbak = lexerFlags;\r\n                lexerFlags = lexerFlags | LF_IN_TEMPLATE;\r\n                do {\r\n                    ASSERT_skipRex($TICK, lexerFlags);\r\n                    let nowAssignable = parseExpression(lexerFlags, ALLOW_ASSIGNMENT, 'expressions');\r\n                    assignable = mergeAssignable(nowAssignable, assignable);\r\n                    if ((targetEsVersion >= 6 && targetEsVersion < 9) && hasAllFlags(curtype, $TICK_BAD_ESCAPE)) {\r\n                        THROW('Template contained an illegal escape', debug_toktype(curtype, false), '' + curtok);\r\n                    }\r\n                    if (!hasAllFlags(curtype, $TICK_BODY) && !hasAllFlags(curtype, $TICK_TAIL)) {\r\n                        THROW('The first token after the tagged template expression should be a continuation of the template');\r\n                    }\r\n                    AST_open('quasis', 'TemplateElement');\r\n                    AST_set('value', { raw: curtok.str.slice(1, hasAllFlags(curtype, $TICK_TAIL) ? -1 : -2), cooked: '<TODO>' });\r\n                    AST_set('tail', hasAllFlags(curtype, $TICK_TAIL));\r\n                    AST_close('TemplateElement');\r\n                    if (hasAllFlags(curtype, $TICK_TAIL))\r\n                        lexerFlags = lfbak;\r\n                } while (!hasAllFlags(curtype, $TICK_TAIL));\r\n            }\r\n            else {\r\n                ASSERT(hasAllFlags(curtype, $TICK_PURE), 'isTemplateStart should have asserted that the type was either tick pure or head');\r\n            }\r\n            ASSERT_skipRex($TICK, lexerFlags);\r\n            AST_close('TemplateLiteral');\r\n            AST_close('TaggedTemplateExpression');\r\n            assignable = parseValueTail(lexerFlags, setNotAssignable(assignable), isNewArg, astProp);\r\n        }\r\n        else if (isNewArg === IS_NEW_ARG) {\r\n            assignable = setNotAssignable(assignable);\r\n        }\r\n        else if ((curc === $$PLUS_2B && curtok.str === '++') || (curc === $$DASH_2D && curtok.str === '--')) {\r\n            assignable = parseUpdateExpressionSuffix(lexerFlags, assignable, astProp);\r\n        }\r\n        return assignable;\r\n    }\r\n    function parseUpdateExpressionSuffix(lexerFlags, assignable, astProp) {\r\n        ASSERT(curtok.str === '++' || curtok.str === '--', 'only for update unaries');\r\n        if (curtok.nl) {\r\n            if (hasAllFlags(lexerFlags, LF_NO_ASI)) {\r\n                THROW('The postfix ++/-- is a restricted production so ASI must apply but that is not valid in this context');\r\n            }\r\n            return assignable;\r\n        }\r\n        if (notAssignable(assignable))\r\n            THROW('Cannot inc/dec a non-assignable value as postfix');\r\n        AST_wrapClosed(astProp, 'UpdateExpression', 'argument');\r\n        AST_set('operator', curtok.str);\r\n        AST_set('prefix', false);\r\n        ASSERT_skipDiv($PUNCTUATOR, lexerFlags);\r\n        AST_close('UpdateExpression');\r\n        return NOT_ASSIGNABLE;\r\n    }\r\n    function parseCallArgs(lexerFlags, astProp) {\r\n        ASSERT_skipRex('(', lexerFlags);\r\n        let assignable = 0;\r\n        if (curc === $$PAREN_R_29) {\r\n            ASSERT_skipDiv(')', lexerFlags);\r\n        }\r\n        else {\r\n            do {\r\n                if (curc === $$DOT_2E && curtok.str === '...') {\r\n                    AST_open(astProp, 'SpreadElement');\r\n                    ASSERT_skipRex($PUNCTUATOR, lexerFlags);\r\n                    let nowAssignable = parseExpression(lexerFlags, ALLOW_ASSIGNMENT, 'argument');\r\n                    assignable = mergeAssignable(nowAssignable, assignable);\r\n                    AST_close('SpreadElement');\r\n                }\r\n                else {\r\n                    let nowAssignable = parseExpression(lexerFlags, ALLOW_ASSIGNMENT, astProp);\r\n                    assignable = mergeAssignable(nowAssignable, assignable);\r\n                }\r\n                if (curc !== $$COMMA_2C)\r\n                    break;\r\n                ASSERT_skipRex(',', lexerFlags);\r\n                if (curc === $$PAREN_R_29) {\r\n                    if (allowTrailingFunctionComma)\r\n                        break;\r\n                    THROW('Targeted language version does not support trailing call arg comma');\r\n                }\r\n            } while (true);\r\n            skipDivOrDieSingleChar($$PAREN_R_29, lexerFlags);\r\n        }\r\n        return assignable;\r\n    }\r\n    function parseArrowFromPunc(lexerFlags, scoop, isAsync, wasSimple) {\r\n        ASSERT(arguments.length === parseArrowFromPunc.length, 'arg count');\r\n        ASSERT(typeof isAsync === 'boolean', 'isasync bool');\r\n        ASSERT_skipRex('=>', lexerFlags);\r\n        ASSERT(_path[_path.length - 1] && _path[_path.length - 1].params, 'params should be wrapped in arrow node now');\r\n        ASSERT(!isAsync || allowAsyncFunctions, 'async = es8');\r\n        AST_set('id', null);\r\n        AST_set('generator', false);\r\n        AST_set('async', isAsync);\r\n        lexerFlags = resetLexerFlagsForFuncAndArrow(lexerFlags, NOT_GENERATOR, isAsync, IS_ARROW);\r\n        if (curc === $$CURLY_L_7B) {\r\n            AST_set('expression', false);\r\n            parseBlockStatement(sansFlag(lexerFlags | LF_IN_SCOPE_ROOT, LF_IN_GLOBAL | LF_IN_SWITCH | LF_IN_ITERATION), SCOPE_addLexTo(scoop, BLOCK_SCOPE, 'parseArrowFromPunc'), { _: 'arrow labels' }, IS_EXPRESSION, PARSE_DIRECTIVES, wasSimple, INC_DECL, 'body');\r\n        }\r\n        else {\r\n            AST_set('expression', true);\r\n            parseExpression(lexerFlags, ALLOW_ASSIGNMENT, 'body');\r\n        }\r\n    }\r\n    function parseGroupToplevels(lexerFlags, asyncStmtOrExpr, allowAssignment, asyncToken, newlineAfterAsync, astProp) {\r\n        ASSERT(parseGroupToplevels.length === arguments.length, 'expecting args');\r\n        skipRexOrDieSingleChar($$PAREN_L_28, lexerFlags);\r\n        return _parseGroupToplevels(lexerFlags, asyncStmtOrExpr, allowAssignment, NOT_DELETE_ARG, asyncToken, newlineAfterAsync, astProp);\r\n    }\r\n    function _parseGroupToplevels(lexerFlagsBeforeParen, asyncStmtOrExpr, allowAssignment, isDeleteArg, asyncToken, newlineAfterAsync, astProp) {\r\n        let lexerFlags = lexerFlagsBeforeParen | LF_NO_ASI;\r\n        let scoop = SCOPE_create('_parseGroupToplevels');\r\n        scoop.lex.type = ARG_SCOPE;\r\n        ASSERT(scoop._ = 'arrow scope', false);\r\n        if (curc === $$PAREN_R_29) {\r\n            if (asyncToken !== UNDEF_ASYNC) {\r\n                skipDivOrDieSingleChar($$PAREN_R_29, lexerFlags);\r\n                return parseAfterAsyncGroup(lexerFlagsBeforeParen, scoop, asyncStmtOrExpr, allowAssignment, ARGS_SIMPLE, false, newlineAfterAsync, MIGHT_DESTRUCT, true, asyncToken, astProp);\r\n            }\r\n            skipAnyOrDieSingleChar($$PAREN_R_29, lexerFlags);\r\n            lexerFlags = lexerFlagsBeforeParen;\r\n            if (curtok.str !== '=>') {\r\n                THROW('Empty group must indicate an arrow, async(), or await()');\r\n            }\r\n            else if (curtok.nl) {\r\n                THROW('The arrow token `=>` is a restricted production and cannot have a newline preceding it');\r\n            }\r\n            if (allowAssignment === NO_ASSIGNMENT) {\r\n                THROW('Was parsing something that could not be an assignment expression but found an arrow');\r\n            }\r\n            AST_open(astProp, 'ArrowFunctionExpression');\r\n            AST_set('params', []);\r\n            parseArrowFromPunc(lexerFlags, scoop, NOT_ASYNC, ARGS_SIMPLE);\r\n            AST_close('ArrowFunctionExpression');\r\n            if (isDeleteArg === IS_DELETE_ARG)\r\n                return NOT_SINGLE_IDENT_WRAP_NA;\r\n            return NOT_ASSIGNABLE;\r\n        }\r\n        let foundSingleIdentWrap = false;\r\n        let rootAstProp = astProp;\r\n        let destructible = MIGHT_DESTRUCT;\r\n        let toplevelComma = false;\r\n        let simpleArgs = ARGS_SIMPLE;\r\n        let backup_allowAssignment = allowAssignment;\r\n        allowAssignment = ALLOW_ASSIGNMENT;\r\n        while (curc !== $$PAREN_R_29) {\r\n            if (curtype === $IDENT) {\r\n                const identToken = curtok;\r\n                skipIdentSafeSlowAndExpensive(lexerFlags);\r\n                if (curtok.str === '=') {\r\n                    simpleArgs = ARGS_COMPLEX;\r\n                    let assignable = parseArrowableTopIdentAssign(lexerFlags, scoop, identToken, destructible, astProp);\r\n                    destructible |= resetDestructibility(assignable);\r\n                }\r\n                else if (curc === $$COMMA_2C || curc === $$PAREN_R_29) {\r\n                    if (!toplevelComma && isDeleteArg === IS_DELETE_ARG && curc === $$PAREN_R_29) {\r\n                        ASSERT(destructible === MIGHT_DESTRUCT, 'should not have parsed anything yet so destructible is still default');\r\n                        ASSERT(simpleArgs === ARGS_SIMPLE, 'should still be the default');\r\n                        foundSingleIdentWrap = true;\r\n                    }\r\n                    let assignable = parseValueHeadBodyAfterIdent(lexerFlags, identToken, BINDING_TYPE_NONE, ALLOW_ASSIGNMENT, astProp);\r\n                    if (notAssignable(assignable)) {\r\n                        destructible |= CANT_DESTRUCT;\r\n                    }\r\n                    else {\r\n                        simpleArgs = ARGS_COMPLEX;\r\n                        SCOPE_addBinding(lexerFlags, scoop, identToken.str, BINDING_TYPE_ARG, SKIP_DUPE_CHECKS, ORIGIN_NOT_VAR_DECL);\r\n                    }\r\n                    destructible |= assignable;\r\n                }\r\n                else {\r\n                    destructible |= CANT_DESTRUCT;\r\n                    destructible |= parseExpressionAfterIdent(lexerFlags, identToken, BINDING_TYPE_NONE, allowAssignment, astProp);\r\n                }\r\n            }\r\n            else if (curc === $$CURLY_L_7B) {\r\n                simpleArgs = ARGS_COMPLEX;\r\n                destructible |= parseObjectLiteralPatternAndAssign(lexerFlags, scoop, BINDING_TYPE_NONE, PARSE_INIT, NOT_CLASS_METHOD, UNDEF_EXPORTS, UNDEF_EXPORTS, astProp);\r\n                ASSERT(curtok.str !== '=', 'destruct assignments should be parsed at this point');\r\n                if (curc !== $$COMMA_2C && curc !== $$PAREN_R_29) {\r\n                    destructible |= CANT_DESTRUCT;\r\n                    destructible |= parseValueTail(lexerFlags, NOT_ASSIGNABLE, NOT_NEW_ARG, astProp);\r\n                    if (asyncStmtOrExpr === IS_STATEMENT) {\r\n                        destructible |= parseExpressionFromOp(lexerFlags, destructible, astProp);\r\n                    }\r\n                }\r\n                else {\r\n                    destructible = setNotAssignable(destructible);\r\n                }\r\n            }\r\n            else if (curc === $$SQUARE_L_5B) {\r\n                simpleArgs = ARGS_COMPLEX;\r\n                destructible |= parseArrayLiteralPattern(lexerFlags, scoop, BINDING_TYPE_NONE, PARSE_INIT, UNDEF_EXPORTS, UNDEF_EXPORTS, astProp);\r\n                ASSERT(curtok.str !== '=', 'destruct assignments should be parsed at this point');\r\n                if (curc !== $$COMMA_2C && curc !== $$PAREN_R_29) {\r\n                    destructible |= parseValueTail(lexerFlags, NOT_ASSIGNABLE, NOT_NEW_ARG, astProp);\r\n                    destructible |= CANT_DESTRUCT;\r\n                    if (asyncStmtOrExpr === IS_STATEMENT) {\r\n                        destructible |= parseExpressionFromOp(lexerFlags, destructible, astProp);\r\n                    }\r\n                }\r\n                else {\r\n                    destructible = setNotAssignable(destructible);\r\n                }\r\n            }\r\n            else if (curc === $$DOT_2E && curtok.str === '...') {\r\n                simpleArgs = ARGS_COMPLEX;\r\n                destructible |= parseArrowableTopRest(lexerFlags, scoop, asyncToken !== UNDEF_ASYNC, astProp);\r\n                if (asyncToken !== UNDEF_ASYNC) {\r\n                    if (curc !== $$PAREN_R_29) {\r\n                        destructible |= CANT_DESTRUCT;\r\n                    }\r\n                }\r\n                else {\r\n                    destructible |= MUST_DESTRUCT;\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                destructible |= CANT_DESTRUCT;\r\n                destructible |= parseExpression(lexerFlags, ALLOW_ASSIGNMENT, astProp);\r\n                if (curc === $$COMMA_2C) {\r\n                    if (!toplevelComma) {\r\n                        toplevelComma = true;\r\n                        AST_wrapClosedIntoArray(rootAstProp, 'SequenceExpression', 'expressions', false);\r\n                        astProp = 'expressions';\r\n                    }\r\n                    destructible |= __parseExpressions(lexerFlags, destructible, astProp);\r\n                }\r\n                if (toplevelComma) {\r\n                    AST_close('SequenceExpression');\r\n                    destructible = setNotAssignable(destructible);\r\n                }\r\n                skipDivOrDieSingleChar($$PAREN_R_29, lexerFlags);\r\n                if (asyncToken !== UNDEF_ASYNC) {\r\n                    return parseAfterAsyncGroup(lexerFlagsBeforeParen, scoop, asyncStmtOrExpr, allowAssignment, simpleArgs, toplevelComma, newlineAfterAsync, CANT_DESTRUCT, false, asyncToken, rootAstProp);\r\n                }\r\n                if (isDeleteArg === IS_DELETE_ARG) {\r\n                    let extraFlags = 0;\r\n                    if (hasAllFlags(destructible, DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_OR_YIELD_KEYWORD))\r\n                        extraFlags |= DELETE_PIGGY_AWAIT_OR_YIELD_KEYWORD;\r\n                    if (hasAllFlags(destructible, DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_VARNAME))\r\n                        extraFlags |= DELETE_PIGGY_AWAIT_VARNAME;\r\n                    if (hasAllFlags(destructible, DESTRUCTIBLE_PIGGY_BACK_SAW_YIELD_VARNAME))\r\n                        extraFlags |= DELETE_PIGGY_YIELD_VARNAME;\r\n                    return (isAssignable(destructible) ? NOT_SINGLE_IDENT_WRAP_A : NOT_SINGLE_IDENT_WRAP_NA) | extraFlags;\r\n                }\r\n                return destructible;\r\n            }\r\n            if (curc !== $$COMMA_2C)\r\n                break;\r\n            ASSERT_skipRex(',', lexerFlags);\r\n            if (curc === $$PAREN_R_29) {\r\n                if (allowTrailingFunctionComma) {\r\n                    destructible |= MUST_DESTRUCT;\r\n                    break;\r\n                }\r\n                else {\r\n                    THROW('Encountered trailing comma in the toplevel of a group, this could be valid in arrows but not with the currently targeted language version');\r\n                }\r\n            }\r\n            if (!toplevelComma) {\r\n                toplevelComma = true;\r\n                AST_wrapClosedIntoArray(rootAstProp, 'SequenceExpression', 'expressions', false);\r\n                astProp = 'expressions';\r\n            }\r\n        }\r\n        allowAssignment = backup_allowAssignment;\r\n        if (toplevelComma) {\r\n            destructible = setNotAssignable(destructible);\r\n            AST_close('SequenceExpression');\r\n        }\r\n        skipDivOrDieSingleChar($$PAREN_R_29, lexerFlags);\r\n        lexerFlags = lexerFlagsBeforeParen;\r\n        verifyDestructible(destructible);\r\n        if (asyncToken !== UNDEF_ASYNC) {\r\n            return parseAfterAsyncGroup(lexerFlags, scoop, asyncStmtOrExpr, allowAssignment, simpleArgs, toplevelComma, newlineAfterAsync, destructible, false, asyncToken, rootAstProp);\r\n        }\r\n        if (curtok.str === '=>') {\r\n            if (curtok.nl) {\r\n                THROW('Arrow is restricted production; cannot have newline before the arrow token');\r\n            }\r\n            if (allowAssignment === NO_ASSIGNMENT)\r\n                THROW('Was parsing a value that could not be AssignmentExpression but found an arrow');\r\n            if (hasAllFlags(destructible, CANT_DESTRUCT))\r\n                THROW('The left hand side of the arrow is not destructible so arrow is illegal');\r\n            if (hasAllFlags(destructible, DESTRUCT_ASSIGN_ONLY))\r\n                THROW('The left hand side of the arrow can only be destructed through assignment so arrow is illegal');\r\n            if (hasAllFlags(destructible, DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_OR_YIELD_KEYWORD))\r\n                THROW('The arguments of an arrow cannot contain an await or yield expression in their defaults');\r\n            if (hasAllFlags(destructible, DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_VARNAME) && (hasAllFlags(destructible, LF_IN_ASYNC) || goalMode === GOAL_MODULE))\r\n                THROW('The arguments of an arrow cannot be named `await` if inside an async function or parsing against the module goal');\r\n            if (hasAllFlags(destructible, DESTRUCTIBLE_PIGGY_BACK_SAW_YIELD_VARNAME) && hasAnyFlag(lexerFlags, LF_IN_GENERATOR | LF_STRICT_MODE)) {\r\n                THROW('The arguments of an arrow cannot be named `yield` if inside a generator or strict mode');\r\n            }\r\n            parseArrowAfterGroup(lexerFlags, scoop, simpleArgs, toplevelComma, asyncToken, rootAstProp);\r\n            if (isDeleteArg === IS_DELETE_ARG)\r\n                return NOT_SINGLE_IDENT_WRAP_NA;\r\n            return NOT_ASSIGNABLE;\r\n        }\r\n        else if (hasAllFlags(destructible, MUST_DESTRUCT)) {\r\n            THROW('The group had to be destructed but was not followed by an arrow (this is an invalid assignment target)');\r\n        }\r\n        else if (curtok.str === '=' || isCompoundAssignment(curtok.str)) {\r\n            if (allowAssignment === NO_ASSIGNMENT)\r\n                THROW('Was parsing a value that could not be AssignmentExpression but found an arrow');\r\n            if (toplevelComma)\r\n                THROW('Cannot assign to list of expressions in a group');\r\n            if (notAssignable(destructible))\r\n                THROW('Invalid assignment because group does not wrap a valid var name or just a property access');\r\n            AST_wrapClosed(rootAstProp, 'AssignmentExpression', 'left');\r\n            AST_set('operator', curtok.str);\r\n            ASSERT_skipRex($PUNCTUATOR, lexerFlags);\r\n            let nowAssignable = parseExpression(lexerFlags, ALLOW_ASSIGNMENT, 'right');\r\n            destructible |= resetDestructibility(nowAssignable);\r\n            AST_close('AssignmentExpression');\r\n            if (isDeleteArg === IS_DELETE_ARG) {\r\n                let extraFlags = 0;\r\n                if (hasAllFlags(destructible, DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_OR_YIELD_KEYWORD))\r\n                    extraFlags |= DELETE_PIGGY_AWAIT_OR_YIELD_KEYWORD;\r\n                if (hasAllFlags(destructible, DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_VARNAME))\r\n                    extraFlags |= DELETE_PIGGY_AWAIT_VARNAME;\r\n                if (hasAllFlags(destructible, DESTRUCTIBLE_PIGGY_BACK_SAW_YIELD_VARNAME))\r\n                    extraFlags |= DELETE_PIGGY_YIELD_VARNAME;\r\n                return NOT_SINGLE_IDENT_WRAP_NA | extraFlags;\r\n            }\r\n            return setNotAssignable(destructible);\r\n        }\r\n        if (isDeleteArg === IS_DELETE_ARG) {\r\n            let extraFlags = 0;\r\n            if (hasAllFlags(destructible, DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_OR_YIELD_KEYWORD))\r\n                extraFlags |= DELETE_PIGGY_AWAIT_OR_YIELD_KEYWORD;\r\n            if (hasAllFlags(destructible, DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_VARNAME))\r\n                extraFlags |= DELETE_PIGGY_AWAIT_VARNAME;\r\n            if (hasAllFlags(destructible, DESTRUCTIBLE_PIGGY_BACK_SAW_YIELD_VARNAME))\r\n                extraFlags |= DELETE_PIGGY_YIELD_VARNAME;\r\n            if (foundSingleIdentWrap) {\r\n                ASSERT(!toplevelComma, 'sanity check; the main loop should break after this state was found');\r\n                if (isAssignable(destructible))\r\n                    return IS_SINGLE_IDENT_WRAP_A | extraFlags;\r\n                return IS_SINGLE_IDENT_WRAP_NA | extraFlags;\r\n            }\r\n            else {\r\n                if (isAssignable(destructible))\r\n                    return NOT_SINGLE_IDENT_WRAP_A | extraFlags;\r\n                return NOT_SINGLE_IDENT_WRAP_NA | extraFlags;\r\n            }\r\n        }\r\n        return destructible;\r\n    }\r\n    function parseAfterAsyncGroup(lexerFlags, scoop, fromStmtOrExpr, allowAssignment, simpleArgs, toplevelComma, newlineAfterAsync, groupDestructible, zeroArgs, asyncToken, astProp) {\r\n        ASSERT(parseAfterAsyncGroup.length === arguments.length, 'arg count');\r\n        ASSERT(typeof groupDestructible === 'number', 'destructible num');\r\n        if (curtok.str === '=>') {\r\n            if (curtok.nl) {\r\n                THROW('The arrow is a restricted production an there can not be a newline before `=>` token');\r\n            }\r\n            else if (newlineAfterAsync === IS_ASYNC_PREFIXED) {\r\n                if (allowAsyncFunctions) {\r\n                    THROW('A newline after async is always a syntax error if the rhs turns to be an arrow function');\r\n                }\r\n                else {\r\n                    THROW('Encountered unexpected arrow; <=ES7 the `async \\\\n (x) => x` case was always parsed as `async(x); => x`');\r\n                }\r\n            }\r\n            else if (allowAssignment === NO_ASSIGNMENT) {\r\n                THROW('Was parsing a value that could not be AssignmentExpression but found an arrow');\r\n            }\r\n            else if (hasAnyFlag(groupDestructible, CANT_DESTRUCT | DESTRUCT_ASSIGN_ONLY)) {\r\n                if (curtok.str === '=>') {\r\n                    THROW('The group was not destructible and yet the next token is an arrow');\r\n                }\r\n            }\r\n            else if (zeroArgs) {\r\n                parseArrowAfterAsyncNoArgGroup(lexerFlags, scoop, simpleArgs, toplevelComma, asyncToken, astProp);\r\n            }\r\n            else if (hasAnyFlag(groupDestructible, DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_OR_YIELD_KEYWORD)) {\r\n                THROW('Async arrow arg defaults can not contain `yield` expressions');\r\n            }\r\n            else if (hasAnyFlag(groupDestructible, DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_VARNAME)) {\r\n                THROW('Async arrows can not have arg bindings named `await` because it is considered a keyword');\r\n            }\r\n            else if (hasAnyFlag(lexerFlags, LF_IN_GENERATOR | LF_STRICT_MODE) && hasAnyFlag(groupDestructible, DESTRUCTIBLE_PIGGY_BACK_SAW_YIELD_VARNAME)) {\r\n                THROW('This async arrow can not have arg bindings named `yield` because it is contained in a generator or strict mode');\r\n            }\r\n            else {\r\n                parseArrowAfterGroup(lexerFlags, scoop, simpleArgs, toplevelComma, asyncToken, astProp);\r\n            }\r\n        }\r\n        else {\r\n            if (zeroArgs) {\r\n                AST_open(astProp, 'CallExpression');\r\n                AST_setIdent('callee', asyncToken);\r\n                AST_set('arguments', []);\r\n                AST_close('CallExpression');\r\n            }\r\n            else {\r\n                let node = _path[_path.length - 1];\r\n                let args = node[astProp];\r\n                if (args instanceof Array)\r\n                    args = args[0];\r\n                ASSERT(args, 'should have parsed someting v1');\r\n                if (args.type === 'SequenceExpression')\r\n                    args = args.expressions;\r\n                else\r\n                    args = [args];\r\n                ASSERT(args, 'should have parsed someting v2');\r\n                if (node[astProp] instanceof Array)\r\n                    node[astProp] = [];\r\n                else\r\n                    node[astProp] = undefined;\r\n                AST_open(astProp, 'CallExpression', true);\r\n                AST_setIdent('callee', asyncToken);\r\n                AST_set('arguments', args);\r\n                AST_close('CallExpression');\r\n            }\r\n            let assignable = parseValueTail(lexerFlags, setNotAssignable(groupDestructible), NOT_NEW_ARG, astProp);\r\n            if (fromStmtOrExpr === IS_STATEMENT) {\r\n                assignable = parseExpressionFromOp(lexerFlags, assignable, astProp);\r\n                parseSemiOrAsi(lexerFlags);\r\n            }\r\n            return assignable;\r\n        }\r\n        if (fromStmtOrExpr === IS_STATEMENT) {\r\n            if (curc === $$COMMA_2C) {\r\n                _parseExpressions(lexerFlags, initNotAssignable(0), astProp);\r\n            }\r\n            parseSemiOrAsi(lexerFlags);\r\n        }\r\n        return NOT_ASSIGNABLE;\r\n    }\r\n    function parseArrowAfterAsyncNoArgGroup(lexerFlags, scoop, simpleArgs, toplevelComma, asyncToke, astProp) {\r\n        let a = simpleArgs;\r\n        let b = toplevelComma;\r\n        let c = asyncToke;\r\n        ASSERT(parseArrowAfterAsyncNoArgGroup.length === arguments.length, 'arg count');\r\n        AST_open(astProp, 'ArrowFunctionExpression');\r\n        AST_set('params', []);\r\n        parseArrowFromPunc(lexerFlags, scoop, WAS_ASYNC, ARG_WAS_SIMPLE);\r\n        AST_close('ArrowFunctionExpression');\r\n    }\r\n    function parseArrowAfterGroup(lexerFlags, scoop, simpleArgs, toplevelComma, asyncToken, astProp) {\r\n        AST_wrapClosedIntoArray(astProp, 'ArrowFunctionExpression', 'params', false);\r\n        let top = _path[_path.length - 1];\r\n        if (toplevelComma) {\r\n            ASSERT(top.params instanceof Array, 'these params should be an array');\r\n            let params = top.params[top.params.length - 1];\r\n            ASSERT(params.type === 'SequenceExpression', 'if toplevelComma then this is a sequence', astProp, params);\r\n            ASSERT(params.expressions instanceof Array, 'if toplevelComma then node is a sequence and .expressions should be an array');\r\n            top.params = params.expressions;\r\n        }\r\n        ASSERT(Array.isArray(top.params), 'params should now be an array in any case');\r\n        let params = top.params;\r\n        for (let i = 0; i < params.length; ++i) {\r\n            AST__destruct(params[i]);\r\n        }\r\n        if (SCOPE_verifyLexical(lexerFlags, scoop, true))\r\n            THROW('Arrow had at least one duplicate parameter name bound');\r\n        parseArrowFromPunc(lexerFlags, scoop, !!asyncToken, simpleArgs);\r\n        AST_close('ArrowFunctionExpression');\r\n    }\r\n    function parseArrowableTopIdentAssign(lexerFlags, scoop, identToken, assignable, astProp) {\r\n        ASSERT(parseArrowableTopIdentAssign.length === arguments.length, 'arg count');\r\n        bindingIdentCheck(identToken, BINDING_TYPE_NONE, lexerFlags);\r\n        SCOPE_addBinding(lexerFlags, scoop, identToken.str, BINDING_TYPE_ARG, SKIP_DUPE_CHECKS, ORIGIN_NOT_VAR_DECL);\r\n        AST_setIdent(astProp, identToken);\r\n        AST_wrapClosed(astProp, 'AssignmentExpression', 'left');\r\n        AST_set('operator', '=');\r\n        ASSERT_skipRex('=', lexerFlags);\r\n        let rhsAssignable = parseExpression(lexerFlags, ALLOW_ASSIGNMENT, 'right');\r\n        rhsAssignable = resetDestructibility(rhsAssignable);\r\n        AST_close('AssignmentExpression');\r\n        return setNotAssignable(mergeAssignable(assignable, rhsAssignable));\r\n    }\r\n    function parseArrowableTopRest(lexerFlags, scoop, asyncKeywordPrefixed, astProp) {\r\n        let subDestruct = parseArrowableSpreadOrRest(lexerFlags, scoop, $$PAREN_R_29, BINDING_TYPE_ARG, IS_GROUP_TOPLEVEL, asyncKeywordPrefixed, UNDEF_EXPORTS, UNDEF_EXPORTS, astProp);\r\n        if (!asyncKeywordPrefixed) {\r\n            if (hasAllFlags(subDestruct, CANT_DESTRUCT) || curc === $$COMMA_2C) {\r\n                THROW('The ... argument must be destructible in an arrow header, found something that was not destructible');\r\n            }\r\n            if (curc === $$IS_3D && curtok.str === '=')\r\n                THROW('Cannot set a default on a rest value');\r\n            if (curc === $$COMMA_2C)\r\n                THROW('Rest arg cannot have a trailing comma');\r\n            if (curc !== $$PAREN_R_29)\r\n                THROW('Rest arg must be last but did not find closing paren');\r\n        }\r\n        return subDestruct;\r\n    }\r\n    function parseArrayLiteralPattern(lexerFlagsBeforeParen, scoop, bindingType, skipInit, exportedNames, exportedBindings, _astProp) {\r\n        ASSERT(parseArrayLiteralPattern.length === arguments.length, 'arg count');\r\n        ASSERT(typeof bindingType === 'number', 'enum');\r\n        let lexerFlags = sansFlag(lexerFlagsBeforeParen, LF_IN_FOR_LHS);\r\n        AST_open(_astProp, 'ArrayExpression');\r\n        ASSERT_skipRex('[', lexerFlags);\r\n        AST_set('elements', []);\r\n        let astProp = 'elements';\r\n        let destructible = MIGHT_DESTRUCT;\r\n        while (curc === $$COMMA_2C) {\r\n            ASSERT_skipRex(',', lexerFlags);\r\n            AST_add(astProp, null);\r\n        }\r\n        let spreadStage = NO_SPREAD;\r\n        while (curc !== $$SQUARE_R_5D) {\r\n            if (curtype === $IDENT) {\r\n                const identToken = curtok;\r\n                skipIdentSafeSlowAndExpensive(lexerFlags);\r\n                if (curtok.str === '=') {\r\n                    let lhsAssignable = bindingAssignableIdentCheck(identToken, bindingType, lexerFlags);\r\n                    if (notAssignable(lhsAssignable))\r\n                        THROW('Cannot assign or destruct to keyword [' + identToken.str + ']');\r\n                    AST_setIdent(astProp, identToken);\r\n                    SCOPE_addBinding(lexerFlags, scoop, identToken.str, bindingType, SKIP_DUPE_CHECKS, ORIGIN_NOT_VAR_DECL);\r\n                    addNameToExports(exportedNames, identToken.str);\r\n                    addBindingToExports(exportedBindings, identToken.str);\r\n                    AST_wrapClosed(astProp, 'AssignmentExpression', 'left');\r\n                    AST_set('operator', '=');\r\n                    ASSERT_skipRex('=', lexerFlags);\r\n                    let rhsAssignable = parseExpression(lexerFlags, ALLOW_ASSIGNMENT, 'right');\r\n                    AST_close('AssignmentExpression');\r\n                    destructible |= mergeAssignable(lhsAssignable, resetDestructibility(rhsAssignable));\r\n                }\r\n                else if (curc === $$COMMA_2C || curc === $$SQUARE_R_5D) {\r\n                    let assignable = parseValueHeadBodyAfterIdent(lexerFlags, identToken, bindingType, ALLOW_ASSIGNMENT, astProp);\r\n                    destructible |= assignable;\r\n                    if (notAssignable(assignable)) {\r\n                        destructible |= CANT_DESTRUCT;\r\n                    }\r\n                    else {\r\n                        SCOPE_addBinding(lexerFlags, scoop, identToken.str, bindingType, SKIP_DUPE_CHECKS, ORIGIN_NOT_VAR_DECL);\r\n                        addNameToExports(exportedNames, identToken.str);\r\n                        addBindingToExports(exportedBindings, identToken.str);\r\n                    }\r\n                }\r\n                else {\r\n                    if (bindingType !== BINDING_TYPE_NONE) {\r\n                        destructible |= CANT_DESTRUCT;\r\n                    }\r\n                    destructible |= parseValueHeadBodyAfterIdent(lexerFlags, identToken, bindingType, ALLOW_ASSIGNMENT, astProp);\r\n                    destructible |= parseOptionalDestructibleRestOfExpression(lexerFlags, bindingType, destructible, destructible, $$SQUARE_R_5D, astProp);\r\n                }\r\n            }\r\n            else if (curc === $$CURLY_L_7B) {\r\n                let nowDestruct = parseObjectLiteralPatternAndAssign(lexerFlags, scoop, bindingType, PARSE_INIT, NOT_CLASS_METHOD, exportedNames, exportedBindings, astProp);\r\n                destructible |= nowDestruct;\r\n                destructible |= parseOptionalDestructibleRestOfExpression(lexerFlags, bindingType, hasAllFlags(nowDestruct, CANT_DESTRUCT) ? NOT_ASSIGNABLE : IS_ASSIGNABLE, nowDestruct, $$SQUARE_R_5D, astProp);\r\n            }\r\n            else if (curc === $$SQUARE_L_5B) {\r\n                let nowDestruct = parseArrayLiteralPattern(lexerFlags, scoop, bindingType, PARSE_INIT, exportedNames, exportedBindings, astProp);\r\n                destructible |= nowDestruct;\r\n                destructible |= parseOptionalDestructibleRestOfExpression(lexerFlags, bindingType, hasAllFlags(nowDestruct, CANT_DESTRUCT) ? NOT_ASSIGNABLE : IS_ASSIGNABLE, nowDestruct, $$SQUARE_R_5D, astProp);\r\n            }\r\n            else if (curc === $$DOT_2E && curtok.str === '...') {\r\n                let subDestruct = parseArrowableSpreadOrRest(lexerFlags, scoop, $$SQUARE_R_5D, bindingType, NOT_GROUP_TOPLEVEL, UNDEF_ASYNC, exportedNames, exportedBindings, astProp);\r\n                destructible |= subDestruct;\r\n                if (curc !== $$COMMA_2C && curc !== $$SQUARE_R_5D)\r\n                    THROW('Encountered unexpected token after parsing spread/rest argument ');\r\n                ASSERT(curc !== $$COMMA_2C || hasAllFlags(subDestruct, CANT_DESTRUCT), 'if comma then cannot destruct, should be dealt with in function');\r\n                if (spreadStage === NO_SPREAD)\r\n                    spreadStage = LAST_SPREAD;\r\n            }\r\n            else {\r\n                destructible |= parseValue(lexerFlags, ALLOW_ASSIGNMENT, NOT_NEW_ARG, astProp);\r\n                destructible |= parseOptionalDestructibleRestOfExpression(lexerFlags, bindingType, destructible, destructible, $$SQUARE_R_5D, astProp);\r\n            }\r\n            if (curc !== $$COMMA_2C)\r\n                break;\r\n            ASSERT_skipRex(',', lexerFlags);\r\n            if (spreadStage === LAST_SPREAD) {\r\n                spreadStage = MID_SPREAD;\r\n                destructible |= CANT_DESTRUCT;\r\n            }\r\n            while (curc === $$COMMA_2C) {\r\n                ASSERT_skipRex(',', lexerFlags);\r\n                AST_add(astProp, null);\r\n            }\r\n        }\r\n        lexerFlags = lexerFlagsBeforeParen;\r\n        skipDivOrDieSingleChar($$SQUARE_R_5D, lexerFlags);\r\n        AST_close('ArrayExpression');\r\n        if (skipInit === PARSE_INIT && curc === $$IS_3D && curtok.str === '=') {\r\n            verifyDestructible(destructible);\r\n            if (hasAllFlags(destructible, CANT_DESTRUCT))\r\n                THROW('Tried to destructure something that is not destructible');\r\n            destructible = sansFlag(destructible, MUST_DESTRUCT | DESTRUCTIBLE_PIGGY_BACK_WAS_PROTO);\r\n            AST_destruct(_astProp);\r\n            AST_wrapClosed(_astProp, 'AssignmentExpression', 'left');\r\n            AST_set('operator', '=');\r\n            ASSERT_skipRex('=', lexerFlags);\r\n            let nowAssignable = parseExpression(lexerFlags, ALLOW_ASSIGNMENT, 'right');\r\n            destructible |= resetDestructibility(nowAssignable);\r\n            AST_close('AssignmentExpression');\r\n        }\r\n        return destructible;\r\n    }\r\n    function parseObjectLiteralPatternAndAssign(lexerFlags, scoop, bindingType, skipInit, isClassMethod, exportedNames, exportedBindings, _astProp) {\r\n        ASSERT(parseObjectLiteralPatternAndAssign.length === arguments.length, 'expecting all args');\r\n        AST_open(_astProp, 'ObjectExpression');\r\n        AST_set('properties', []);\r\n        let destructible = parseObjectLikePatternSansAssign(lexerFlags | LF_NO_ASI, scoop, bindingType, isClassMethod, IS_EXPRESSION, exportedNames, exportedBindings, 'properties');\r\n        AST_close('ObjectExpression');\r\n        if (skipInit === PARSE_INIT && curc === $$IS_3D && curtok.str === '=') {\r\n            verifyDestructible(destructible | MUST_DESTRUCT);\r\n            destructible = sansFlag(destructible, MUST_DESTRUCT | DESTRUCTIBLE_PIGGY_BACK_WAS_PROTO);\r\n            AST_destruct(_astProp);\r\n            AST_wrapClosed(_astProp, 'AssignmentExpression', 'left');\r\n            AST_set('operator', '=');\r\n            ASSERT_skipRex('=', lexerFlags);\r\n            let assignable = parseExpression(lexerFlags, ALLOW_ASSIGNMENT, 'right');\r\n            destructible |= resetDestructibility(assignable);\r\n            AST_close('AssignmentExpression');\r\n        }\r\n        return destructible;\r\n    }\r\n    function parseClassbody(lexerFlags, scoop, bindingType, isExpression, astProp) {\r\n        ASSERT(parseClassbody.length === arguments.length, 'expecting all args');\r\n        AST_open(astProp, 'ClassBody');\r\n        AST_set('body', []);\r\n        let destructible = parseObjectLikePatternSansAssign(lexerFlags, scoop, bindingType, IS_CLASS_METHOD, isExpression, UNDEF_EXPORTS, UNDEF_EXPORTS, 'body');\r\n        AST_close('ClassBody');\r\n        return destructible;\r\n    }\r\n    function parseObjectLikePatternSansAssign(_lexerFlags, scoop, bindingType, isClassMethod, isExpression, exportedNames, exportedBindings, astProp) {\r\n        ASSERT(parseObjectLikePatternSansAssign.length === arguments.length, 'arg count');\r\n        let lexerFlags = _lexerFlags;\r\n        if (hasAllFlags(lexerFlags, LF_IN_FOR_LHS))\r\n            lexerFlags = lexerFlags ^ LF_IN_FOR_LHS;\r\n        if (hasAllFlags(lexerFlags, LF_IN_TEMPLATE))\r\n            lexerFlags = lexerFlags ^ LF_IN_TEMPLATE;\r\n        ASSERT_skipAny('{', lexerFlags);\r\n        let destructible = MIGHT_DESTRUCT;\r\n        if (isClassMethod === IS_CLASS_METHOD) {\r\n            while (curc === $$SEMI_3B)\r\n                ASSERT_skipAny(';', lexerFlags);\r\n        }\r\n        let constructors = 0;\r\n        let doubleDunderProto = 0;\r\n        while (curc !== $$CURLY_R_7D) {\r\n            if (curc === $$COMMA_2C) {\r\n                THROW('Objects cant have comma without something preceding it');\r\n            }\r\n            let currentDestruct = parseObjectLikePart(lexerFlags, scoop, bindingType, isClassMethod, undefined, exportedNames, exportedBindings, astProp);\r\n            if (hasAnyFlag(currentDestruct, DESTRUCTIBLE_PIGGY_BACK_WAS_PROTO)) {\r\n                ++doubleDunderProto;\r\n            }\r\n            destructible |= currentDestruct;\r\n            if (isClassMethod === IS_CLASS_METHOD) {\r\n                if (hasAnyFlag(currentDestruct, DESTRUCTIBLE_PIGGY_BACK_WAS_CONSTRUCTOR)) {\r\n                    ++constructors;\r\n                }\r\n                while (curc === $$SEMI_3B)\r\n                    ASSERT_skipAny(';', lexerFlags);\r\n            }\r\n            else {\r\n                if (curc !== $$COMMA_2C)\r\n                    break;\r\n                ASSERT_skipAny(',', lexerFlags);\r\n            }\r\n        }\r\n        if (constructors > 1) {\r\n            THROW('Classes may only have one constructor');\r\n        }\r\n        else if (constructors > 0) {\r\n            destructible = sansFlag(destructible, DESTRUCTIBLE_PIGGY_BACK_WAS_CONSTRUCTOR);\r\n        }\r\n        lexerFlags = _lexerFlags;\r\n        if (isExpression === IS_EXPRESSION) {\r\n            skipDivOrDieSingleChar($$CURLY_R_7D, lexerFlags);\r\n        }\r\n        else {\r\n            skipRexOrDieSingleChar($$CURLY_R_7D, lexerFlags);\r\n        }\r\n        if (doubleDunderProto === 1)\r\n            return sansFlag(destructible, DESTRUCTIBLE_PIGGY_BACK_WAS_PROTO);\r\n        ASSERT(hasAnyFlag(destructible, DESTRUCTIBLE_PIGGY_BACK_WAS_PROTO) === doubleDunderProto > 1, 'either dunder was not found and the piggy is not there or proto was found multiple times and the piggy is still in the destructible field');\r\n        return destructible;\r\n    }\r\n    function parseObjectLikePart(lexerFlags, scoop, bindingType, isClassMethod, staticToken, exportedNames, exportedBindings, astProp) {\r\n        ASSERT(parseObjectLikePart.length === arguments.length, 'arg count');\r\n        ASSERT(typeof astProp === 'string', 'astprop string');\r\n        ASSERT(staticToken === undefined || staticToken.str === 'static', 'token or undefined');\r\n        let destructible = MIGHT_DESTRUCT;\r\n        if (curtype === $IDENT) {\r\n            if (curtok.str === 'static' && staticToken === undefined) {\r\n                let currentStaticToken = curtok;\r\n                ASSERT_skipAny('static', lexerFlags);\r\n                if (curc === $$COMMA_2C || curc === $$CURLY_R_7D || curc === $$COLON_3A || curc === $$PAREN_L_28) {\r\n                    destructible = parseObjectLikePartFromIdent(lexerFlags, scoop, bindingType, isClassMethod, NOT_CONSTRUCTOR, undefined, currentStaticToken, exportedNames, exportedBindings, astProp);\r\n                }\r\n                else {\r\n                    destructible = parseObjectLikePart(lexerFlags, scoop, bindingType, isClassMethod, currentStaticToken, exportedNames, exportedBindings, astProp);\r\n                }\r\n            }\r\n            else {\r\n                let identToken = curtok;\r\n                ASSERT_skipAny($IDENT, lexerFlags);\r\n                if (allowAsyncFunctions) {\r\n                    if (curc !== $$PAREN_L_28 && curtok.nl && identToken.str === 'async') {\r\n                        THROW('Async methods are a restricted production and cannot have a newline following it');\r\n                    }\r\n                }\r\n                let wasConstructor = isClassMethod === IS_CLASS_METHOD && staticToken === undefined && curc === $$PAREN_L_28 && identToken.canon === 'constructor';\r\n                ASSERT(typeof wasConstructor === 'boolean', 'enum');\r\n                destructible = parseObjectLikePartFromIdent(lexerFlags, scoop, bindingType, isClassMethod, wasConstructor, staticToken, identToken, exportedNames, exportedBindings, astProp);\r\n                if (wasConstructor) {\r\n                    destructible |= DESTRUCTIBLE_PIGGY_BACK_WAS_CONSTRUCTOR;\r\n                }\r\n            }\r\n        }\r\n        else if (hasAllFlags(curtype, $NUMBER) || hasAllFlags(curtype, $STRING)) {\r\n            let litToken = curtok;\r\n            ASSERT_skipRex(litToken.str, lexerFlags);\r\n            if (curc === $$COLON_3A) {\r\n                if (litToken.str.slice(1, -1) === '__proto__')\r\n                    destructible |= DESTRUCTIBLE_PIGGY_BACK_WAS_PROTO;\r\n                ASSERT_skipRex(':', lexerFlags);\r\n                if (curtype === $IDENT) {\r\n                    let nameBinding = curtok;\r\n                    destructible |= bindingAssignableIdentCheck(nameBinding, bindingType, lexerFlags);\r\n                    if (notAssignable(destructible)) {\r\n                        destructible |= CANT_DESTRUCT;\r\n                    }\r\n                    else {\r\n                        SCOPE_addBinding(lexerFlags, scoop, nameBinding.str, bindingType, SKIP_DUPE_CHECKS, ORIGIN_NOT_VAR_DECL);\r\n                        addNameToExports(exportedNames, nameBinding.str);\r\n                        addBindingToExports(exportedBindings, nameBinding.str);\r\n                    }\r\n                    skipIdentSafeSlowAndExpensive(lexerFlags);\r\n                    if (curc !== $$COMMA_2C && curc !== $$CURLY_R_7D && curtok.str !== '=') {\r\n                        destructible |= CANT_DESTRUCT;\r\n                    }\r\n                    AST_open(astProp, 'Property');\r\n                    AST_setLiteral('key', litToken);\r\n                    AST_set('kind', 'init');\r\n                    AST_set('method', false);\r\n                    AST_set('computed', false);\r\n                    destructible |= parseExpressionAfterIdent(lexerFlags, nameBinding, bindingType, ALLOW_ASSIGNMENT, 'value');\r\n                    AST_set('shorthand', false);\r\n                    AST_close('Property');\r\n                }\r\n                else if (curc === $$SQUARE_L_5B) {\r\n                    AST_open(astProp, 'Property');\r\n                    AST_setLiteral('key', litToken);\r\n                    AST_set('kind', 'init');\r\n                    AST_set('method', false);\r\n                    AST_set('computed', false);\r\n                    let identAssignable = parseArrayLiteralPattern(lexerFlags, scoop, bindingType, PARSE_INIT, exportedNames, exportedBindings, 'value');\r\n                    if (curc !== $$COMMA_2C && curc !== $$CURLY_R_7D && curtok.str !== '=') {\r\n                        destructible |= parseExpressionAfterLiteral(lexerFlags, 'value');\r\n                        if (isAssignable(destructible)) {\r\n                            destructible |= DESTRUCT_ASSIGN_ONLY;\r\n                        }\r\n                        else {\r\n                            destructible |= CANT_DESTRUCT;\r\n                        }\r\n                    }\r\n                    destructible |= identAssignable;\r\n                    AST_set('shorthand', false);\r\n                    AST_close('Property');\r\n                }\r\n                else if (curc === $$CURLY_L_7B) {\r\n                    AST_open(astProp, 'Property');\r\n                    AST_setLiteral('key', litToken);\r\n                    AST_set('kind', 'init');\r\n                    AST_set('method', false);\r\n                    AST_set('computed', false);\r\n                    let objAssignable = parseObjectLiteralPatternAndAssign(lexerFlags, scoop, bindingType, PARSE_INIT, NOT_CLASS_METHOD, exportedNames, exportedBindings, 'value');\r\n                    if (curc !== $$COMMA_2C && curc !== $$CURLY_R_7D && curtok.str !== '=') {\r\n                        destructible |= parseExpressionAfterLiteral(lexerFlags, 'value');\r\n                        if (isAssignable(destructible)) {\r\n                            destructible |= DESTRUCT_ASSIGN_ONLY;\r\n                        }\r\n                        else {\r\n                            destructible |= CANT_DESTRUCT;\r\n                        }\r\n                    }\r\n                    destructible |= objAssignable;\r\n                    AST_set('shorthand', false);\r\n                    AST_close('Property');\r\n                }\r\n                else {\r\n                    AST_open(astProp, 'Property');\r\n                    AST_setLiteral('key', litToken);\r\n                    AST_set('kind', 'init');\r\n                    AST_set('method', false);\r\n                    AST_set('computed', false);\r\n                    destructible |= parseExpression(lexerFlags, ALLOW_ASSIGNMENT, 'value');\r\n                    if (isAssignable(destructible)) {\r\n                        destructible |= DESTRUCT_ASSIGN_ONLY;\r\n                    }\r\n                    else {\r\n                        destructible |= CANT_DESTRUCT;\r\n                    }\r\n                    AST_set('shorthand', false);\r\n                    AST_close('Property');\r\n                }\r\n            }\r\n            else if (curc === $$PAREN_L_28) {\r\n                AST_setLiteral(astProp, litToken);\r\n                let wasConstructor = isClassMethod === IS_CLASS_METHOD &&\r\n                    staticToken === undefined &&\r\n                    hasAllFlags(litToken.type, $STRING) &&\r\n                    litToken.str.slice(1, -1) === 'constructor';\r\n                ASSERT(typeof wasConstructor === 'boolean', 'enum');\r\n                let nowDestructible = parseObjectLikeMethodAfterKey(lexerFlags, staticToken, undefined, undefined, litToken, isClassMethod, wasConstructor, NOT_DyNAMIC_PROPERTY, NOT_GETSET, astProp);\r\n                destructible = nowDestructible | CANT_DESTRUCT;\r\n                if (wasConstructor) {\r\n                    destructible |= DESTRUCTIBLE_PIGGY_BACK_WAS_CONSTRUCTOR;\r\n                }\r\n            }\r\n            else {\r\n                THROW('Object literal keys that are strings or numbers must be a method or have a colon: ' + curtok);\r\n            }\r\n            ASSERT(curc !== $$IS_3D, 'assignments should be parsed as part of the expression');\r\n        }\r\n        else if (curtok.str === '...') {\r\n            if (targetEsVersion < VERSION_OBJECTSPREAD && targetEsVersion !== VERSION_WHATEVER) {\r\n                THROW('Object spread/rest requires the requested version to be ES9+');\r\n            }\r\n            let subDestruct = parseArrowableSpreadOrRest(lexerFlags, scoop, $$CURLY_R_7D, bindingType, NOT_GROUP_TOPLEVEL, undefined, exportedNames, exportedBindings, astProp);\r\n            ASSERT(typeof subDestruct === 'number', 'should be number');\r\n            destructible |= subDestruct;\r\n            ASSERT(curc !== $$COMMA_2C || hasAllFlags(subDestruct, CANT_DESTRUCT), 'if comma then cannot destruct, should be dealt with in function');\r\n            ASSERT(curc === $$COMMA_2C || curc === $$CURLY_R_7D, 'abstraction should parse whole rest/spread goal; ' + curtok);\r\n        }\r\n        else if (curc === $$SQUARE_L_5B) {\r\n            ASSERT_skipRex('[', lexerFlags);\r\n            let computedKeyAssignable = parseExpression(lexerFlags, ALLOW_ASSIGNMENT, astProp);\r\n            skipAnyOrDieSingleChar($$SQUARE_R_5D, lexerFlags);\r\n            if (curc === $$COLON_3A) {\r\n                ASSERT_skipRex(':', lexerFlags);\r\n                if (isClassMethod === IS_CLASS_METHOD)\r\n                    THROW('fail');\r\n                AST_wrapClosed(astProp, 'Property', 'key');\r\n                AST_set('kind', 'init');\r\n                AST_set('method', curc === $$PAREN_L_28);\r\n                AST_set('computed', true);\r\n                let lhsAssignable = parseValue(lexerFlags, ALLOW_ASSIGNMENT, NOT_NEW_ARG, 'value');\r\n                if (notAssignable(lhsAssignable) || (curc !== $$COMMA_2C && curc !== $$CURLY_R_7D && curtok.str !== '=')) {\r\n                    destructible |= CANT_DESTRUCT;\r\n                }\r\n                let rhsAssignable = parseExpressionFromOp(lexerFlags, lhsAssignable, 'value');\r\n                destructible |= lhsAssignable | rhsAssignable;\r\n                AST_set('shorthand', false);\r\n                AST_close('Property');\r\n            }\r\n            else {\r\n                if (curc !== $$PAREN_L_28)\r\n                    THROW('A computed property name must be followed by a colon or paren');\r\n                destructible |= parseObjectLikeMethodAfterKey(lexerFlags, staticToken, UNDEF_ASYNC, UNDEF_ASYNC, undefined, isClassMethod, NOT_CONSTRUCTOR, IS_DyNAMIC_PROPERTY, NOT_GETSET, astProp);\r\n                destructible |= CANT_DESTRUCT;\r\n            }\r\n            destructible |= computedKeyAssignable;\r\n        }\r\n        else if (curc === $$STAR_2A) {\r\n            destructible |= CANT_DESTRUCT;\r\n            let starToken = curtok;\r\n            ASSERT_skipAny('*', lexerFlags);\r\n            if (curtype === $IDENT) {\r\n                let identToken = curtok;\r\n                ASSERT_skipAny($IDENT, lexerFlags);\r\n                if (curc === $$PAREN_L_28) {\r\n                    if (identToken.str === 'prototype')\r\n                        THROW('Class methods can not be called `prototype`');\r\n                    AST_setIdent(astProp, identToken);\r\n                    parseObjectLikeMethodAfterKey(lexerFlags, staticToken, starToken, undefined, identToken, isClassMethod, NOT_CONSTRUCTOR, NOT_DyNAMIC_PROPERTY, NOT_GETSET, astProp);\r\n                }\r\n                else {\r\n                    if (allowAsyncFunctions) {\r\n                        if (curtok.str === 'async') {\r\n                            THROW('Found `* async x(){}` but this should be `async * x(){}`');\r\n                        }\r\n                    }\r\n                    if (curtok.str === 'get' || curtok.str === 'set') {\r\n                        THROW('Getters and setters can not be generators');\r\n                    }\r\n                    if (curc === $$COLON_3A) {\r\n                        THROW('Generators must be method shorthands');\r\n                    }\r\n                    THROW('Unexpected token can not be generator method');\r\n                }\r\n            }\r\n            else if (hasAnyFlag(curtype, $NUMBER | $STRING)) {\r\n                let litToken = curtok;\r\n                ASSERT_skipAny(litToken.str, lexerFlags);\r\n                destructible |= CANT_DESTRUCT;\r\n                AST_setLiteral(astProp, litToken);\r\n                parseObjectLikeMethodAfterKey(lexerFlags, staticToken, starToken, undefined, litToken, isClassMethod, NOT_CONSTRUCTOR, NOT_DyNAMIC_PROPERTY, NOT_GETSET, astProp);\r\n            }\r\n            else if (curc === $$SQUARE_L_5B) {\r\n                destructible |= CANT_DESTRUCT;\r\n                destructible |= parseComputedModifierMethod(lexerFlags, isClassMethod, staticToken, starToken, undefined, astProp);\r\n            }\r\n            else {\r\n                THROW('Invalid objlit key character after generator star');\r\n            }\r\n            ASSERT(curc !== $$IS_3D, 'this struct can not have an init');\r\n        }\r\n        else if (curc === $$SEMI_3B) {\r\n            if (isClassMethod === NOT_CLASS_METHOD) {\r\n                THROW('Semi is not a valid character in object literals');\r\n            }\r\n            ASSERT_skipAny(';', lexerFlags);\r\n        }\r\n        else {\r\n            THROW('Unexpected token, wanted to parse a start of a property in an object literal/pattern');\r\n        }\r\n        return destructible;\r\n    }\r\n    function parseObjectLikePartFromIdent(lexerFlags, scoop, bindingType, isClassMethod, isConstructor, isStatic, identToken, exportedNames, exportedBindings, astProp) {\r\n        ASSERT(parseObjectLikePartFromIdent.length === arguments.length, 'arg count');\r\n        ASSERT(identToken.type === $IDENT, 'should get ident token: ' + identToken);\r\n        ASSERT(typeof astProp === 'string', 'astprop string');\r\n        ASSERT(isStatic === undefined || isStatic.str === 'static', 'keyword or undefined');\r\n        ASSERT(typeof isConstructor === 'boolean', 'enum');\r\n        let destructible = MIGHT_DESTRUCT;\r\n        if (curc === $$COMMA_2C || curc === $$CURLY_R_7D || curtok.str === '=') {\r\n            if (isClassMethod) {\r\n                if (curc === $$COMMA_2C)\r\n                    THROW('Classes do not use commas');\r\n                THROW('Class members have to be methods, for now');\r\n            }\r\n            if (identToken.str === 'eval' || identToken.str === 'arguments') {\r\n                if (hasAnyFlag(lexerFlags, LF_STRICT_MODE)) {\r\n                    destructible |= CANT_DESTRUCT;\r\n                }\r\n            }\r\n            else {\r\n                bindingIdentCheck(identToken, bindingType, lexerFlags);\r\n            }\r\n            SCOPE_addBinding(lexerFlags, scoop, identToken.str, bindingType, SKIP_DUPE_CHECKS, ORIGIN_NOT_VAR_DECL);\r\n            addNameToExports(exportedNames, identToken.str);\r\n            addBindingToExports(exportedBindings, identToken.str);\r\n            AST_open(astProp, 'Property');\r\n            AST_setIdent('key', identToken);\r\n            AST_set('kind', 'init');\r\n            AST_set('method', false);\r\n            AST_set('computed', false);\r\n            AST_setIdent('value', identToken);\r\n            if (curc === $$IS_3D && curtok.str === '=') {\r\n                destructible |= MUST_DESTRUCT;\r\n                AST_wrapClosed('value', 'AssignmentExpression', 'left');\r\n                AST_set('operator', '=');\r\n                ASSERT_skipRex('=', lexerFlags);\r\n                let rhsAssignable = parseExpression(lexerFlags, ALLOW_ASSIGNMENT, 'right');\r\n                destructible |= resetDestructibility(rhsAssignable);\r\n                AST_close('AssignmentExpression');\r\n            }\r\n            AST_set('shorthand', true);\r\n            AST_close('Property');\r\n            ASSERT(curc !== $$IS_3D, 'further assignments should be parsed as part of the rhs expression');\r\n        }\r\n        else if (curc === $$COLON_3A) {\r\n            if (isClassMethod)\r\n                THROW('Class members have to be methods, for now');\r\n            ASSERT_skipRex(':', lexerFlags);\r\n            if (identToken.str === '__proto__')\r\n                destructible |= DESTRUCTIBLE_PIGGY_BACK_WAS_PROTO;\r\n            if (curtype === $IDENT) {\r\n                AST_open(astProp, 'Property');\r\n                AST_setIdent('key', identToken);\r\n                AST_set('kind', 'init');\r\n                AST_set('method', false);\r\n                AST_set('computed', false);\r\n                identToken = curtok;\r\n                skipIdentSafeSlowAndExpensive(lexerFlags);\r\n                let wasAssign = curtok.str === '=';\r\n                let willBeSimple = curc === $$CURLY_R_7D || curc === $$COMMA_2C || wasAssign;\r\n                let nowAssignable = parseValueAfterIdent(lexerFlags, identToken, bindingType, ALLOW_ASSIGNMENT, 'value');\r\n                destructible |= resetDestructibility(nowAssignable);\r\n                if (curc !== $$COMMA_2C && curc !== $$CURLY_R_7D) {\r\n                    destructible |= parseExpressionFromOp(lexerFlags, destructible, 'value');\r\n                    if (!wasAssign)\r\n                        destructible |= CANT_DESTRUCT;\r\n                }\r\n                else if (notAssignable(destructible)) {\r\n                    if (wasAssign)\r\n                        THROW('Tried to assign to a value that was not assignable in obj lit/patt');\r\n                    destructible |= CANT_DESTRUCT;\r\n                }\r\n                else if (willBeSimple) {\r\n                    SCOPE_addBinding(lexerFlags, scoop, identToken.str, bindingType, SKIP_DUPE_CHECKS, ORIGIN_NOT_VAR_DECL);\r\n                    addNameToExports(exportedNames, identToken.str);\r\n                    addBindingToExports(exportedBindings, identToken.str);\r\n                }\r\n                AST_set('shorthand', false);\r\n                AST_close('Property');\r\n            }\r\n            else if (curc === $$SQUARE_L_5B) {\r\n                AST_open(astProp, 'Property');\r\n                AST_setIdent('key', identToken);\r\n                AST_set('kind', 'init');\r\n                AST_set('method', false);\r\n                AST_set('computed', false);\r\n                let nowDestruct = parseArrayLiteralPattern(lexerFlags, scoop, bindingType, PARSE_INIT, exportedNames, exportedBindings, 'value');\r\n                destructible |= nowDestruct;\r\n                destructible |= parseOptionalDestructibleRestOfExpression(lexerFlags, bindingType, hasAllFlags(nowDestruct, CANT_DESTRUCT) ? NOT_ASSIGNABLE : IS_ASSIGNABLE, nowDestruct, $$CURLY_R_7D, 'value');\r\n                AST_set('shorthand', false);\r\n                AST_close('Property');\r\n            }\r\n            else if (curc === $$CURLY_L_7B) {\r\n                AST_open(astProp, 'Property');\r\n                AST_setIdent('key', identToken);\r\n                AST_set('kind', 'init');\r\n                AST_set('method', false);\r\n                AST_set('computed', false);\r\n                let nowDestruct = parseObjectLiteralPatternAndAssign(lexerFlags, scoop, bindingType, PARSE_INIT, NOT_CLASS_METHOD, exportedNames, exportedBindings, 'value');\r\n                destructible |= nowDestruct;\r\n                destructible |= parseOptionalDestructibleRestOfExpression(lexerFlags, bindingType, hasAllFlags(nowDestruct, CANT_DESTRUCT) ? NOT_ASSIGNABLE : IS_ASSIGNABLE, nowDestruct, $$CURLY_R_7D, 'value');\r\n                AST_set('shorthand', false);\r\n                AST_close('Property');\r\n            }\r\n            else {\r\n                AST_open(astProp, 'Property');\r\n                AST_setIdent('key', identToken);\r\n                AST_set('kind', 'init');\r\n                AST_set('method', false);\r\n                AST_set('computed', false);\r\n                destructible |= parseExpression(lexerFlags, ALLOW_ASSIGNMENT, 'value');\r\n                if (isAssignable(destructible)) {\r\n                    destructible |= DESTRUCT_ASSIGN_ONLY;\r\n                }\r\n                else {\r\n                    destructible |= CANT_DESTRUCT;\r\n                }\r\n                AST_set('shorthand', false);\r\n                AST_close('Property');\r\n            }\r\n            ASSERT(curc !== $$IS_3D, 'assignments should be parsed as part of the rhs expression');\r\n        }\r\n        else if (curc === $$SQUARE_L_5B) {\r\n            destructible |= CANT_DESTRUCT;\r\n            destructible |= parseComputedModifierMethod(lexerFlags, isClassMethod, isStatic, undefined, identToken, astProp);\r\n        }\r\n        else if (curc === $$PAREN_L_28) {\r\n            destructible |= CANT_DESTRUCT;\r\n            AST_setIdent(astProp, identToken);\r\n            if (identToken.str === 'prototype')\r\n                THROW('Class methods can not be called `prototype`');\r\n            ASSERT(!!(identToken.canon === 'constructor' && !isStatic && isClassMethod) == isConstructor, 'if the ident is constructor then isconstructor should be set');\r\n            parseObjectLikeMethodAfterKey(lexerFlags, isStatic, undefined, undefined, identToken, isClassMethod, isConstructor, NOT_DyNAMIC_PROPERTY, NOT_GETSET, astProp);\r\n            ASSERT(curc !== $$IS_3D, 'this struct does not allow init/defaults');\r\n        }\r\n        else if (curtype === $IDENT) {\r\n            destructible |= CANT_DESTRUCT;\r\n            let kind = NOT_GETSET;\r\n            if (identToken.str === 'get') {\r\n                kind = IS_GETTER;\r\n            }\r\n            else if (identToken.str === 'set') {\r\n                kind = IS_SETTER;\r\n            }\r\n            else if (!allowAsyncFunctions || identToken.str !== 'async') {\r\n                if (!isClassMethod || identToken.str !== 'static') {\r\n                    THROW('Did not expect another identifier while parsing an object literal property');\r\n                }\r\n            }\r\n            let identToken2 = curtok;\r\n            if (identToken2.str === 'prototype')\r\n                THROW('Class methods can not be called `prototype`');\r\n            ASSERT_skipAny($IDENT, lexerFlags);\r\n            if (curc !== $$PAREN_L_28)\r\n                THROW('Must have left paren now, got: ' + curtok);\r\n            AST_setIdent(astProp, identToken2);\r\n            parseObjectLikeMethodAfterKey(lexerFlags, isStatic, undefined, identToken, identToken2, isClassMethod, NOT_CONSTRUCTOR, NOT_DyNAMIC_PROPERTY, kind, astProp);\r\n            ASSERT(curc !== $$IS_3D, 'this struct does not allow init/defaults');\r\n        }\r\n        else if (curc === $$STAR_2A) {\r\n            destructible |= CANT_DESTRUCT;\r\n            let starToken = curtok;\r\n            ASSERT_skipAny('*', lexerFlags);\r\n            if (identToken.str === 'get')\r\n                THROW('A getter cannot be a generator');\r\n            if (identToken.str === 'set')\r\n                THROW('A setter cannot be a generator');\r\n            ASSERT(identToken.str !== 'static', 'this case is caught elsewhere');\r\n            if (identToken.str !== 'async')\r\n                THROW('the only method modifier allowed to have a generator is `async` (since es9)');\r\n            if (!allowAsyncFunctions)\r\n                THROW('Async functions are not supported by the current targeted language version');\r\n            if (!allowAsyncGenerators)\r\n                THROW('Async generators are not supported by the current targeted language version');\r\n            if (curtype === $IDENT) {\r\n                if (curtok.str === 'prototype')\r\n                    THROW('Class async generator methods can not be called `prototype`');\r\n                let nameToken = curtok;\r\n                AST_setIdent(astProp, curtok);\r\n                ASSERT_skipAny($IDENT, lexerFlags);\r\n                parseObjectLikeMethodAfterKey(lexerFlags, isStatic, starToken, identToken, nameToken, isClassMethod, NOT_CONSTRUCTOR, NOT_DyNAMIC_PROPERTY, NOT_GETSET, astProp);\r\n            }\r\n            else if ((curtype & $STRING) === $STRING || (curtype & $NUMBER) === $NUMBER) {\r\n                let litToken = curtok;\r\n                AST_setLiteral(astProp, litToken);\r\n                ASSERT_skipAny(litToken.str, lexerFlags);\r\n                parseObjectLikeMethodAfterKey(lexerFlags, isStatic, starToken, identToken, litToken, isClassMethod, NOT_CONSTRUCTOR, NOT_DyNAMIC_PROPERTY, NOT_GETSET, astProp);\r\n            }\r\n            else if (curc === $$SQUARE_L_5B) {\r\n                destructible |= parseComputedModifierMethod(lexerFlags, isClassMethod, isStatic, starToken, identToken, astProp);\r\n            }\r\n            else {\r\n                THROW('Invalid key token');\r\n            }\r\n            ASSERT(curc !== $$IS_3D, 'this struct does not allow init/defaults');\r\n        }\r\n        else if (hasAnyFlag(curtype, $NUMBER | $STRING)) {\r\n            destructible |= CANT_DESTRUCT;\r\n            let kind = NOT_GETSET;\r\n            if (identToken.str === 'get') {\r\n                kind = IS_GETTER;\r\n            }\r\n            else if (identToken.str === 'set') {\r\n                kind = IS_SETTER;\r\n            }\r\n            let litToken = curtok;\r\n            ASSERT_skipRex(litToken.str, lexerFlags);\r\n            AST_setLiteral(astProp, litToken);\r\n            parseObjectLikeMethodAfterKey(lexerFlags, isStatic, undefined, identToken, litToken, isClassMethod, NOT_CONSTRUCTOR, NOT_DyNAMIC_PROPERTY, kind, astProp);\r\n            ASSERT(curc !== $$IS_3D, 'this struct does not allow init/defaults');\r\n        }\r\n        else {\r\n            if (isClassMethod)\r\n                THROW('Class members have to be methods, for now');\r\n            THROW('Unexpected character after object literal property name ' + curtok);\r\n        }\r\n        return destructible;\r\n    }\r\n    function parseComputedModifierMethod(lexerFlags, isClassMethod, isStatic, isGenerator, modifierIdentToken, astProp) {\r\n        ASSERT(parseComputedModifierMethod.length === arguments.length, 'arg count');\r\n        ASSERT_skipRex('[', lexerFlags);\r\n        let assignable = parseExpression(lexerFlags, ALLOW_ASSIGNMENT, astProp);\r\n        skipAnyOrDieSingleChar($$SQUARE_R_5D, lexerFlags);\r\n        _parseComputedModifierMethod(lexerFlags, isClassMethod, isStatic, isGenerator, modifierIdentToken, astProp);\r\n        return assignable;\r\n    }\r\n    function _parseComputedModifierMethod(lexerFlags, isClassMethod, isStatic, isGenerator, modifierIdentToken, astProp) {\r\n        ASSERT(_parseComputedModifierMethod.length === arguments.length, 'arg count');\r\n        let modifier = modifierIdentToken ? modifierIdentToken.str : '';\r\n        let generatorState = (isGenerator && isGenerator.str === '*') ? WAS_GENERATOR : NOT_GENERATOR;\r\n        let asyncState = NOT_ASYNC;\r\n        let kind = NOT_GETSET;\r\n        let kindValue = '';\r\n        if (modifier === 'get') {\r\n            kind = IS_GETTER;\r\n            kindValue = 'get';\r\n        }\r\n        else if (modifier === 'set') {\r\n            kind = IS_SETTER;\r\n            kindValue = 'set';\r\n        }\r\n        else if (modifier === 'async') {\r\n            if (!allowAsyncFunctions) {\r\n                THROW('Async functions are not supported in the currently targeted language version');\r\n            }\r\n            else if (generatorState === WAS_GENERATOR && !allowAsyncGenerators) {\r\n                THROW('Async generators are not supported in the currently targeted language version');\r\n            }\r\n            else {\r\n                asyncState = WAS_ASYNC;\r\n                kindValue = isClassMethod === IS_CLASS_METHOD ? 'method' : 'init';\r\n            }\r\n        }\r\n        else {\r\n            kindValue = isClassMethod === IS_CLASS_METHOD ? 'method' : 'init';\r\n        }\r\n        if (isClassMethod === IS_CLASS_METHOD) {\r\n            AST_wrapClosed(astProp, 'MethodDefinition', 'key');\r\n            AST_set('static', !!isStatic);\r\n            AST_set('computed', true);\r\n            AST_set('kind', kindValue);\r\n            parseFunctionAfterKeyword(lexerFlags, DO_NOT_BIND, NOT_FUNC_DECL, NOT_FUNC_EXPR, generatorState, asyncState, IDENT_OPTIONAL, NOT_CONSTRUCTOR, IS_METHOD, kind, NOT_FUNCTION_STATEMENT, 'value');\r\n            AST_close('MethodDefinition');\r\n        }\r\n        else {\r\n            AST_wrapClosed(astProp, 'Property', 'key');\r\n            AST_set('kind', kindValue);\r\n            AST_set('method', kind === NOT_GETSET);\r\n            AST_set('computed', true);\r\n            parseFunctionAfterKeyword(lexerFlags, DO_NOT_BIND, NOT_FUNC_DECL, NOT_FUNC_EXPR, generatorState, asyncState, IDENT_OPTIONAL, NOT_CONSTRUCTOR, IS_METHOD, kind, NOT_FUNCTION_STATEMENT, 'value');\r\n            AST_set('shorthand', false);\r\n            AST_close('Property');\r\n            ASSERT(curc !== $$IS_3D, 'this struct does not allow init/defaults');\r\n        }\r\n    }\r\n    function verifyDestructible(destructible) {\r\n        if (hasAllFlags(destructible, CANT_DESTRUCT) && hasAllFlags(destructible, MUST_DESTRUCT)) {\r\n            THROW('Found a part that cant destruct and a part that must destruct so it is not destructible');\r\n        }\r\n    }\r\n    function verifyDestructibleForBinding(destructible, bindingType) {\r\n        if (hasAnyFlag(destructible, CANT_DESTRUCT)) {\r\n            THROW('The binding declaration is not destructible');\r\n        }\r\n        if (bindingType === BINDING_TYPE_ARG && hasAnyFlag(destructible, DESTRUCT_ASSIGN_ONLY)) {\r\n            THROW('This binding an not be used in function parameters because it is not destructible');\r\n        }\r\n    }\r\n    function parseOptionalDestructibleRestOfExpression(lexerFlags, bindingType, assignable, destructible, closingCharOrd, astProp) {\r\n        ASSERT(arguments.length === 6, 'arg count');\r\n        if (curc === $$COMMA_2C || curc === closingCharOrd) {\r\n            if (notAssignable(assignable)) {\r\n                destructible |= CANT_DESTRUCT;\r\n            }\r\n        }\r\n        else {\r\n            assignable = parseValueTail(lexerFlags, assignable, NOT_NEW_ARG, astProp);\r\n            let notAssign = curtok.str !== '=';\r\n            if (curc !== $$COMMA_2C && curc !== closingCharOrd) {\r\n                if (notAssign)\r\n                    destructible |= CANT_DESTRUCT;\r\n                assignable = parseExpressionFromOp(lexerFlags, assignable, astProp);\r\n                if (!notAssign)\r\n                    assignable = resetDestructibility(assignable);\r\n            }\r\n            else if (notAssign) {\r\n                if (bindingType !== BINDING_TYPE_NONE || notAssignable(assignable)) {\r\n                    destructible |= CANT_DESTRUCT;\r\n                }\r\n                else {\r\n                    destructible |= DESTRUCT_ASSIGN_ONLY;\r\n                }\r\n            }\r\n        }\r\n        return destructible | assignable;\r\n    }\r\n    function parseArrowableSpreadOrRest(lexerFlags, scoop, closingCharOrd, bindingType, groupTopLevel, asyncIdent, exportedNames, exportedBindings, astProp) {\r\n        ASSERT(parseArrowableSpreadOrRest.length === arguments.length, 'want all args');\r\n        ASSERT_skipRex('...', lexerFlags);\r\n        if (curc === $$DOT_2E && curtok.str === '...')\r\n            THROW('Can not rest twice');\r\n        AST_open(astProp, 'SpreadElement');\r\n        let destructible = _parseArrowableSpreadOrRest(lexerFlags, scoop, closingCharOrd, bindingType, groupTopLevel, asyncIdent, exportedNames, exportedBindings, 'argument');\r\n        AST_close('SpreadElement');\r\n        return destructible;\r\n    }\r\n    function _parseArrowableSpreadOrRest(lexerFlags, scoop, closingCharOrd, bindingType, groupTopLevel, asyncIdent, exportedNames, exportedBindings, astProp) {\r\n        ASSERT(_parseArrowableSpreadOrRest.length === arguments.length, 'arg count');\r\n        ASSERT(typeof bindingType === 'number', 'enum');\r\n        let a = groupTopLevel;\r\n        let destructible = MIGHT_DESTRUCT;\r\n        if (curtype === $IDENT) {\r\n            let identToken = curtok;\r\n            skipIdentSafeSlowAndExpensive(lexerFlags);\r\n            let assignBefore = curtok.str === '=';\r\n            let willBeSimple = curc === closingCharOrd || curc === $$COMMA_2C || assignBefore;\r\n            let lhsAssignable = parseValueAfterIdent(lexerFlags, identToken, bindingType, ALLOW_ASSIGNMENT, astProp);\r\n            ASSERT(!assignBefore || curtok.str === '=', 'parseValueAfterIdent should not consume the assignment');\r\n            let assignAfter = curtok.str === '=';\r\n            if (curc !== $$COMMA_2C && curc !== closingCharOrd) {\r\n                if (assignAfter) {\r\n                    if (notAssignable(lhsAssignable))\r\n                        THROW('Tried to assign to a value that was not assignable in arr lit/patt');\r\n                }\r\n                destructible |= CANT_DESTRUCT;\r\n                let rhsAssignable = parseExpressionFromOp(lexerFlags, lhsAssignable, astProp);\r\n                destructible |= resetDestructibility(rhsAssignable);\r\n            }\r\n            destructible |= lhsAssignable;\r\n            if (notAssignable(lhsAssignable)) {\r\n                destructible |= CANT_DESTRUCT;\r\n            }\r\n            else if (willBeSimple) {\r\n                SCOPE_addBinding(lexerFlags, scoop, identToken.str, bindingType, SKIP_DUPE_CHECKS, ORIGIN_NOT_VAR_DECL);\r\n                addNameToExports(exportedNames, identToken.str);\r\n                addBindingToExports(exportedBindings, identToken.str);\r\n            }\r\n            else {\r\n                destructible |= DESTRUCT_ASSIGN_ONLY;\r\n            }\r\n        }\r\n        else if (curc === $$SQUARE_L_5B) {\r\n            destructible |= parseArrayLiteralPattern(lexerFlags, scoop, bindingType, SKIP_INIT, exportedNames, exportedBindings, astProp);\r\n            destructible |= hasAllFlags(destructible, CANT_DESTRUCT) ? NOT_ASSIGNABLE : IS_ASSIGNABLE;\r\n            if (curtok.str !== '=' && curc !== closingCharOrd && curc !== $$COMMA_2C) {\r\n                destructible |= parseOptionalDestructibleRestOfExpression(lexerFlags, bindingType, destructible, destructible, closingCharOrd, astProp);\r\n            }\r\n        }\r\n        else if (curc === $$CURLY_L_7B) {\r\n            destructible = parseObjectLiteralPatternAndAssign(lexerFlags, scoop, bindingType, SKIP_INIT, NOT_CLASS_METHOD, exportedNames, exportedBindings, astProp);\r\n            destructible |= hasAllFlags(destructible, CANT_DESTRUCT) ? NOT_ASSIGNABLE : IS_ASSIGNABLE;\r\n            if (curtok.str !== '=' && curc !== closingCharOrd && curc !== $$COMMA_2C) {\r\n                destructible = parseOptionalDestructibleRestOfExpression(lexerFlags, bindingType, destructible, destructible, closingCharOrd, astProp);\r\n                console.log('after op', '' + curtok, D_DEBUG(destructible));\r\n            }\r\n        }\r\n        else if (curc === closingCharOrd) {\r\n            THROW('The rest operator is missing an argument');\r\n        }\r\n        else {\r\n            if (bindingType !== BINDING_TYPE_NONE)\r\n                THROW('The rest arg was not destructible as it can only apply to an identifier or array/object pattern arg');\r\n            let assignable = parseValue(lexerFlags, ALLOW_ASSIGNMENT, NOT_NEW_ARG, astProp);\r\n            if (curtok.str === '=' && curc !== closingCharOrd && curc !== $$COMMA_2C) {\r\n                if (notAssignable(assignable)) {\r\n                    THROW('Cannot assign to lhs, not destructible with this initializer');\r\n                }\r\n                destructible |= parseExpressionFromOp(lexerFlags, assignable, astProp);\r\n                destructible |= CANT_DESTRUCT;\r\n            }\r\n            else {\r\n                if (curc !== $$COMMA_2C && curc !== closingCharOrd) {\r\n                    assignable = parseExpressionFromOp(lexerFlags, assignable, astProp);\r\n                }\r\n                else {\r\n                }\r\n                if (isAssignable(assignable)) {\r\n                    destructible |= DESTRUCT_ASSIGN_ONLY;\r\n                }\r\n                else {\r\n                    destructible |= CANT_DESTRUCT;\r\n                }\r\n                destructible |= assignable;\r\n            }\r\n            return destructible;\r\n        }\r\n        if (curc !== closingCharOrd) {\r\n            if (bindingType === BINDING_TYPE_ARG) {\r\n                if (!asyncIdent) {\r\n                    console.log('rest crashed, closingCharOrd=' + String.fromCharCode(closingCharOrd) + ', token: ' + curtok);\r\n                    if (curtok.str === '=')\r\n                        THROW('The rest argument can not have an initializer');\r\n                    else if (curtok.str === ',')\r\n                        THROW('The rest argument was not destructible as it must be last and can not have a trailing comma');\r\n                    else\r\n                        THROW('The rest argument must the be last parameter');\r\n                }\r\n            }\r\n            if (curc === $$IS_3D && curtok.str === '=') {\r\n                verifyDestructible(destructible | MUST_DESTRUCT);\r\n                destructible = CANT_DESTRUCT;\r\n                AST_destruct(astProp);\r\n                AST_wrapClosed(astProp, 'AssignmentExpression', 'left');\r\n                AST_set('operator', '=');\r\n                ASSERT_skipRex('=', lexerFlags);\r\n                destructible |= parseExpression(lexerFlags, ALLOW_ASSIGNMENT, 'right');\r\n                AST_close('AssignmentExpression');\r\n            }\r\n            else {\r\n                let assignable = parseValueTail(lexerFlags, destructible, NOT_NEW_ARG, astProp);\r\n                destructible |= parseExpressionFromOp(lexerFlags, assignable, astProp);\r\n            }\r\n            destructible |= CANT_DESTRUCT;\r\n        }\r\n        return destructible;\r\n    }\r\n    function parseObjectLikeMethodAfterKey(lexerFlags, isStatic, isGenerator, asyncgetsetToken, keyToken, isClassMethod, isConstructor, isDynamic, isGetSet, astProp) {\r\n        ASSERT(arguments.length === parseObjectLikeMethodAfterKey.length, 'want args');\r\n        ASSERT(asyncgetsetToken === undefined || (asyncgetsetToken.str === 'get' || asyncgetsetToken.str === 'set' || asyncgetsetToken.str === 'async'), 'either pass on token or undefined');\r\n        ASSERT(isStatic === undefined || isStatic.type === $IDENT, 'isStatic should be token or undefined');\r\n        ASSERT(isGenerator === undefined || isGenerator.type === $PUNCTUATOR, 'isGenerator should be * token or undefined');\r\n        ASSERT(keyToken === undefined || keyToken.str, 'keyToken is a token');\r\n        ASSERT(keyToken === undefined || (keyToken.type === $IDENT || hasAnyFlag(keyToken.type, $STRING | $NUMBER)), 'keyToken is a string or ident', '' + keyToken);\r\n        ASSERT(typeof isClassMethod === 'boolean', 'isClassMethod is a bool');\r\n        ASSERT(typeof isDynamic === 'boolean', 'isDynamic is a bool');\r\n        let modifier = asyncgetsetToken ? asyncgetsetToken.str : '';\r\n        let asyncState = NOT_ASYNC;\r\n        let generatorState = isGenerator ? WAS_GENERATOR : NOT_GENERATOR;\r\n        if (modifier === 'async') {\r\n            if (!allowAsyncFunctions) {\r\n                THROW('Async functions are not supported in the currently targeted language version');\r\n            }\r\n            else if (isGenerator && !allowAsyncGenerators) {\r\n                THROW('Async generators are not supported in the currently targeted language version');\r\n            }\r\n            else {\r\n                asyncState = WAS_ASYNC;\r\n            }\r\n        }\r\n        if (isClassMethod) {\r\n            AST_wrapClosed(astProp, 'MethodDefinition', 'key');\r\n            AST_set('static', !!isStatic);\r\n            AST_set('computed', !!isDynamic);\r\n            if (isConstructor) {\r\n                if (isGetSet === IS_GETTER || isGetSet === IS_SETTER || isGenerator || asyncState === WAS_ASYNC) {\r\n                    THROW('The constructor can not be a getter, setter, async, or generator');\r\n                }\r\n                AST_set('kind', 'constructor');\r\n            }\r\n            else if (isGetSet === IS_GETTER) {\r\n                AST_set('kind', 'get');\r\n                if (keyToken && !isStatic && ((keyToken.type === $IDENT && keyToken.canon === 'constructor') ||\r\n                    (hasAllFlags(keyToken.type, $STRING) && keyToken.str.slice(1, -1) === 'constructor')))\r\n                    THROW('Constructors cannot be get/set/async/generators');\r\n            }\r\n            else if (isGetSet === IS_SETTER) {\r\n                AST_set('kind', 'set');\r\n                if (keyToken && !isStatic && ((keyToken.type === $IDENT && keyToken.canon === 'constructor') ||\r\n                    (hasAllFlags(keyToken.type, $STRING) && keyToken.str.slice(1, -1) === 'constructor')))\r\n                    THROW('Constructors cannot be get/set/async/generators');\r\n            }\r\n            else {\r\n                ASSERT(isGetSet === NOT_GETSET, 'enum');\r\n                AST_set('kind', 'method');\r\n                if ((isGenerator || asyncState === WAS_ASYNC) && keyToken && !isStatic && ((keyToken.type === $IDENT && keyToken.canon === 'constructor') ||\r\n                    (hasAllFlags(keyToken.type, $STRING) && keyToken.str.slice(1, -1) === 'constructor')))\r\n                    THROW('Constructors cannot be get/set/async/generators');\r\n            }\r\n            ASSERT(curc === $$PAREN_L_28, 'should have parsed everything before the method args now');\r\n            parseFunctionAfterKeyword(lexerFlags, DO_NOT_BIND, NOT_FUNC_DECL, NOT_FUNC_EXPR, generatorState, asyncState, IDENT_OPTIONAL, isConstructor, IS_METHOD, isGetSet, NOT_FUNCTION_STATEMENT, 'value');\r\n            AST_close('MethodDefinition');\r\n        }\r\n        else {\r\n            if (isStatic)\r\n                THROW('Only class methods can be `static`');\r\n            ASSERT(isConstructor === NOT_CONSTRUCTOR, 'should not have constructor for object');\r\n            AST_wrapClosed(astProp, 'Property', 'key');\r\n            if (isGetSet === IS_GETTER) {\r\n                AST_set('kind', 'get');\r\n            }\r\n            else if (isGetSet === IS_SETTER) {\r\n                AST_set('kind', 'set');\r\n            }\r\n            else {\r\n                AST_set('kind', 'init');\r\n            }\r\n            AST_set('method', isGetSet === NOT_GETSET);\r\n            AST_set('computed', !!isDynamic);\r\n            ASSERT(curc === $$PAREN_L_28, 'should have parsed everything before the method args now');\r\n            parseFunctionAfterKeyword(lexerFlags, DO_NOT_BIND, NOT_FUNC_DECL, NOT_FUNC_EXPR, generatorState, asyncState, IDENT_OPTIONAL, NOT_CONSTRUCTOR, IS_METHOD, isGetSet, NOT_FUNCTION_STATEMENT, 'value');\r\n            AST_set('shorthand', false);\r\n            AST_close('Property');\r\n        }\r\n    }\r\n    function resetDestructibility(assignable) {\r\n        return (assignable | CANT_DESTRUCT | DESTRUCT_ASSIGN_ONLY) ^ (CANT_DESTRUCT | DESTRUCT_ASSIGN_ONLY);\r\n    }\r\n    function logPath() {\r\n        console.log('logPath: ' + _path.map((o) => o.type).join(' '));\r\n    }\r\n    function logTree() {\r\n        console.log('logTree: ' + inspect(_tree, false, null));\r\n    }\r\n    let initialLexerFlags = sansFlag(INITIAL_LEXER_FLAGS | ((options_strictMode || goalMode === GOAL_MODULE) ? LF_STRICT_MODE : 0), LF_FOR_REGEX);\r\n    init(initialLexerFlags);\r\n    parseTopLevels(initialLexerFlags);\r\n    return {\r\n        ast: _tree,\r\n        tokens: tok.tokens,\r\n        tokenCountSolid: tok.getTokenCountAny(),\r\n        tokenCountAny: tok.getTokenCountSolid(),\r\n    };\r\n}\r\nfunction getGenericTokenType(type) {\r\n    let redundantFlags = (($NUMBER_HEX | $NUMBER_DEC | $NUMBER_BIN | $NUMBER_OCT | $NUMBER_OLD | $NUMBER) ^ $NUMBER) |\r\n        (($REGEXU | $REGEX) ^ $REGEX) |\r\n        (($STRING_DOUBLE | $STRING_SINGLE | $STRING) ^ $STRING) |\r\n        (($TICK_BODY | $TICK_HEAD | $TICK_PURE | $TICK_TAIL | $TICK_BAD_ESCAPE | $TICK) ^ $TICK);\r\n    return (type | redundantFlags) ^ redundantFlags;\r\n}\r\nfunction D_DEBUG(d) {\r\n    if (d === 0) {\r\n        return '(d)=MIGHT_DESTRUCT|ASSIGNABLE_UNDETERMINED';\r\n    }\r\n    let arr = [];\r\n    if (d & CANT_DESTRUCT) {\r\n        arr.push('CANT_DESTRUCT');\r\n        d ^= CANT_DESTRUCT;\r\n    }\r\n    if (d & MUST_DESTRUCT) {\r\n        arr.push('MUST_DESTRUCT');\r\n        d ^= MUST_DESTRUCT;\r\n    }\r\n    if (d & DESTRUCT_ASSIGN_ONLY) {\r\n        arr.push('DESTRUCT_ASSIGN_ONLY');\r\n        d ^= DESTRUCT_ASSIGN_ONLY;\r\n    }\r\n    if (d & DESTRUCTIBLE_PIGGY_BACK_WAS_CONSTRUCTOR) {\r\n        arr.push('DESTRUCTIBLE_PIGGY_BACK_WAS_CONSTRUCTOR');\r\n        d ^= DESTRUCTIBLE_PIGGY_BACK_WAS_CONSTRUCTOR;\r\n    }\r\n    if (d & DESTRUCTIBLE_PIGGY_BACK_WAS_PROTO) {\r\n        arr.push('DESTRUCTIBLE_PIGGY_BACK_WAS_PROTO');\r\n        d ^= DESTRUCTIBLE_PIGGY_BACK_WAS_PROTO;\r\n    }\r\n    if (d & DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_OR_YIELD_KEYWORD) {\r\n        arr.push('DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_OR_YIELD_KEYWORD');\r\n        d ^= DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_OR_YIELD_KEYWORD;\r\n    }\r\n    if (d & DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_VARNAME) {\r\n        arr.push('DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_VARNAME');\r\n        d ^= DESTRUCTIBLE_PIGGY_BACK_SAW_AWAIT_VARNAME;\r\n    }\r\n    if (d & DESTRUCTIBLE_PIGGY_BACK_SAW_YIELD_VARNAME) {\r\n        arr.push('DESTRUCTIBLE_PIGGY_BACK_SAW_YIELD_VARNAME');\r\n        d ^= DESTRUCTIBLE_PIGGY_BACK_SAW_YIELD_VARNAME;\r\n    }\r\n    if (d & NOT_ASSIGNABLE) {\r\n        arr.push('NOT_ASSIGNABLE');\r\n        d ^= NOT_ASSIGNABLE;\r\n    }\r\n    if (d & IS_ASSIGNABLE) {\r\n        arr.push('IS_ASSIGNABLE');\r\n        d ^= IS_ASSIGNABLE;\r\n    }\r\n    if (d !== 0) {\r\n        console.log('Gathered flags so far:', arr.join(', '));\r\n        _THROW('D_DEBUG: unknown flags left:', d.toString(2));\r\n    }\r\n    return arr.join(', ');\r\n}\r\nfunction isTemplateStart(curtype) {\r\n    return (curtype & $TICK_PURE) === $TICK_PURE || (curtype & $TICK_HEAD) === $TICK_HEAD;\r\n}\r\nexport function parseScript(source, _) {\r\n    return ZeParser(source, false);\r\n}\r\nexport function parseSource(source, _) {\r\n    return ZeParser(source, false);\r\n}\r\nexport default ZeParser;\r\nexport { COLLECT_TOKENS_NONE, COLLECT_TOKENS_SOLID, COLLECT_TOKENS_ALL, GOAL_MODULE, GOAL_SCRIPT, VERSION_EXPONENTIATION, VERSION_WHATEVER, };\r\n//# sourceMappingURL=zeparser.js.map","dtsmap":{"name":"D:/cherow_gh/cherow1/zeparser.d.ts.map","writeByteOrderMark":false,"text":"{\"version\":3,\"file\":\"zeparser.d.ts\",\"sourceRoot\":\"\",\"sources\":[\"src/zeparser.ts\"],\"names\":[],\"mappings\":\"AAiJA,OAAoB,EA0BlB,mBAAmB,EACnB,oBAAoB,EACpB,kBAAkB,EAIlB,WAAW,EACX,WAAW,EA+BZ,MAAM,oBAAoB,CAAC;AAI5B,QAAA,MAAM,sBAAsB,IAAI,CAAC;AAMjC,QAAA,MAAM,gBAAgB,QAAW,CAAC;AAoHlC,iBAAS,QAAQ,CAAC,IAAI,EAAE,GAAG,EAAE,QAAQ,UAAc,EAAE,aAAa,SAAsB,EAAE,OAAO,GAAE,GAAQ,GAAI,GAAG,CAy2OjH;AA4ED,wBAAgB,WAAW,CAAC,MAAM,EAAE,MAAM,EAAE,CAAC,EAAE,GAAG,GAAG,IAAI,OAExD;AAED,wBAAgB,WAAW,CAAC,MAAM,EAAE,MAAM,EAAE,CAAC,EAAE,GAAG,GAAG,IAAI,OAEtD;AAEH,eAAe,QAAQ,CAAC;AACxB,OAAO,EAGL,mBAAmB,EACnB,oBAAoB,EACpB,kBAAkB,EAElB,WAAW,EACX,WAAW,EAEX,sBAAsB,EACtB,gBAAgB,GACjB,CAAC\"}"},"dts":{"name":"D:/cherow_gh/cherow1/zeparser.d.ts","writeByteOrderMark":false,"text":"import { COLLECT_TOKENS_NONE, COLLECT_TOKENS_SOLID, COLLECT_TOKENS_ALL, GOAL_MODULE, GOAL_SCRIPT } from '../src/zetokenizer';\r\ndeclare const VERSION_EXPONENTIATION = 7;\r\ndeclare const VERSION_WHATEVER: number;\r\ndeclare function ZeParser(code: any, goalMode?: boolean, collectTokens?: number, options?: any): any;\r\nexport declare function parseScript(source: String, _: any | void): any;\r\nexport declare function parseSource(source: String, _: any | void): any;\r\nexport default ZeParser;\r\nexport { COLLECT_TOKENS_NONE, COLLECT_TOKENS_SOLID, COLLECT_TOKENS_ALL, GOAL_MODULE, GOAL_SCRIPT, VERSION_EXPONENTIATION, VERSION_WHATEVER, };\r\n//# sourceMappingURL=zeparser.d.ts.map"}}
