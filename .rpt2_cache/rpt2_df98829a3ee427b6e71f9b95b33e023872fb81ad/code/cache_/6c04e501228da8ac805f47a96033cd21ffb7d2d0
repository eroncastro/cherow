{"code":"import { isIdentifierPart } from '../chars';\r\nimport { report } from '../errors';\r\nimport { fromCodePoint } from './common';\r\nexport var RegexState;\r\n(function (RegexState) {\r\n    RegexState[RegexState[\"Empty\"] = 0] = \"Empty\";\r\n    RegexState[RegexState[\"Escape\"] = 1] = \"Escape\";\r\n    RegexState[RegexState[\"Class\"] = 2] = \"Class\";\r\n})(RegexState || (RegexState = {}));\r\nexport var RegexFlags;\r\n(function (RegexFlags) {\r\n    RegexFlags[RegexFlags[\"Empty\"] = 0] = \"Empty\";\r\n    RegexFlags[RegexFlags[\"IgnoreCase\"] = 1] = \"IgnoreCase\";\r\n    RegexFlags[RegexFlags[\"Global\"] = 2] = \"Global\";\r\n    RegexFlags[RegexFlags[\"Multiline\"] = 4] = \"Multiline\";\r\n    RegexFlags[RegexFlags[\"Unicode\"] = 8] = \"Unicode\";\r\n    RegexFlags[RegexFlags[\"Sticky\"] = 16] = \"Sticky\";\r\n    RegexFlags[RegexFlags[\"DotAll\"] = 32] = \"DotAll\";\r\n})(RegexFlags || (RegexFlags = {}));\r\nexport function scanRegularExpression(state, context) {\r\n    const bodyStart = state.index;\r\n    let preparseState = RegexState.Empty;\r\n    loop: while (true) {\r\n        const ch = state.source.charCodeAt(state.index);\r\n        state.index++;\r\n        state.column++;\r\n        if (preparseState & RegexState.Escape) {\r\n            preparseState &= ~RegexState.Escape;\r\n        }\r\n        else {\r\n            switch (ch) {\r\n                case 47:\r\n                    if (!preparseState)\r\n                        break loop;\r\n                    else\r\n                        break;\r\n                case 92:\r\n                    preparseState |= RegexState.Escape;\r\n                    break;\r\n                case 91:\r\n                    preparseState |= RegexState.Class;\r\n                    break;\r\n                case 93:\r\n                    preparseState &= RegexState.Escape;\r\n                    break;\r\n                case 13:\r\n                case 10:\r\n                case 8232:\r\n                case 8233:\r\n                    report(state, 64);\r\n                default:\r\n            }\r\n        }\r\n        if (state.index >= state.source.length) {\r\n            report(state, 64);\r\n        }\r\n    }\r\n    const bodyEnd = state.index - 1;\r\n    let mask = RegexFlags.Empty;\r\n    const { index: flagStart } = state;\r\n    loop: while (state.index < state.source.length) {\r\n        const code = state.source.charCodeAt(state.index);\r\n        switch (code) {\r\n            case 103:\r\n                if (mask & RegexFlags.Global)\r\n                    report(state, 26, 'g');\r\n                mask |= RegexFlags.Global;\r\n                break;\r\n            case 105:\r\n                if (mask & RegexFlags.IgnoreCase)\r\n                    report(state, 26, 'i');\r\n                mask |= RegexFlags.IgnoreCase;\r\n                break;\r\n            case 109:\r\n                if (mask & RegexFlags.Multiline)\r\n                    report(state, 26, 'm');\r\n                mask |= RegexFlags.Multiline;\r\n                break;\r\n            case 117:\r\n                if (mask & RegexFlags.Unicode)\r\n                    report(state, 26, 'u');\r\n                mask |= RegexFlags.Unicode;\r\n                break;\r\n            case 121:\r\n                if (mask & RegexFlags.Sticky)\r\n                    report(state, 26, 'y');\r\n                mask |= RegexFlags.Sticky;\r\n                break;\r\n            case 115:\r\n                if (mask & RegexFlags.DotAll)\r\n                    report(state, 26, 's');\r\n                mask |= RegexFlags.DotAll;\r\n                break;\r\n            default:\r\n                if (!isIdentifierPart(code))\r\n                    break loop;\r\n                report(state, 65, fromCodePoint(code));\r\n        }\r\n        state.index++;\r\n        state.column++;\r\n    }\r\n    const flags = state.source.slice(flagStart, state.index);\r\n    const pattern = state.source.slice(bodyStart, bodyEnd);\r\n    state.tokenRegExp = { pattern, flags };\r\n    if (context & 8)\r\n        state.tokenRaw = state.source.slice(state.startIndex, state.index);\r\n    state.tokenValue = validate(state, pattern, flags);\r\n    return 131076;\r\n}\r\nfunction validate(state, pattern, flags) {\r\n    try {\r\n        RegExp(pattern);\r\n    }\r\n    catch (e) {\r\n        report(state, 64);\r\n    }\r\n    try {\r\n        return new RegExp(pattern, flags);\r\n    }\r\n    catch (e) {\r\n        return null;\r\n    }\r\n}\r\n//# sourceMappingURL=regexp.js.map","map":"{\"version\":3,\"file\":\"regexp.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/scanner/regexp.ts\"],\"names\":[],\"mappings\":\"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\"}","dtsmap":{"name":"D:/cherow_gh/cherow1/scanner/regexp.d.ts.map","writeByteOrderMark":false,"text":"{\"version\":3,\"file\":\"regexp.d.ts\",\"sourceRoot\":\"\",\"sources\":[\"../src/scanner/regexp.ts\"],\"names\":[],\"mappings\":\"AACA,OAAO,EAAE,OAAO,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AAEjD,OAAO,EAAE,KAAK,EAAE,MAAM,UAAU,CAAC;AAGjC,oBAAY,UAAU;IACpB,KAAK,IAAI;IACT,MAAM,IAAM;IACZ,KAAK,IAAM;CACZ;AAED,oBAAY,UAAU;IACpB,KAAK,IAAI;IACT,UAAU,IAAS;IACnB,MAAM,IAAS;IACf,SAAS,IAAS;IAClB,OAAO,IAAS;IAChB,MAAM,KAAS;IACf,MAAM,KAAS;CAChB;AASD,wBAAgB,qBAAqB,CAAC,KAAK,EAAE,WAAW,EAAE,OAAO,EAAE,OAAO,GAAG,KAAK,CAoGjF\"}"},"dts":{"name":"D:/cherow_gh/cherow1/scanner/regexp.d.ts","writeByteOrderMark":false,"text":"import { Context, ParserState } from '../common';\r\nimport { Token } from '../token';\r\nexport declare enum RegexState {\r\n    Empty = 0,\r\n    Escape = 1,\r\n    Class = 2\r\n}\r\nexport declare enum RegexFlags {\r\n    Empty = 0,\r\n    IgnoreCase = 1,\r\n    Global = 2,\r\n    Multiline = 4,\r\n    Unicode = 8,\r\n    Sticky = 16,\r\n    DotAll = 32\r\n}\r\nexport declare function scanRegularExpression(state: ParserState, context: Context): Token;\r\n//# sourceMappingURL=regexp.d.ts.map"}}
